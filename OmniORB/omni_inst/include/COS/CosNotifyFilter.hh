// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __CosNotifyFilter_hh__
#define __CosNotifyFilter_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_CosNotifyFilter
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_CosNotifyFilter
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosNotifyFilter
#endif


#include "COS_sysdep.h"
#ifndef __CosNotification_hh_EXTERNAL_GUARD__
#define __CosNotification_hh_EXTERNAL_GUARD__
#include "CosNotification.hh"
#endif
#ifndef __CosEventComm_hh_EXTERNAL_GUARD__
#define __CosEventComm_hh_EXTERNAL_GUARD__
#include "CosEventComm.hh"
#endif
#ifndef __CosNotifyComm_hh_EXTERNAL_GUARD__
#define __CosNotifyComm_hh_EXTERNAL_GUARD__
#include "CosNotifyComm.hh"
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE CosNotifyFilter

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConstraintID;

  typedef ::CORBA::Long ConstraintID;
  typedef ::CORBA::Long_out ConstraintID_out;

  struct ConstraintExp {
    typedef _CORBA_ConstrType_Variable_Var<ConstraintExp> _var_type;

    
    CosNotification::EventTypeSeq event_types;

    ::CORBA::String_member constraint_expr;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ConstraintExp::_var_type ConstraintExp_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ConstraintExp,ConstraintExp_var > ConstraintExp_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConstraintExp;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConstraintIDSeq;

  class ConstraintIDSeq_var;

  class ConstraintIDSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ConstraintID, 4, 4 >  {
  public:
    typedef ConstraintIDSeq_var _var_type;
    inline ConstraintIDSeq() {}
    inline ConstraintIDSeq(const ConstraintIDSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ConstraintID, 4, 4 > (_s) {}

    inline ConstraintIDSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ConstraintID, 4, 4 > (_max) {}
    inline ConstraintIDSeq(_CORBA_ULong _max, _CORBA_ULong _len, ConstraintID* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ConstraintID, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline ConstraintIDSeq& operator = (const ConstraintIDSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ConstraintID, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class ConstraintIDSeq_out;

  class ConstraintIDSeq_var {
  public:
    inline ConstraintIDSeq_var() : _pd_seq(0) {}
    inline ConstraintIDSeq_var(ConstraintIDSeq* _s) : _pd_seq(_s) {}
    inline ConstraintIDSeq_var(const ConstraintIDSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new ConstraintIDSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~ConstraintIDSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline ConstraintIDSeq_var& operator = (ConstraintIDSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ConstraintIDSeq_var& operator = (const ConstraintIDSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new ConstraintIDSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ConstraintID& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ConstraintIDSeq* operator -> () { return _pd_seq; }
    inline const ConstraintIDSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ConstraintIDSeq& () const { return *_pd_seq; }
#else
    inline operator const ConstraintIDSeq& () const { return *_pd_seq; }
    inline operator ConstraintIDSeq& () { return *_pd_seq; }
#endif
      
    inline const ConstraintIDSeq& in() const { return *_pd_seq; }
    inline ConstraintIDSeq&       inout()    { return *_pd_seq; }
    inline ConstraintIDSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ConstraintIDSeq* _retn() { ConstraintIDSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ConstraintIDSeq_out;
    
  private:
    ConstraintIDSeq* _pd_seq;
  };

  class ConstraintIDSeq_out {
  public:
    inline ConstraintIDSeq_out(ConstraintIDSeq*& _s) : _data(_s) { _data = 0; }
    inline ConstraintIDSeq_out(ConstraintIDSeq_var& _s)
      : _data(_s._pd_seq) { _s = (ConstraintIDSeq*) 0; }
    inline ConstraintIDSeq_out(const ConstraintIDSeq_out& _s) : _data(_s._data) {}
    inline ConstraintIDSeq_out& operator = (const ConstraintIDSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ConstraintIDSeq_out& operator = (ConstraintIDSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator ConstraintIDSeq*&()  { return _data; }
    inline ConstraintIDSeq*& ptr()       { return _data; }
    inline ConstraintIDSeq* operator->() { return _data; }

    inline ConstraintID& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ConstraintIDSeq*& _data;

  private:
    ConstraintIDSeq_out();
    ConstraintIDSeq_out& operator=(const ConstraintIDSeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConstraintExpSeq;

  class ConstraintExpSeq_var;

  class ConstraintExpSeq : public _CORBA_Unbounded_Sequence< ConstraintExp >  {
  public:
    typedef ConstraintExpSeq_var _var_type;
    inline ConstraintExpSeq() {}
    inline ConstraintExpSeq(const ConstraintExpSeq& _s)
      : _CORBA_Unbounded_Sequence< ConstraintExp > (_s) {}

    inline ConstraintExpSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ConstraintExp > (_max) {}
    inline ConstraintExpSeq(_CORBA_ULong _max, _CORBA_ULong _len, ConstraintExp* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ConstraintExp > (_max, _len, _val, _rel) {}

  

    inline ConstraintExpSeq& operator = (const ConstraintExpSeq& _s) {
      _CORBA_Unbounded_Sequence< ConstraintExp > ::operator=(_s);
      return *this;
    }
  };

  class ConstraintExpSeq_out;

  class ConstraintExpSeq_var {
  public:
    inline ConstraintExpSeq_var() : _pd_seq(0) {}
    inline ConstraintExpSeq_var(ConstraintExpSeq* _s) : _pd_seq(_s) {}
    inline ConstraintExpSeq_var(const ConstraintExpSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new ConstraintExpSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~ConstraintExpSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline ConstraintExpSeq_var& operator = (ConstraintExpSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ConstraintExpSeq_var& operator = (const ConstraintExpSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new ConstraintExpSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ConstraintExp& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ConstraintExpSeq* operator -> () { return _pd_seq; }
    inline const ConstraintExpSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ConstraintExpSeq& () const { return *_pd_seq; }
#else
    inline operator const ConstraintExpSeq& () const { return *_pd_seq; }
    inline operator ConstraintExpSeq& () { return *_pd_seq; }
#endif
      
    inline const ConstraintExpSeq& in() const { return *_pd_seq; }
    inline ConstraintExpSeq&       inout()    { return *_pd_seq; }
    inline ConstraintExpSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ConstraintExpSeq* _retn() { ConstraintExpSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ConstraintExpSeq_out;
    
  private:
    ConstraintExpSeq* _pd_seq;
  };

  class ConstraintExpSeq_out {
  public:
    inline ConstraintExpSeq_out(ConstraintExpSeq*& _s) : _data(_s) { _data = 0; }
    inline ConstraintExpSeq_out(ConstraintExpSeq_var& _s)
      : _data(_s._pd_seq) { _s = (ConstraintExpSeq*) 0; }
    inline ConstraintExpSeq_out(const ConstraintExpSeq_out& _s) : _data(_s._data) {}
    inline ConstraintExpSeq_out& operator = (const ConstraintExpSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ConstraintExpSeq_out& operator = (ConstraintExpSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator ConstraintExpSeq*&()  { return _data; }
    inline ConstraintExpSeq*& ptr()       { return _data; }
    inline ConstraintExpSeq* operator->() { return _data; }

    inline ConstraintExp& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ConstraintExpSeq*& _data;

  private:
    ConstraintExpSeq_out();
    ConstraintExpSeq_out& operator=(const ConstraintExpSeq_var&);
  };

  struct ConstraintInfo {
    typedef _CORBA_ConstrType_Variable_Var<ConstraintInfo> _var_type;

    
    ConstraintExp constraint_expression;

    ConstraintID constraint_id;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ConstraintInfo::_var_type ConstraintInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ConstraintInfo,ConstraintInfo_var > ConstraintInfo_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConstraintInfo;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConstraintInfoSeq;

  class ConstraintInfoSeq_var;

  class ConstraintInfoSeq : public _CORBA_Unbounded_Sequence< ConstraintInfo >  {
  public:
    typedef ConstraintInfoSeq_var _var_type;
    inline ConstraintInfoSeq() {}
    inline ConstraintInfoSeq(const ConstraintInfoSeq& _s)
      : _CORBA_Unbounded_Sequence< ConstraintInfo > (_s) {}

    inline ConstraintInfoSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ConstraintInfo > (_max) {}
    inline ConstraintInfoSeq(_CORBA_ULong _max, _CORBA_ULong _len, ConstraintInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ConstraintInfo > (_max, _len, _val, _rel) {}

  

    inline ConstraintInfoSeq& operator = (const ConstraintInfoSeq& _s) {
      _CORBA_Unbounded_Sequence< ConstraintInfo > ::operator=(_s);
      return *this;
    }
  };

  class ConstraintInfoSeq_out;

  class ConstraintInfoSeq_var {
  public:
    inline ConstraintInfoSeq_var() : _pd_seq(0) {}
    inline ConstraintInfoSeq_var(ConstraintInfoSeq* _s) : _pd_seq(_s) {}
    inline ConstraintInfoSeq_var(const ConstraintInfoSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new ConstraintInfoSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~ConstraintInfoSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline ConstraintInfoSeq_var& operator = (ConstraintInfoSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ConstraintInfoSeq_var& operator = (const ConstraintInfoSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new ConstraintInfoSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ConstraintInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ConstraintInfoSeq* operator -> () { return _pd_seq; }
    inline const ConstraintInfoSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ConstraintInfoSeq& () const { return *_pd_seq; }
#else
    inline operator const ConstraintInfoSeq& () const { return *_pd_seq; }
    inline operator ConstraintInfoSeq& () { return *_pd_seq; }
#endif
      
    inline const ConstraintInfoSeq& in() const { return *_pd_seq; }
    inline ConstraintInfoSeq&       inout()    { return *_pd_seq; }
    inline ConstraintInfoSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ConstraintInfoSeq* _retn() { ConstraintInfoSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ConstraintInfoSeq_out;
    
  private:
    ConstraintInfoSeq* _pd_seq;
  };

  class ConstraintInfoSeq_out {
  public:
    inline ConstraintInfoSeq_out(ConstraintInfoSeq*& _s) : _data(_s) { _data = 0; }
    inline ConstraintInfoSeq_out(ConstraintInfoSeq_var& _s)
      : _data(_s._pd_seq) { _s = (ConstraintInfoSeq*) 0; }
    inline ConstraintInfoSeq_out(const ConstraintInfoSeq_out& _s) : _data(_s._data) {}
    inline ConstraintInfoSeq_out& operator = (const ConstraintInfoSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ConstraintInfoSeq_out& operator = (ConstraintInfoSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator ConstraintInfoSeq*&()  { return _data; }
    inline ConstraintInfoSeq*& ptr()       { return _data; }
    inline ConstraintInfoSeq* operator->() { return _data; }

    inline ConstraintInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ConstraintInfoSeq*& _data;

  private:
    ConstraintInfoSeq_out();
    ConstraintInfoSeq_out& operator=(const ConstraintInfoSeq_var&);
  };

  struct MappingConstraintPair {
    typedef _CORBA_ConstrType_Variable_Var<MappingConstraintPair> _var_type;

    
    ConstraintExp constraint_expression;

    ::CORBA::Any result_to_set;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef MappingConstraintPair::_var_type MappingConstraintPair_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< MappingConstraintPair,MappingConstraintPair_var > MappingConstraintPair_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MappingConstraintPair;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MappingConstraintPairSeq;

  class MappingConstraintPairSeq_var;

  class MappingConstraintPairSeq : public _CORBA_Unbounded_Sequence< MappingConstraintPair >  {
  public:
    typedef MappingConstraintPairSeq_var _var_type;
    inline MappingConstraintPairSeq() {}
    inline MappingConstraintPairSeq(const MappingConstraintPairSeq& _s)
      : _CORBA_Unbounded_Sequence< MappingConstraintPair > (_s) {}

    inline MappingConstraintPairSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< MappingConstraintPair > (_max) {}
    inline MappingConstraintPairSeq(_CORBA_ULong _max, _CORBA_ULong _len, MappingConstraintPair* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< MappingConstraintPair > (_max, _len, _val, _rel) {}

  

    inline MappingConstraintPairSeq& operator = (const MappingConstraintPairSeq& _s) {
      _CORBA_Unbounded_Sequence< MappingConstraintPair > ::operator=(_s);
      return *this;
    }
  };

  class MappingConstraintPairSeq_out;

  class MappingConstraintPairSeq_var {
  public:
    inline MappingConstraintPairSeq_var() : _pd_seq(0) {}
    inline MappingConstraintPairSeq_var(MappingConstraintPairSeq* _s) : _pd_seq(_s) {}
    inline MappingConstraintPairSeq_var(const MappingConstraintPairSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new MappingConstraintPairSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~MappingConstraintPairSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline MappingConstraintPairSeq_var& operator = (MappingConstraintPairSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline MappingConstraintPairSeq_var& operator = (const MappingConstraintPairSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new MappingConstraintPairSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline MappingConstraintPair& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline MappingConstraintPairSeq* operator -> () { return _pd_seq; }
    inline const MappingConstraintPairSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator MappingConstraintPairSeq& () const { return *_pd_seq; }
#else
    inline operator const MappingConstraintPairSeq& () const { return *_pd_seq; }
    inline operator MappingConstraintPairSeq& () { return *_pd_seq; }
#endif
      
    inline const MappingConstraintPairSeq& in() const { return *_pd_seq; }
    inline MappingConstraintPairSeq&       inout()    { return *_pd_seq; }
    inline MappingConstraintPairSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline MappingConstraintPairSeq* _retn() { MappingConstraintPairSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class MappingConstraintPairSeq_out;
    
  private:
    MappingConstraintPairSeq* _pd_seq;
  };

  class MappingConstraintPairSeq_out {
  public:
    inline MappingConstraintPairSeq_out(MappingConstraintPairSeq*& _s) : _data(_s) { _data = 0; }
    inline MappingConstraintPairSeq_out(MappingConstraintPairSeq_var& _s)
      : _data(_s._pd_seq) { _s = (MappingConstraintPairSeq*) 0; }
    inline MappingConstraintPairSeq_out(const MappingConstraintPairSeq_out& _s) : _data(_s._data) {}
    inline MappingConstraintPairSeq_out& operator = (const MappingConstraintPairSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline MappingConstraintPairSeq_out& operator = (MappingConstraintPairSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator MappingConstraintPairSeq*&()  { return _data; }
    inline MappingConstraintPairSeq*& ptr()       { return _data; }
    inline MappingConstraintPairSeq* operator->() { return _data; }

    inline MappingConstraintPair& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    MappingConstraintPairSeq*& _data;

  private:
    MappingConstraintPairSeq_out();
    MappingConstraintPairSeq_out& operator=(const MappingConstraintPairSeq_var&);
  };

  struct MappingConstraintInfo {
    typedef _CORBA_ConstrType_Variable_Var<MappingConstraintInfo> _var_type;

    
    ConstraintExp constraint_expression;

    ConstraintID constraint_id;

    ::CORBA::Any value;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef MappingConstraintInfo::_var_type MappingConstraintInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< MappingConstraintInfo,MappingConstraintInfo_var > MappingConstraintInfo_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MappingConstraintInfo;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MappingConstraintInfoSeq;

  class MappingConstraintInfoSeq_var;

  class MappingConstraintInfoSeq : public _CORBA_Unbounded_Sequence< MappingConstraintInfo >  {
  public:
    typedef MappingConstraintInfoSeq_var _var_type;
    inline MappingConstraintInfoSeq() {}
    inline MappingConstraintInfoSeq(const MappingConstraintInfoSeq& _s)
      : _CORBA_Unbounded_Sequence< MappingConstraintInfo > (_s) {}

    inline MappingConstraintInfoSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< MappingConstraintInfo > (_max) {}
    inline MappingConstraintInfoSeq(_CORBA_ULong _max, _CORBA_ULong _len, MappingConstraintInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< MappingConstraintInfo > (_max, _len, _val, _rel) {}

  

    inline MappingConstraintInfoSeq& operator = (const MappingConstraintInfoSeq& _s) {
      _CORBA_Unbounded_Sequence< MappingConstraintInfo > ::operator=(_s);
      return *this;
    }
  };

  class MappingConstraintInfoSeq_out;

  class MappingConstraintInfoSeq_var {
  public:
    inline MappingConstraintInfoSeq_var() : _pd_seq(0) {}
    inline MappingConstraintInfoSeq_var(MappingConstraintInfoSeq* _s) : _pd_seq(_s) {}
    inline MappingConstraintInfoSeq_var(const MappingConstraintInfoSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new MappingConstraintInfoSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~MappingConstraintInfoSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline MappingConstraintInfoSeq_var& operator = (MappingConstraintInfoSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline MappingConstraintInfoSeq_var& operator = (const MappingConstraintInfoSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new MappingConstraintInfoSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline MappingConstraintInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline MappingConstraintInfoSeq* operator -> () { return _pd_seq; }
    inline const MappingConstraintInfoSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator MappingConstraintInfoSeq& () const { return *_pd_seq; }
#else
    inline operator const MappingConstraintInfoSeq& () const { return *_pd_seq; }
    inline operator MappingConstraintInfoSeq& () { return *_pd_seq; }
#endif
      
    inline const MappingConstraintInfoSeq& in() const { return *_pd_seq; }
    inline MappingConstraintInfoSeq&       inout()    { return *_pd_seq; }
    inline MappingConstraintInfoSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline MappingConstraintInfoSeq* _retn() { MappingConstraintInfoSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class MappingConstraintInfoSeq_out;
    
  private:
    MappingConstraintInfoSeq* _pd_seq;
  };

  class MappingConstraintInfoSeq_out {
  public:
    inline MappingConstraintInfoSeq_out(MappingConstraintInfoSeq*& _s) : _data(_s) { _data = 0; }
    inline MappingConstraintInfoSeq_out(MappingConstraintInfoSeq_var& _s)
      : _data(_s._pd_seq) { _s = (MappingConstraintInfoSeq*) 0; }
    inline MappingConstraintInfoSeq_out(const MappingConstraintInfoSeq_out& _s) : _data(_s._data) {}
    inline MappingConstraintInfoSeq_out& operator = (const MappingConstraintInfoSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline MappingConstraintInfoSeq_out& operator = (MappingConstraintInfoSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator MappingConstraintInfoSeq*&()  { return _data; }
    inline MappingConstraintInfoSeq*& ptr()       { return _data; }
    inline MappingConstraintInfoSeq* operator->() { return _data; }

    inline MappingConstraintInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    MappingConstraintInfoSeq*& _data;

  private:
    MappingConstraintInfoSeq_out();
    MappingConstraintInfoSeq_out& operator=(const MappingConstraintInfoSeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CallbackID;

  typedef ::CORBA::Long CallbackID;
  typedef ::CORBA::Long_out CallbackID_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CallbackIDSeq;

  class CallbackIDSeq_var;

  class CallbackIDSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< CallbackID, 4, 4 >  {
  public:
    typedef CallbackIDSeq_var _var_type;
    inline CallbackIDSeq() {}
    inline CallbackIDSeq(const CallbackIDSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< CallbackID, 4, 4 > (_s) {}

    inline CallbackIDSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< CallbackID, 4, 4 > (_max) {}
    inline CallbackIDSeq(_CORBA_ULong _max, _CORBA_ULong _len, CallbackID* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< CallbackID, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline CallbackIDSeq& operator = (const CallbackIDSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< CallbackID, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class CallbackIDSeq_out;

  class CallbackIDSeq_var {
  public:
    inline CallbackIDSeq_var() : _pd_seq(0) {}
    inline CallbackIDSeq_var(CallbackIDSeq* _s) : _pd_seq(_s) {}
    inline CallbackIDSeq_var(const CallbackIDSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new CallbackIDSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~CallbackIDSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline CallbackIDSeq_var& operator = (CallbackIDSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline CallbackIDSeq_var& operator = (const CallbackIDSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new CallbackIDSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline CallbackID& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline CallbackIDSeq* operator -> () { return _pd_seq; }
    inline const CallbackIDSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator CallbackIDSeq& () const { return *_pd_seq; }
#else
    inline operator const CallbackIDSeq& () const { return *_pd_seq; }
    inline operator CallbackIDSeq& () { return *_pd_seq; }
#endif
      
    inline const CallbackIDSeq& in() const { return *_pd_seq; }
    inline CallbackIDSeq&       inout()    { return *_pd_seq; }
    inline CallbackIDSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline CallbackIDSeq* _retn() { CallbackIDSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class CallbackIDSeq_out;
    
  private:
    CallbackIDSeq* _pd_seq;
  };

  class CallbackIDSeq_out {
  public:
    inline CallbackIDSeq_out(CallbackIDSeq*& _s) : _data(_s) { _data = 0; }
    inline CallbackIDSeq_out(CallbackIDSeq_var& _s)
      : _data(_s._pd_seq) { _s = (CallbackIDSeq*) 0; }
    inline CallbackIDSeq_out(const CallbackIDSeq_out& _s) : _data(_s._data) {}
    inline CallbackIDSeq_out& operator = (const CallbackIDSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline CallbackIDSeq_out& operator = (CallbackIDSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator CallbackIDSeq*&()  { return _data; }
    inline CallbackIDSeq*& ptr()       { return _data; }
    inline CallbackIDSeq* operator->() { return _data; }

    inline CallbackID& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    CallbackIDSeq*& _data;

  private:
    CallbackIDSeq_out();
    CallbackIDSeq_out& operator=(const CallbackIDSeq_var&);
  };

  class UnsupportedFilterableData : public ::CORBA::UserException {
  public:
    
    

    inline UnsupportedFilterableData() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    UnsupportedFilterableData(const UnsupportedFilterableData&);
    
    UnsupportedFilterableData& operator=(const UnsupportedFilterableData&);
    virtual ~UnsupportedFilterableData();
    virtual void _raise() const;
    static UnsupportedFilterableData* _downcast(::CORBA::Exception*);
    static const UnsupportedFilterableData* _downcast(const ::CORBA::Exception*);
    static inline UnsupportedFilterableData* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnsupportedFilterableData;

  class InvalidGrammar : public ::CORBA::UserException {
  public:
    
    

    inline InvalidGrammar() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidGrammar(const InvalidGrammar&);
    
    InvalidGrammar& operator=(const InvalidGrammar&);
    virtual ~InvalidGrammar();
    virtual void _raise() const;
    static InvalidGrammar* _downcast(::CORBA::Exception*);
    static const InvalidGrammar* _downcast(const ::CORBA::Exception*);
    static inline InvalidGrammar* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidGrammar;

  class InvalidConstraint : public ::CORBA::UserException {
  public:
    
    ConstraintExp constr;

  

    inline InvalidConstraint() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidConstraint(const InvalidConstraint&);
    InvalidConstraint(const ConstraintExp& i_constr);
    InvalidConstraint& operator=(const InvalidConstraint&);
    virtual ~InvalidConstraint();
    virtual void _raise() const;
    static InvalidConstraint* _downcast(::CORBA::Exception*);
    static const InvalidConstraint* _downcast(const ::CORBA::Exception*);
    static inline InvalidConstraint* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidConstraint;

  class DuplicateConstraintID : public ::CORBA::UserException {
  public:
    
    ConstraintID id;

  

    inline DuplicateConstraintID() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    DuplicateConstraintID(const DuplicateConstraintID&);
    DuplicateConstraintID(ConstraintID i_id);
    DuplicateConstraintID& operator=(const DuplicateConstraintID&);
    virtual ~DuplicateConstraintID();
    virtual void _raise() const;
    static DuplicateConstraintID* _downcast(::CORBA::Exception*);
    static const DuplicateConstraintID* _downcast(const ::CORBA::Exception*);
    static inline DuplicateConstraintID* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DuplicateConstraintID;

  class ConstraintNotFound : public ::CORBA::UserException {
  public:
    
    ConstraintID id;

  

    inline ConstraintNotFound() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    ConstraintNotFound(const ConstraintNotFound&);
    ConstraintNotFound(ConstraintID i_id);
    ConstraintNotFound& operator=(const ConstraintNotFound&);
    virtual ~ConstraintNotFound();
    virtual void _raise() const;
    static ConstraintNotFound* _downcast(::CORBA::Exception*);
    static const ConstraintNotFound* _downcast(const ::CORBA::Exception*);
    static inline ConstraintNotFound* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConstraintNotFound;

  class CallbackNotFound : public ::CORBA::UserException {
  public:
    
    

    inline CallbackNotFound() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    CallbackNotFound(const CallbackNotFound&);
    
    CallbackNotFound& operator=(const CallbackNotFound&);
    virtual ~CallbackNotFound();
    virtual void _raise() const;
    static CallbackNotFound* _downcast(::CORBA::Exception*);
    static const CallbackNotFound* _downcast(const ::CORBA::Exception*);
    static inline CallbackNotFound* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CallbackNotFound;

  class InvalidValue : public ::CORBA::UserException {
  public:
    
    ConstraintExp constr;

    ::CORBA::Any value;

  

    inline InvalidValue() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidValue(const InvalidValue&);
    InvalidValue(const ConstraintExp& i_constr, const ::CORBA::Any& i_value);
    InvalidValue& operator=(const InvalidValue&);
    virtual ~InvalidValue();
    virtual void _raise() const;
    static InvalidValue* _downcast(::CORBA::Exception*);
    static const InvalidValue* _downcast(const ::CORBA::Exception*);
    static inline InvalidValue* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidValue;

#ifndef __CosNotifyFilter_mFilter__
#define __CosNotifyFilter_mFilter__
  class Filter;
  class _objref_Filter;
  class _impl_Filter;
  
  typedef _objref_Filter* Filter_ptr;
  typedef Filter_ptr FilterRef;

  class Filter_Helper {
  public:
    typedef Filter_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Filter, Filter_Helper> Filter_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Filter,Filter_Helper > Filter_out;

#endif

  // interface Filter
  class Filter {
  public:
    // Declarations for this interface type.
    typedef Filter_ptr _ptr_type;
    typedef Filter_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Filter :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    char* constraint_grammar();
    ConstraintInfoSeq* add_constraints(const ::CosNotifyFilter::ConstraintExpSeq& constraint_list);
    void modify_constraints(const ::CosNotifyFilter::ConstraintIDSeq& del_list, const ::CosNotifyFilter::ConstraintInfoSeq& modify_list);
    ConstraintInfoSeq* get_constraints(const ::CosNotifyFilter::ConstraintIDSeq& id_list);
    ConstraintInfoSeq* get_all_constraints();
    void remove_all_constraints();
    void destroy();
    ::CORBA::Boolean match(const ::CORBA::Any& filterable_data);
    ::CORBA::Boolean match_structured(const ::CosNotification::StructuredEvent& filterable_data);
    ::CORBA::Boolean match_typed(const ::CosNotification::PropertySeq& filterable_data);
    CallbackID attach_callback(::CosNotifyComm::NotifySubscribe_ptr callback);
    void detach_callback(::CosNotifyFilter::CallbackID callback);
    CallbackIDSeq* get_callbacks();

    // Constructors
    inline _objref_Filter()  { _PR_setobj(0); }  // nil
    _objref_Filter(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Filter();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Filter(const _objref_Filter&);
    _objref_Filter& operator = (const _objref_Filter&);
    // not implemented

    friend class Filter;
  };

  class _pof_Filter : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Filter() : _OMNI_NS(proxyObjectFactory)(Filter::_PD_repoId) {}
    virtual ~_pof_Filter();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Filter :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Filter();

    virtual char* constraint_grammar() = 0;
    virtual ConstraintInfoSeq* add_constraints(const ::CosNotifyFilter::ConstraintExpSeq& constraint_list) = 0;
    virtual void modify_constraints(const ::CosNotifyFilter::ConstraintIDSeq& del_list, const ::CosNotifyFilter::ConstraintInfoSeq& modify_list) = 0;
    virtual ConstraintInfoSeq* get_constraints(const ::CosNotifyFilter::ConstraintIDSeq& id_list) = 0;
    virtual ConstraintInfoSeq* get_all_constraints() = 0;
    virtual void remove_all_constraints() = 0;
    virtual void destroy() = 0;
    virtual ::CORBA::Boolean match(const ::CORBA::Any& filterable_data) = 0;
    virtual ::CORBA::Boolean match_structured(const ::CosNotification::StructuredEvent& filterable_data) = 0;
    virtual ::CORBA::Boolean match_typed(const ::CosNotification::PropertySeq& filterable_data) = 0;
    virtual CallbackID attach_callback(::CosNotifyComm::NotifySubscribe_ptr callback) = 0;
    virtual void detach_callback(::CosNotifyFilter::CallbackID callback) = 0;
    virtual CallbackIDSeq* get_callbacks() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Filter;

#ifndef __CosNotifyFilter_mMappingFilter__
#define __CosNotifyFilter_mMappingFilter__
  class MappingFilter;
  class _objref_MappingFilter;
  class _impl_MappingFilter;
  
  typedef _objref_MappingFilter* MappingFilter_ptr;
  typedef MappingFilter_ptr MappingFilterRef;

  class MappingFilter_Helper {
  public:
    typedef MappingFilter_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_MappingFilter, MappingFilter_Helper> MappingFilter_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_MappingFilter,MappingFilter_Helper > MappingFilter_out;

#endif

  // interface MappingFilter
  class MappingFilter {
  public:
    // Declarations for this interface type.
    typedef MappingFilter_ptr _ptr_type;
    typedef MappingFilter_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_MappingFilter :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    char* constraint_grammar();
    ::CORBA::TypeCode_ptr value_type();
    ::CORBA::Any* default_value();
    MappingConstraintInfoSeq* add_mapping_constraints(const ::CosNotifyFilter::MappingConstraintPairSeq& pair_list);
    void modify_mapping_constraints(const ::CosNotifyFilter::ConstraintIDSeq& del_list, const ::CosNotifyFilter::MappingConstraintInfoSeq& modify_list);
    MappingConstraintInfoSeq* get_mapping_constraints(const ::CosNotifyFilter::ConstraintIDSeq& id_list);
    MappingConstraintInfoSeq* get_all_mapping_constraints();
    void remove_all_mapping_constraints();
    void destroy();
    ::CORBA::Boolean match(const ::CORBA::Any& filterable_data, ::CORBA::Any_OUT_arg result_to_set);
    ::CORBA::Boolean match_structured(const ::CosNotification::StructuredEvent& filterable_data, ::CORBA::Any_OUT_arg result_to_set);
    ::CORBA::Boolean match_typed(const ::CosNotification::PropertySeq& filterable_data, ::CORBA::Any_OUT_arg result_to_set);

    // Constructors
    inline _objref_MappingFilter()  { _PR_setobj(0); }  // nil
    _objref_MappingFilter(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_MappingFilter();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_MappingFilter(const _objref_MappingFilter&);
    _objref_MappingFilter& operator = (const _objref_MappingFilter&);
    // not implemented

    friend class MappingFilter;
  };

  class _pof_MappingFilter : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_MappingFilter() : _OMNI_NS(proxyObjectFactory)(MappingFilter::_PD_repoId) {}
    virtual ~_pof_MappingFilter();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_MappingFilter :
    public virtual omniServant
  {
  public:
    virtual ~_impl_MappingFilter();

    virtual char* constraint_grammar() = 0;
    virtual ::CORBA::TypeCode_ptr value_type() = 0;
    virtual ::CORBA::Any* default_value() = 0;
    virtual MappingConstraintInfoSeq* add_mapping_constraints(const ::CosNotifyFilter::MappingConstraintPairSeq& pair_list) = 0;
    virtual void modify_mapping_constraints(const ::CosNotifyFilter::ConstraintIDSeq& del_list, const ::CosNotifyFilter::MappingConstraintInfoSeq& modify_list) = 0;
    virtual MappingConstraintInfoSeq* get_mapping_constraints(const ::CosNotifyFilter::ConstraintIDSeq& id_list) = 0;
    virtual MappingConstraintInfoSeq* get_all_mapping_constraints() = 0;
    virtual void remove_all_mapping_constraints() = 0;
    virtual void destroy() = 0;
    virtual ::CORBA::Boolean match(const ::CORBA::Any& filterable_data, ::CORBA::Any_OUT_arg result_to_set) = 0;
    virtual ::CORBA::Boolean match_structured(const ::CosNotification::StructuredEvent& filterable_data, ::CORBA::Any_OUT_arg result_to_set) = 0;
    virtual ::CORBA::Boolean match_typed(const ::CosNotification::PropertySeq& filterable_data, ::CORBA::Any_OUT_arg result_to_set) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MappingFilter;

#ifndef __CosNotifyFilter_mFilterFactory__
#define __CosNotifyFilter_mFilterFactory__
  class FilterFactory;
  class _objref_FilterFactory;
  class _impl_FilterFactory;
  
  typedef _objref_FilterFactory* FilterFactory_ptr;
  typedef FilterFactory_ptr FilterFactoryRef;

  class FilterFactory_Helper {
  public:
    typedef FilterFactory_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_FilterFactory, FilterFactory_Helper> FilterFactory_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_FilterFactory,FilterFactory_Helper > FilterFactory_out;

#endif

  // interface FilterFactory
  class FilterFactory {
  public:
    // Declarations for this interface type.
    typedef FilterFactory_ptr _ptr_type;
    typedef FilterFactory_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_FilterFactory :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    Filter_ptr create_filter(const char* constraint_grammar);
    MappingFilter_ptr create_mapping_filter(const char* constraint_grammar, const ::CORBA::Any& default_value);

    // Constructors
    inline _objref_FilterFactory()  { _PR_setobj(0); }  // nil
    _objref_FilterFactory(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_FilterFactory();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_FilterFactory(const _objref_FilterFactory&);
    _objref_FilterFactory& operator = (const _objref_FilterFactory&);
    // not implemented

    friend class FilterFactory;
  };

  class _pof_FilterFactory : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_FilterFactory() : _OMNI_NS(proxyObjectFactory)(FilterFactory::_PD_repoId) {}
    virtual ~_pof_FilterFactory();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_FilterFactory :
    public virtual omniServant
  {
  public:
    virtual ~_impl_FilterFactory();

    virtual Filter_ptr create_filter(const char* constraint_grammar) = 0;
    virtual MappingFilter_ptr create_mapping_filter(const char* constraint_grammar, const ::CORBA::Any& default_value) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FilterFactory;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FilterID;

  typedef ::CORBA::Long FilterID;
  typedef ::CORBA::Long_out FilterID_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FilterIDSeq;

  class FilterIDSeq_var;

  class FilterIDSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< FilterID, 4, 4 >  {
  public:
    typedef FilterIDSeq_var _var_type;
    inline FilterIDSeq() {}
    inline FilterIDSeq(const FilterIDSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< FilterID, 4, 4 > (_s) {}

    inline FilterIDSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< FilterID, 4, 4 > (_max) {}
    inline FilterIDSeq(_CORBA_ULong _max, _CORBA_ULong _len, FilterID* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< FilterID, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline FilterIDSeq& operator = (const FilterIDSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< FilterID, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class FilterIDSeq_out;

  class FilterIDSeq_var {
  public:
    inline FilterIDSeq_var() : _pd_seq(0) {}
    inline FilterIDSeq_var(FilterIDSeq* _s) : _pd_seq(_s) {}
    inline FilterIDSeq_var(const FilterIDSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new FilterIDSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~FilterIDSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline FilterIDSeq_var& operator = (FilterIDSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline FilterIDSeq_var& operator = (const FilterIDSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new FilterIDSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline FilterID& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline FilterIDSeq* operator -> () { return _pd_seq; }
    inline const FilterIDSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator FilterIDSeq& () const { return *_pd_seq; }
#else
    inline operator const FilterIDSeq& () const { return *_pd_seq; }
    inline operator FilterIDSeq& () { return *_pd_seq; }
#endif
      
    inline const FilterIDSeq& in() const { return *_pd_seq; }
    inline FilterIDSeq&       inout()    { return *_pd_seq; }
    inline FilterIDSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline FilterIDSeq* _retn() { FilterIDSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class FilterIDSeq_out;
    
  private:
    FilterIDSeq* _pd_seq;
  };

  class FilterIDSeq_out {
  public:
    inline FilterIDSeq_out(FilterIDSeq*& _s) : _data(_s) { _data = 0; }
    inline FilterIDSeq_out(FilterIDSeq_var& _s)
      : _data(_s._pd_seq) { _s = (FilterIDSeq*) 0; }
    inline FilterIDSeq_out(const FilterIDSeq_out& _s) : _data(_s._data) {}
    inline FilterIDSeq_out& operator = (const FilterIDSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline FilterIDSeq_out& operator = (FilterIDSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator FilterIDSeq*&()  { return _data; }
    inline FilterIDSeq*& ptr()       { return _data; }
    inline FilterIDSeq* operator->() { return _data; }

    inline FilterID& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    FilterIDSeq*& _data;

  private:
    FilterIDSeq_out();
    FilterIDSeq_out& operator=(const FilterIDSeq_var&);
  };

  class FilterNotFound : public ::CORBA::UserException {
  public:
    
    

    inline FilterNotFound() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    FilterNotFound(const FilterNotFound&);
    
    FilterNotFound& operator=(const FilterNotFound&);
    virtual ~FilterNotFound();
    virtual void _raise() const;
    static FilterNotFound* _downcast(::CORBA::Exception*);
    static const FilterNotFound* _downcast(const ::CORBA::Exception*);
    static inline FilterNotFound* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FilterNotFound;

#ifndef __CosNotifyFilter_mFilterAdmin__
#define __CosNotifyFilter_mFilterAdmin__
  class FilterAdmin;
  class _objref_FilterAdmin;
  class _impl_FilterAdmin;
  
  typedef _objref_FilterAdmin* FilterAdmin_ptr;
  typedef FilterAdmin_ptr FilterAdminRef;

  class FilterAdmin_Helper {
  public:
    typedef FilterAdmin_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_FilterAdmin, FilterAdmin_Helper> FilterAdmin_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_FilterAdmin,FilterAdmin_Helper > FilterAdmin_out;

#endif

  // interface FilterAdmin
  class FilterAdmin {
  public:
    // Declarations for this interface type.
    typedef FilterAdmin_ptr _ptr_type;
    typedef FilterAdmin_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_FilterAdmin :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    FilterID add_filter(::CosNotifyFilter::Filter_ptr new_filter);
    void remove_filter(::CosNotifyFilter::FilterID filter);
    Filter_ptr get_filter(::CosNotifyFilter::FilterID filter);
    FilterIDSeq* get_all_filters();
    void remove_all_filters();

    // Constructors
    inline _objref_FilterAdmin()  { _PR_setobj(0); }  // nil
    _objref_FilterAdmin(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_FilterAdmin();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_FilterAdmin(const _objref_FilterAdmin&);
    _objref_FilterAdmin& operator = (const _objref_FilterAdmin&);
    // not implemented

    friend class FilterAdmin;
  };

  class _pof_FilterAdmin : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_FilterAdmin() : _OMNI_NS(proxyObjectFactory)(FilterAdmin::_PD_repoId) {}
    virtual ~_pof_FilterAdmin();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_FilterAdmin :
    public virtual omniServant
  {
  public:
    virtual ~_impl_FilterAdmin();

    virtual FilterID add_filter(::CosNotifyFilter::Filter_ptr new_filter) = 0;
    virtual void remove_filter(::CosNotifyFilter::FilterID filter) = 0;
    virtual Filter_ptr get_filter(::CosNotifyFilter::FilterID filter) = 0;
    virtual FilterIDSeq* get_all_filters() = 0;
    virtual void remove_all_filters() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FilterAdmin;

_CORBA_MODULE_END



_CORBA_MODULE POA_CosNotifyFilter
_CORBA_MODULE_BEG

  class Filter :
    public virtual CosNotifyFilter::_impl_Filter,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~Filter();

    inline ::CosNotifyFilter::Filter_ptr _this() {
      return (::CosNotifyFilter::Filter_ptr) _do_this(::CosNotifyFilter::Filter::_PD_repoId);
    }
  };

  class MappingFilter :
    public virtual CosNotifyFilter::_impl_MappingFilter,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~MappingFilter();

    inline ::CosNotifyFilter::MappingFilter_ptr _this() {
      return (::CosNotifyFilter::MappingFilter_ptr) _do_this(::CosNotifyFilter::MappingFilter::_PD_repoId);
    }
  };

  class FilterFactory :
    public virtual CosNotifyFilter::_impl_FilterFactory,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~FilterFactory();

    inline ::CosNotifyFilter::FilterFactory_ptr _this() {
      return (::CosNotifyFilter::FilterFactory_ptr) _do_this(::CosNotifyFilter::FilterFactory::_PD_repoId);
    }
  };

  class FilterAdmin :
    public virtual CosNotifyFilter::_impl_FilterAdmin,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~FilterAdmin();

    inline ::CosNotifyFilter::FilterAdmin_ptr _this() {
      return (::CosNotifyFilter::FilterAdmin_ptr) _do_this(::CosNotifyFilter::FilterAdmin::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_CosNotifyFilter
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::ConstraintExp& _s);
extern void operator<<=(::CORBA::Any& _a, CosNotifyFilter::ConstraintExp* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::ConstraintExp*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::ConstraintExp*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::ConstraintIDSeq& _s);
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::ConstraintIDSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::ConstraintIDSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::ConstraintIDSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::ConstraintExpSeq& _s);
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::ConstraintExpSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::ConstraintExpSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::ConstraintExpSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::ConstraintInfo& _s);
extern void operator<<=(::CORBA::Any& _a, CosNotifyFilter::ConstraintInfo* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::ConstraintInfo*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::ConstraintInfo*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::ConstraintInfoSeq& _s);
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::ConstraintInfoSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::ConstraintInfoSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::ConstraintInfoSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintPair& _s);
extern void operator<<=(::CORBA::Any& _a, CosNotifyFilter::MappingConstraintPair* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::MappingConstraintPair*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintPair*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintPairSeq& _s);
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::MappingConstraintPairSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::MappingConstraintPairSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintPairSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintInfo& _s);
extern void operator<<=(::CORBA::Any& _a, CosNotifyFilter::MappingConstraintInfo* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::MappingConstraintInfo*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintInfo*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintInfoSeq& _s);
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::MappingConstraintInfoSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::MappingConstraintInfoSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintInfoSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::CallbackIDSeq& _s);
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::CallbackIDSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::CallbackIDSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::CallbackIDSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::UnsupportedFilterableData& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::UnsupportedFilterableData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::UnsupportedFilterableData*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::InvalidGrammar& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::InvalidGrammar* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::InvalidGrammar*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::InvalidConstraint& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::InvalidConstraint* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::InvalidConstraint*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::DuplicateConstraintID& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::DuplicateConstraintID* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::DuplicateConstraintID*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::ConstraintNotFound& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::ConstraintNotFound* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::ConstraintNotFound*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::CallbackNotFound& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::CallbackNotFound* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::CallbackNotFound*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::InvalidValue& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::InvalidValue* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::InvalidValue*& _sp);

void operator<<=(::CORBA::Any& _a, CosNotifyFilter::Filter_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::Filter_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::Filter_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyFilter::MappingFilter_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::MappingFilter_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::MappingFilter_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyFilter::FilterFactory_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::FilterFactory_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::FilterFactory_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::FilterIDSeq& _s);
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::FilterIDSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::FilterIDSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::FilterIDSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::FilterNotFound& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::FilterNotFound* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::FilterNotFound*& _sp);

void operator<<=(::CORBA::Any& _a, CosNotifyFilter::FilterAdmin_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::FilterAdmin_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::FilterAdmin_ptr& _s);



inline void
CosNotifyFilter::Filter::_marshalObjRef(::CosNotifyFilter::Filter_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyFilter::MappingFilter::_marshalObjRef(::CosNotifyFilter::MappingFilter_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyFilter::FilterFactory::_marshalObjRef(::CosNotifyFilter::FilterFactory_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyFilter::FilterAdmin::_marshalObjRef(::CosNotifyFilter::FilterAdmin_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}



#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_CosNotifyFilter
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_CosNotifyFilter
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_CosNotifyFilter
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_CosNotifyFilter
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosNotifyFilter
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosNotifyFilter
#endif

#endif  // __CosNotifyFilter_hh__

