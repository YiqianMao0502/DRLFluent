// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __CosNotifyChannelAdmin_hh__
#define __CosNotifyChannelAdmin_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_CosNotifyChannelAdmin
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_CosNotifyChannelAdmin
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosNotifyChannelAdmin
#endif


#include "COS_sysdep.h"
#ifndef __CosNotification_hh_EXTERNAL_GUARD__
#define __CosNotification_hh_EXTERNAL_GUARD__
#include "CosNotification.hh"
#endif
#ifndef __CosEventComm_hh_EXTERNAL_GUARD__
#define __CosEventComm_hh_EXTERNAL_GUARD__
#include "CosEventComm.hh"
#endif
#ifndef __CosNotifyComm_hh_EXTERNAL_GUARD__
#define __CosNotifyComm_hh_EXTERNAL_GUARD__
#include "CosNotifyComm.hh"
#endif
#ifndef __CosNotifyFilter_hh_EXTERNAL_GUARD__
#define __CosNotifyFilter_hh_EXTERNAL_GUARD__
#include "CosNotifyFilter.hh"
#endif
#ifndef __CosEventChannelAdmin_hh_EXTERNAL_GUARD__
#define __CosEventChannelAdmin_hh_EXTERNAL_GUARD__
#include "CosEventChannelAdmin.hh"
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE CosNotifyChannelAdmin

_CORBA_MODULE_BEG

  class ConnectionAlreadyActive : public ::CORBA::UserException {
  public:
    
    

    inline ConnectionAlreadyActive() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    ConnectionAlreadyActive(const ConnectionAlreadyActive&);
    
    ConnectionAlreadyActive& operator=(const ConnectionAlreadyActive&);
    virtual ~ConnectionAlreadyActive();
    virtual void _raise() const;
    static ConnectionAlreadyActive* _downcast(::CORBA::Exception*);
    static const ConnectionAlreadyActive* _downcast(const ::CORBA::Exception*);
    static inline ConnectionAlreadyActive* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConnectionAlreadyActive;

  class ConnectionAlreadyInactive : public ::CORBA::UserException {
  public:
    
    

    inline ConnectionAlreadyInactive() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    ConnectionAlreadyInactive(const ConnectionAlreadyInactive&);
    
    ConnectionAlreadyInactive& operator=(const ConnectionAlreadyInactive&);
    virtual ~ConnectionAlreadyInactive();
    virtual void _raise() const;
    static ConnectionAlreadyInactive* _downcast(::CORBA::Exception*);
    static const ConnectionAlreadyInactive* _downcast(const ::CORBA::Exception*);
    static inline ConnectionAlreadyInactive* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConnectionAlreadyInactive;

  class NotConnected : public ::CORBA::UserException {
  public:
    
    

    inline NotConnected() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    NotConnected(const NotConnected&);
    
    NotConnected& operator=(const NotConnected&);
    virtual ~NotConnected();
    virtual void _raise() const;
    static NotConnected* _downcast(::CORBA::Exception*);
    static const NotConnected* _downcast(const ::CORBA::Exception*);
    static inline NotConnected* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NotConnected;

#ifndef __CosNotifyChannelAdmin_mConsumerAdmin__
#define __CosNotifyChannelAdmin_mConsumerAdmin__
  class ConsumerAdmin;
  class _objref_ConsumerAdmin;
  class _impl_ConsumerAdmin;
  
  typedef _objref_ConsumerAdmin* ConsumerAdmin_ptr;
  typedef ConsumerAdmin_ptr ConsumerAdminRef;

  class ConsumerAdmin_Helper {
  public:
    typedef ConsumerAdmin_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ConsumerAdmin, ConsumerAdmin_Helper> ConsumerAdmin_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ConsumerAdmin,ConsumerAdmin_Helper > ConsumerAdmin_out;

#endif

#ifndef __CosNotifyChannelAdmin_mSupplierAdmin__
#define __CosNotifyChannelAdmin_mSupplierAdmin__
  class SupplierAdmin;
  class _objref_SupplierAdmin;
  class _impl_SupplierAdmin;
  
  typedef _objref_SupplierAdmin* SupplierAdmin_ptr;
  typedef SupplierAdmin_ptr SupplierAdminRef;

  class SupplierAdmin_Helper {
  public:
    typedef SupplierAdmin_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SupplierAdmin, SupplierAdmin_Helper> SupplierAdmin_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SupplierAdmin,SupplierAdmin_Helper > SupplierAdmin_out;

#endif

#ifndef __CosNotifyChannelAdmin_mEventChannel__
#define __CosNotifyChannelAdmin_mEventChannel__
  class EventChannel;
  class _objref_EventChannel;
  class _impl_EventChannel;
  
  typedef _objref_EventChannel* EventChannel_ptr;
  typedef EventChannel_ptr EventChannelRef;

  class EventChannel_Helper {
  public:
    typedef EventChannel_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_EventChannel, EventChannel_Helper> EventChannel_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_EventChannel,EventChannel_Helper > EventChannel_out;

#endif

#ifndef __CosNotifyChannelAdmin_mEventChannelFactory__
#define __CosNotifyChannelAdmin_mEventChannelFactory__
  class EventChannelFactory;
  class _objref_EventChannelFactory;
  class _impl_EventChannelFactory;
  
  typedef _objref_EventChannelFactory* EventChannelFactory_ptr;
  typedef EventChannelFactory_ptr EventChannelFactoryRef;

  class EventChannelFactory_Helper {
  public:
    typedef EventChannelFactory_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_EventChannelFactory, EventChannelFactory_Helper> EventChannelFactory_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_EventChannelFactory,EventChannelFactory_Helper > EventChannelFactory_out;

#endif

  enum ProxyType { PUSH_ANY, PULL_ANY, PUSH_STRUCTURED, PULL_STRUCTURED, PUSH_SEQUENCE, PULL_SEQUENCE, PUSH_TYPED, PULL_TYPED /*, __max_ProxyType=0xffffffff */ };
  typedef ProxyType& ProxyType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProxyType;

  enum ObtainInfoMode { ALL_NOW_UPDATES_OFF, ALL_NOW_UPDATES_ON, NONE_NOW_UPDATES_OFF, NONE_NOW_UPDATES_ON /*, __max_ObtainInfoMode=0xffffffff */ };
  typedef ObtainInfoMode& ObtainInfoMode_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ObtainInfoMode;

#ifndef __CosNotifyChannelAdmin_mProxyConsumer__
#define __CosNotifyChannelAdmin_mProxyConsumer__
  class ProxyConsumer;
  class _objref_ProxyConsumer;
  class _impl_ProxyConsumer;
  
  typedef _objref_ProxyConsumer* ProxyConsumer_ptr;
  typedef ProxyConsumer_ptr ProxyConsumerRef;

  class ProxyConsumer_Helper {
  public:
    typedef ProxyConsumer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ProxyConsumer, ProxyConsumer_Helper> ProxyConsumer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ProxyConsumer,ProxyConsumer_Helper > ProxyConsumer_out;

#endif

  // interface ProxyConsumer
  class ProxyConsumer {
  public:
    // Declarations for this interface type.
    typedef ProxyConsumer_ptr _ptr_type;
    typedef ProxyConsumer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ProxyConsumer :
    public virtual CosNotification::_objref_QoSAdmin,
    public virtual CosNotifyFilter::_objref_FilterAdmin
  {
  public:
    // IDL operations
    ProxyType MyType();
    SupplierAdmin_ptr MyAdmin();
    CosNotification::EventTypeSeq* obtain_subscription_types(::CosNotifyChannelAdmin::ObtainInfoMode mode);
    void validate_event_qos(const ::CosNotification::QoSProperties& required_qos, ::CosNotification::NamedPropertyRangeSeq_out available_qos);

    // Constructors
    inline _objref_ProxyConsumer()  { _PR_setobj(0); }  // nil
    _objref_ProxyConsumer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ProxyConsumer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ProxyConsumer(const _objref_ProxyConsumer&);
    _objref_ProxyConsumer& operator = (const _objref_ProxyConsumer&);
    // not implemented

    friend class ProxyConsumer;
  };

  class _pof_ProxyConsumer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ProxyConsumer() : _OMNI_NS(proxyObjectFactory)(ProxyConsumer::_PD_repoId) {}
    virtual ~_pof_ProxyConsumer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ProxyConsumer :
    public virtual CosNotification::_impl_QoSAdmin,
    public virtual CosNotifyFilter::_impl_FilterAdmin
  {
  public:
    virtual ~_impl_ProxyConsumer();

    virtual ProxyType MyType() = 0;
    virtual SupplierAdmin_ptr MyAdmin() = 0;
    virtual CosNotification::EventTypeSeq* obtain_subscription_types(::CosNotifyChannelAdmin::ObtainInfoMode mode) = 0;
    virtual void validate_event_qos(const ::CosNotification::QoSProperties& required_qos, ::CosNotification::NamedPropertyRangeSeq_out available_qos) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProxyConsumer;

#ifndef __CosNotifyChannelAdmin_mProxySupplier__
#define __CosNotifyChannelAdmin_mProxySupplier__
  class ProxySupplier;
  class _objref_ProxySupplier;
  class _impl_ProxySupplier;
  
  typedef _objref_ProxySupplier* ProxySupplier_ptr;
  typedef ProxySupplier_ptr ProxySupplierRef;

  class ProxySupplier_Helper {
  public:
    typedef ProxySupplier_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ProxySupplier, ProxySupplier_Helper> ProxySupplier_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ProxySupplier,ProxySupplier_Helper > ProxySupplier_out;

#endif

  // interface ProxySupplier
  class ProxySupplier {
  public:
    // Declarations for this interface type.
    typedef ProxySupplier_ptr _ptr_type;
    typedef ProxySupplier_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ProxySupplier :
    public virtual CosNotification::_objref_QoSAdmin,
    public virtual CosNotifyFilter::_objref_FilterAdmin
  {
  public:
    // IDL operations
    ProxyType MyType();
    ConsumerAdmin_ptr MyAdmin();
    CosNotifyFilter::MappingFilter_ptr priority_filter();
    void priority_filter(::CosNotifyFilter::MappingFilter_ptr _v);
    CosNotifyFilter::MappingFilter_ptr lifetime_filter();
    void lifetime_filter(::CosNotifyFilter::MappingFilter_ptr _v);
    CosNotification::EventTypeSeq* obtain_offered_types(::CosNotifyChannelAdmin::ObtainInfoMode mode);
    void validate_event_qos(const ::CosNotification::QoSProperties& required_qos, ::CosNotification::NamedPropertyRangeSeq_out available_qos);

    // Constructors
    inline _objref_ProxySupplier()  { _PR_setobj(0); }  // nil
    _objref_ProxySupplier(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ProxySupplier();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ProxySupplier(const _objref_ProxySupplier&);
    _objref_ProxySupplier& operator = (const _objref_ProxySupplier&);
    // not implemented

    friend class ProxySupplier;
  };

  class _pof_ProxySupplier : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ProxySupplier() : _OMNI_NS(proxyObjectFactory)(ProxySupplier::_PD_repoId) {}
    virtual ~_pof_ProxySupplier();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ProxySupplier :
    public virtual CosNotification::_impl_QoSAdmin,
    public virtual CosNotifyFilter::_impl_FilterAdmin
  {
  public:
    virtual ~_impl_ProxySupplier();

    virtual ProxyType MyType() = 0;
    virtual ConsumerAdmin_ptr MyAdmin() = 0;
    virtual CosNotifyFilter::MappingFilter_ptr priority_filter() = 0;
    virtual void priority_filter(::CosNotifyFilter::MappingFilter_ptr _v) = 0;
    virtual CosNotifyFilter::MappingFilter_ptr lifetime_filter() = 0;
    virtual void lifetime_filter(::CosNotifyFilter::MappingFilter_ptr _v) = 0;
    virtual CosNotification::EventTypeSeq* obtain_offered_types(::CosNotifyChannelAdmin::ObtainInfoMode mode) = 0;
    virtual void validate_event_qos(const ::CosNotification::QoSProperties& required_qos, ::CosNotification::NamedPropertyRangeSeq_out available_qos) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProxySupplier;

#ifndef __CosNotifyChannelAdmin_mProxyPushConsumer__
#define __CosNotifyChannelAdmin_mProxyPushConsumer__
  class ProxyPushConsumer;
  class _objref_ProxyPushConsumer;
  class _impl_ProxyPushConsumer;
  
  typedef _objref_ProxyPushConsumer* ProxyPushConsumer_ptr;
  typedef ProxyPushConsumer_ptr ProxyPushConsumerRef;

  class ProxyPushConsumer_Helper {
  public:
    typedef ProxyPushConsumer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ProxyPushConsumer, ProxyPushConsumer_Helper> ProxyPushConsumer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ProxyPushConsumer,ProxyPushConsumer_Helper > ProxyPushConsumer_out;

#endif

  // interface ProxyPushConsumer
  class ProxyPushConsumer {
  public:
    // Declarations for this interface type.
    typedef ProxyPushConsumer_ptr _ptr_type;
    typedef ProxyPushConsumer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ProxyPushConsumer :
    public virtual _objref_ProxyConsumer,
    public virtual CosNotifyComm::_objref_PushConsumer
  {
  public:
    // IDL operations
    void connect_any_push_supplier(::CosEventComm::PushSupplier_ptr push_supplier);

    // Constructors
    inline _objref_ProxyPushConsumer()  { _PR_setobj(0); }  // nil
    _objref_ProxyPushConsumer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ProxyPushConsumer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ProxyPushConsumer(const _objref_ProxyPushConsumer&);
    _objref_ProxyPushConsumer& operator = (const _objref_ProxyPushConsumer&);
    // not implemented

    friend class ProxyPushConsumer;
  };

  class _pof_ProxyPushConsumer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ProxyPushConsumer() : _OMNI_NS(proxyObjectFactory)(ProxyPushConsumer::_PD_repoId) {}
    virtual ~_pof_ProxyPushConsumer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ProxyPushConsumer :
    public virtual _impl_ProxyConsumer,
    public virtual CosNotifyComm::_impl_PushConsumer
  {
  public:
    virtual ~_impl_ProxyPushConsumer();

    virtual void connect_any_push_supplier(::CosEventComm::PushSupplier_ptr push_supplier) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProxyPushConsumer;

#ifndef __CosNotifyChannelAdmin_mStructuredProxyPushConsumer__
#define __CosNotifyChannelAdmin_mStructuredProxyPushConsumer__
  class StructuredProxyPushConsumer;
  class _objref_StructuredProxyPushConsumer;
  class _impl_StructuredProxyPushConsumer;
  
  typedef _objref_StructuredProxyPushConsumer* StructuredProxyPushConsumer_ptr;
  typedef StructuredProxyPushConsumer_ptr StructuredProxyPushConsumerRef;

  class StructuredProxyPushConsumer_Helper {
  public:
    typedef StructuredProxyPushConsumer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_StructuredProxyPushConsumer, StructuredProxyPushConsumer_Helper> StructuredProxyPushConsumer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_StructuredProxyPushConsumer,StructuredProxyPushConsumer_Helper > StructuredProxyPushConsumer_out;

#endif

  // interface StructuredProxyPushConsumer
  class StructuredProxyPushConsumer {
  public:
    // Declarations for this interface type.
    typedef StructuredProxyPushConsumer_ptr _ptr_type;
    typedef StructuredProxyPushConsumer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_StructuredProxyPushConsumer :
    public virtual _objref_ProxyConsumer,
    public virtual CosNotifyComm::_objref_StructuredPushConsumer
  {
  public:
    // IDL operations
    void connect_structured_push_supplier(::CosNotifyComm::StructuredPushSupplier_ptr push_supplier);

    // Constructors
    inline _objref_StructuredProxyPushConsumer()  { _PR_setobj(0); }  // nil
    _objref_StructuredProxyPushConsumer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_StructuredProxyPushConsumer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_StructuredProxyPushConsumer(const _objref_StructuredProxyPushConsumer&);
    _objref_StructuredProxyPushConsumer& operator = (const _objref_StructuredProxyPushConsumer&);
    // not implemented

    friend class StructuredProxyPushConsumer;
  };

  class _pof_StructuredProxyPushConsumer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_StructuredProxyPushConsumer() : _OMNI_NS(proxyObjectFactory)(StructuredProxyPushConsumer::_PD_repoId) {}
    virtual ~_pof_StructuredProxyPushConsumer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_StructuredProxyPushConsumer :
    public virtual _impl_ProxyConsumer,
    public virtual CosNotifyComm::_impl_StructuredPushConsumer
  {
  public:
    virtual ~_impl_StructuredProxyPushConsumer();

    virtual void connect_structured_push_supplier(::CosNotifyComm::StructuredPushSupplier_ptr push_supplier) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StructuredProxyPushConsumer;

#ifndef __CosNotifyChannelAdmin_mSequenceProxyPushConsumer__
#define __CosNotifyChannelAdmin_mSequenceProxyPushConsumer__
  class SequenceProxyPushConsumer;
  class _objref_SequenceProxyPushConsumer;
  class _impl_SequenceProxyPushConsumer;
  
  typedef _objref_SequenceProxyPushConsumer* SequenceProxyPushConsumer_ptr;
  typedef SequenceProxyPushConsumer_ptr SequenceProxyPushConsumerRef;

  class SequenceProxyPushConsumer_Helper {
  public:
    typedef SequenceProxyPushConsumer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SequenceProxyPushConsumer, SequenceProxyPushConsumer_Helper> SequenceProxyPushConsumer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SequenceProxyPushConsumer,SequenceProxyPushConsumer_Helper > SequenceProxyPushConsumer_out;

#endif

  // interface SequenceProxyPushConsumer
  class SequenceProxyPushConsumer {
  public:
    // Declarations for this interface type.
    typedef SequenceProxyPushConsumer_ptr _ptr_type;
    typedef SequenceProxyPushConsumer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_SequenceProxyPushConsumer :
    public virtual _objref_ProxyConsumer,
    public virtual CosNotifyComm::_objref_SequencePushConsumer
  {
  public:
    // IDL operations
    void connect_sequence_push_supplier(::CosNotifyComm::SequencePushSupplier_ptr push_supplier);

    // Constructors
    inline _objref_SequenceProxyPushConsumer()  { _PR_setobj(0); }  // nil
    _objref_SequenceProxyPushConsumer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_SequenceProxyPushConsumer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_SequenceProxyPushConsumer(const _objref_SequenceProxyPushConsumer&);
    _objref_SequenceProxyPushConsumer& operator = (const _objref_SequenceProxyPushConsumer&);
    // not implemented

    friend class SequenceProxyPushConsumer;
  };

  class _pof_SequenceProxyPushConsumer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_SequenceProxyPushConsumer() : _OMNI_NS(proxyObjectFactory)(SequenceProxyPushConsumer::_PD_repoId) {}
    virtual ~_pof_SequenceProxyPushConsumer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_SequenceProxyPushConsumer :
    public virtual _impl_ProxyConsumer,
    public virtual CosNotifyComm::_impl_SequencePushConsumer
  {
  public:
    virtual ~_impl_SequenceProxyPushConsumer();

    virtual void connect_sequence_push_supplier(::CosNotifyComm::SequencePushSupplier_ptr push_supplier) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SequenceProxyPushConsumer;

#ifndef __CosNotifyChannelAdmin_mProxyPullSupplier__
#define __CosNotifyChannelAdmin_mProxyPullSupplier__
  class ProxyPullSupplier;
  class _objref_ProxyPullSupplier;
  class _impl_ProxyPullSupplier;
  
  typedef _objref_ProxyPullSupplier* ProxyPullSupplier_ptr;
  typedef ProxyPullSupplier_ptr ProxyPullSupplierRef;

  class ProxyPullSupplier_Helper {
  public:
    typedef ProxyPullSupplier_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ProxyPullSupplier, ProxyPullSupplier_Helper> ProxyPullSupplier_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ProxyPullSupplier,ProxyPullSupplier_Helper > ProxyPullSupplier_out;

#endif

  // interface ProxyPullSupplier
  class ProxyPullSupplier {
  public:
    // Declarations for this interface type.
    typedef ProxyPullSupplier_ptr _ptr_type;
    typedef ProxyPullSupplier_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ProxyPullSupplier :
    public virtual _objref_ProxySupplier,
    public virtual CosNotifyComm::_objref_PullSupplier
  {
  public:
    // IDL operations
    void connect_any_pull_consumer(::CosEventComm::PullConsumer_ptr pull_consumer);

    // Constructors
    inline _objref_ProxyPullSupplier()  { _PR_setobj(0); }  // nil
    _objref_ProxyPullSupplier(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ProxyPullSupplier();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ProxyPullSupplier(const _objref_ProxyPullSupplier&);
    _objref_ProxyPullSupplier& operator = (const _objref_ProxyPullSupplier&);
    // not implemented

    friend class ProxyPullSupplier;
  };

  class _pof_ProxyPullSupplier : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ProxyPullSupplier() : _OMNI_NS(proxyObjectFactory)(ProxyPullSupplier::_PD_repoId) {}
    virtual ~_pof_ProxyPullSupplier();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ProxyPullSupplier :
    public virtual _impl_ProxySupplier,
    public virtual CosNotifyComm::_impl_PullSupplier
  {
  public:
    virtual ~_impl_ProxyPullSupplier();

    virtual void connect_any_pull_consumer(::CosEventComm::PullConsumer_ptr pull_consumer) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProxyPullSupplier;

#ifndef __CosNotifyChannelAdmin_mStructuredProxyPullSupplier__
#define __CosNotifyChannelAdmin_mStructuredProxyPullSupplier__
  class StructuredProxyPullSupplier;
  class _objref_StructuredProxyPullSupplier;
  class _impl_StructuredProxyPullSupplier;
  
  typedef _objref_StructuredProxyPullSupplier* StructuredProxyPullSupplier_ptr;
  typedef StructuredProxyPullSupplier_ptr StructuredProxyPullSupplierRef;

  class StructuredProxyPullSupplier_Helper {
  public:
    typedef StructuredProxyPullSupplier_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_StructuredProxyPullSupplier, StructuredProxyPullSupplier_Helper> StructuredProxyPullSupplier_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_StructuredProxyPullSupplier,StructuredProxyPullSupplier_Helper > StructuredProxyPullSupplier_out;

#endif

  // interface StructuredProxyPullSupplier
  class StructuredProxyPullSupplier {
  public:
    // Declarations for this interface type.
    typedef StructuredProxyPullSupplier_ptr _ptr_type;
    typedef StructuredProxyPullSupplier_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_StructuredProxyPullSupplier :
    public virtual _objref_ProxySupplier,
    public virtual CosNotifyComm::_objref_StructuredPullSupplier
  {
  public:
    // IDL operations
    void connect_structured_pull_consumer(::CosNotifyComm::StructuredPullConsumer_ptr pull_consumer);

    // Constructors
    inline _objref_StructuredProxyPullSupplier()  { _PR_setobj(0); }  // nil
    _objref_StructuredProxyPullSupplier(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_StructuredProxyPullSupplier();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_StructuredProxyPullSupplier(const _objref_StructuredProxyPullSupplier&);
    _objref_StructuredProxyPullSupplier& operator = (const _objref_StructuredProxyPullSupplier&);
    // not implemented

    friend class StructuredProxyPullSupplier;
  };

  class _pof_StructuredProxyPullSupplier : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_StructuredProxyPullSupplier() : _OMNI_NS(proxyObjectFactory)(StructuredProxyPullSupplier::_PD_repoId) {}
    virtual ~_pof_StructuredProxyPullSupplier();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_StructuredProxyPullSupplier :
    public virtual _impl_ProxySupplier,
    public virtual CosNotifyComm::_impl_StructuredPullSupplier
  {
  public:
    virtual ~_impl_StructuredProxyPullSupplier();

    virtual void connect_structured_pull_consumer(::CosNotifyComm::StructuredPullConsumer_ptr pull_consumer) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StructuredProxyPullSupplier;

#ifndef __CosNotifyChannelAdmin_mSequenceProxyPullSupplier__
#define __CosNotifyChannelAdmin_mSequenceProxyPullSupplier__
  class SequenceProxyPullSupplier;
  class _objref_SequenceProxyPullSupplier;
  class _impl_SequenceProxyPullSupplier;
  
  typedef _objref_SequenceProxyPullSupplier* SequenceProxyPullSupplier_ptr;
  typedef SequenceProxyPullSupplier_ptr SequenceProxyPullSupplierRef;

  class SequenceProxyPullSupplier_Helper {
  public:
    typedef SequenceProxyPullSupplier_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SequenceProxyPullSupplier, SequenceProxyPullSupplier_Helper> SequenceProxyPullSupplier_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SequenceProxyPullSupplier,SequenceProxyPullSupplier_Helper > SequenceProxyPullSupplier_out;

#endif

  // interface SequenceProxyPullSupplier
  class SequenceProxyPullSupplier {
  public:
    // Declarations for this interface type.
    typedef SequenceProxyPullSupplier_ptr _ptr_type;
    typedef SequenceProxyPullSupplier_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_SequenceProxyPullSupplier :
    public virtual _objref_ProxySupplier,
    public virtual CosNotifyComm::_objref_SequencePullSupplier
  {
  public:
    // IDL operations
    void connect_sequence_pull_consumer(::CosNotifyComm::SequencePullConsumer_ptr pull_consumer);

    // Constructors
    inline _objref_SequenceProxyPullSupplier()  { _PR_setobj(0); }  // nil
    _objref_SequenceProxyPullSupplier(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_SequenceProxyPullSupplier();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_SequenceProxyPullSupplier(const _objref_SequenceProxyPullSupplier&);
    _objref_SequenceProxyPullSupplier& operator = (const _objref_SequenceProxyPullSupplier&);
    // not implemented

    friend class SequenceProxyPullSupplier;
  };

  class _pof_SequenceProxyPullSupplier : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_SequenceProxyPullSupplier() : _OMNI_NS(proxyObjectFactory)(SequenceProxyPullSupplier::_PD_repoId) {}
    virtual ~_pof_SequenceProxyPullSupplier();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_SequenceProxyPullSupplier :
    public virtual _impl_ProxySupplier,
    public virtual CosNotifyComm::_impl_SequencePullSupplier
  {
  public:
    virtual ~_impl_SequenceProxyPullSupplier();

    virtual void connect_sequence_pull_consumer(::CosNotifyComm::SequencePullConsumer_ptr pull_consumer) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SequenceProxyPullSupplier;

#ifndef __CosNotifyChannelAdmin_mProxyPullConsumer__
#define __CosNotifyChannelAdmin_mProxyPullConsumer__
  class ProxyPullConsumer;
  class _objref_ProxyPullConsumer;
  class _impl_ProxyPullConsumer;
  
  typedef _objref_ProxyPullConsumer* ProxyPullConsumer_ptr;
  typedef ProxyPullConsumer_ptr ProxyPullConsumerRef;

  class ProxyPullConsumer_Helper {
  public:
    typedef ProxyPullConsumer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ProxyPullConsumer, ProxyPullConsumer_Helper> ProxyPullConsumer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ProxyPullConsumer,ProxyPullConsumer_Helper > ProxyPullConsumer_out;

#endif

  // interface ProxyPullConsumer
  class ProxyPullConsumer {
  public:
    // Declarations for this interface type.
    typedef ProxyPullConsumer_ptr _ptr_type;
    typedef ProxyPullConsumer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ProxyPullConsumer :
    public virtual _objref_ProxyConsumer,
    public virtual CosNotifyComm::_objref_PullConsumer
  {
  public:
    // IDL operations
    void connect_any_pull_supplier(::CosEventComm::PullSupplier_ptr pull_supplier);
    void suspend_connection();
    void resume_connection();

    // Constructors
    inline _objref_ProxyPullConsumer()  { _PR_setobj(0); }  // nil
    _objref_ProxyPullConsumer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ProxyPullConsumer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ProxyPullConsumer(const _objref_ProxyPullConsumer&);
    _objref_ProxyPullConsumer& operator = (const _objref_ProxyPullConsumer&);
    // not implemented

    friend class ProxyPullConsumer;
  };

  class _pof_ProxyPullConsumer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ProxyPullConsumer() : _OMNI_NS(proxyObjectFactory)(ProxyPullConsumer::_PD_repoId) {}
    virtual ~_pof_ProxyPullConsumer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ProxyPullConsumer :
    public virtual _impl_ProxyConsumer,
    public virtual CosNotifyComm::_impl_PullConsumer
  {
  public:
    virtual ~_impl_ProxyPullConsumer();

    virtual void connect_any_pull_supplier(::CosEventComm::PullSupplier_ptr pull_supplier) = 0;
    virtual void suspend_connection() = 0;
    virtual void resume_connection() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProxyPullConsumer;

#ifndef __CosNotifyChannelAdmin_mStructuredProxyPullConsumer__
#define __CosNotifyChannelAdmin_mStructuredProxyPullConsumer__
  class StructuredProxyPullConsumer;
  class _objref_StructuredProxyPullConsumer;
  class _impl_StructuredProxyPullConsumer;
  
  typedef _objref_StructuredProxyPullConsumer* StructuredProxyPullConsumer_ptr;
  typedef StructuredProxyPullConsumer_ptr StructuredProxyPullConsumerRef;

  class StructuredProxyPullConsumer_Helper {
  public:
    typedef StructuredProxyPullConsumer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_StructuredProxyPullConsumer, StructuredProxyPullConsumer_Helper> StructuredProxyPullConsumer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_StructuredProxyPullConsumer,StructuredProxyPullConsumer_Helper > StructuredProxyPullConsumer_out;

#endif

  // interface StructuredProxyPullConsumer
  class StructuredProxyPullConsumer {
  public:
    // Declarations for this interface type.
    typedef StructuredProxyPullConsumer_ptr _ptr_type;
    typedef StructuredProxyPullConsumer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_StructuredProxyPullConsumer :
    public virtual _objref_ProxyConsumer,
    public virtual CosNotifyComm::_objref_StructuredPullConsumer
  {
  public:
    // IDL operations
    void connect_structured_pull_supplier(::CosNotifyComm::StructuredPullSupplier_ptr pull_supplier);
    void suspend_connection();
    void resume_connection();

    // Constructors
    inline _objref_StructuredProxyPullConsumer()  { _PR_setobj(0); }  // nil
    _objref_StructuredProxyPullConsumer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_StructuredProxyPullConsumer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_StructuredProxyPullConsumer(const _objref_StructuredProxyPullConsumer&);
    _objref_StructuredProxyPullConsumer& operator = (const _objref_StructuredProxyPullConsumer&);
    // not implemented

    friend class StructuredProxyPullConsumer;
  };

  class _pof_StructuredProxyPullConsumer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_StructuredProxyPullConsumer() : _OMNI_NS(proxyObjectFactory)(StructuredProxyPullConsumer::_PD_repoId) {}
    virtual ~_pof_StructuredProxyPullConsumer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_StructuredProxyPullConsumer :
    public virtual _impl_ProxyConsumer,
    public virtual CosNotifyComm::_impl_StructuredPullConsumer
  {
  public:
    virtual ~_impl_StructuredProxyPullConsumer();

    virtual void connect_structured_pull_supplier(::CosNotifyComm::StructuredPullSupplier_ptr pull_supplier) = 0;
    virtual void suspend_connection() = 0;
    virtual void resume_connection() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StructuredProxyPullConsumer;

#ifndef __CosNotifyChannelAdmin_mSequenceProxyPullConsumer__
#define __CosNotifyChannelAdmin_mSequenceProxyPullConsumer__
  class SequenceProxyPullConsumer;
  class _objref_SequenceProxyPullConsumer;
  class _impl_SequenceProxyPullConsumer;
  
  typedef _objref_SequenceProxyPullConsumer* SequenceProxyPullConsumer_ptr;
  typedef SequenceProxyPullConsumer_ptr SequenceProxyPullConsumerRef;

  class SequenceProxyPullConsumer_Helper {
  public:
    typedef SequenceProxyPullConsumer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SequenceProxyPullConsumer, SequenceProxyPullConsumer_Helper> SequenceProxyPullConsumer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SequenceProxyPullConsumer,SequenceProxyPullConsumer_Helper > SequenceProxyPullConsumer_out;

#endif

  // interface SequenceProxyPullConsumer
  class SequenceProxyPullConsumer {
  public:
    // Declarations for this interface type.
    typedef SequenceProxyPullConsumer_ptr _ptr_type;
    typedef SequenceProxyPullConsumer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_SequenceProxyPullConsumer :
    public virtual _objref_ProxyConsumer,
    public virtual CosNotifyComm::_objref_SequencePullConsumer
  {
  public:
    // IDL operations
    void connect_sequence_pull_supplier(::CosNotifyComm::SequencePullSupplier_ptr pull_supplier);
    void suspend_connection();
    void resume_connection();

    // Constructors
    inline _objref_SequenceProxyPullConsumer()  { _PR_setobj(0); }  // nil
    _objref_SequenceProxyPullConsumer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_SequenceProxyPullConsumer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_SequenceProxyPullConsumer(const _objref_SequenceProxyPullConsumer&);
    _objref_SequenceProxyPullConsumer& operator = (const _objref_SequenceProxyPullConsumer&);
    // not implemented

    friend class SequenceProxyPullConsumer;
  };

  class _pof_SequenceProxyPullConsumer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_SequenceProxyPullConsumer() : _OMNI_NS(proxyObjectFactory)(SequenceProxyPullConsumer::_PD_repoId) {}
    virtual ~_pof_SequenceProxyPullConsumer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_SequenceProxyPullConsumer :
    public virtual _impl_ProxyConsumer,
    public virtual CosNotifyComm::_impl_SequencePullConsumer
  {
  public:
    virtual ~_impl_SequenceProxyPullConsumer();

    virtual void connect_sequence_pull_supplier(::CosNotifyComm::SequencePullSupplier_ptr pull_supplier) = 0;
    virtual void suspend_connection() = 0;
    virtual void resume_connection() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SequenceProxyPullConsumer;

#ifndef __CosNotifyChannelAdmin_mProxyPushSupplier__
#define __CosNotifyChannelAdmin_mProxyPushSupplier__
  class ProxyPushSupplier;
  class _objref_ProxyPushSupplier;
  class _impl_ProxyPushSupplier;
  
  typedef _objref_ProxyPushSupplier* ProxyPushSupplier_ptr;
  typedef ProxyPushSupplier_ptr ProxyPushSupplierRef;

  class ProxyPushSupplier_Helper {
  public:
    typedef ProxyPushSupplier_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ProxyPushSupplier, ProxyPushSupplier_Helper> ProxyPushSupplier_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ProxyPushSupplier,ProxyPushSupplier_Helper > ProxyPushSupplier_out;

#endif

  // interface ProxyPushSupplier
  class ProxyPushSupplier {
  public:
    // Declarations for this interface type.
    typedef ProxyPushSupplier_ptr _ptr_type;
    typedef ProxyPushSupplier_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ProxyPushSupplier :
    public virtual _objref_ProxySupplier,
    public virtual CosNotifyComm::_objref_PushSupplier
  {
  public:
    // IDL operations
    void connect_any_push_consumer(::CosEventComm::PushConsumer_ptr push_consumer);
    void suspend_connection();
    void resume_connection();

    // Constructors
    inline _objref_ProxyPushSupplier()  { _PR_setobj(0); }  // nil
    _objref_ProxyPushSupplier(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ProxyPushSupplier();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ProxyPushSupplier(const _objref_ProxyPushSupplier&);
    _objref_ProxyPushSupplier& operator = (const _objref_ProxyPushSupplier&);
    // not implemented

    friend class ProxyPushSupplier;
  };

  class _pof_ProxyPushSupplier : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ProxyPushSupplier() : _OMNI_NS(proxyObjectFactory)(ProxyPushSupplier::_PD_repoId) {}
    virtual ~_pof_ProxyPushSupplier();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ProxyPushSupplier :
    public virtual _impl_ProxySupplier,
    public virtual CosNotifyComm::_impl_PushSupplier
  {
  public:
    virtual ~_impl_ProxyPushSupplier();

    virtual void connect_any_push_consumer(::CosEventComm::PushConsumer_ptr push_consumer) = 0;
    virtual void suspend_connection() = 0;
    virtual void resume_connection() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProxyPushSupplier;

#ifndef __CosNotifyChannelAdmin_mStructuredProxyPushSupplier__
#define __CosNotifyChannelAdmin_mStructuredProxyPushSupplier__
  class StructuredProxyPushSupplier;
  class _objref_StructuredProxyPushSupplier;
  class _impl_StructuredProxyPushSupplier;
  
  typedef _objref_StructuredProxyPushSupplier* StructuredProxyPushSupplier_ptr;
  typedef StructuredProxyPushSupplier_ptr StructuredProxyPushSupplierRef;

  class StructuredProxyPushSupplier_Helper {
  public:
    typedef StructuredProxyPushSupplier_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_StructuredProxyPushSupplier, StructuredProxyPushSupplier_Helper> StructuredProxyPushSupplier_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_StructuredProxyPushSupplier,StructuredProxyPushSupplier_Helper > StructuredProxyPushSupplier_out;

#endif

  // interface StructuredProxyPushSupplier
  class StructuredProxyPushSupplier {
  public:
    // Declarations for this interface type.
    typedef StructuredProxyPushSupplier_ptr _ptr_type;
    typedef StructuredProxyPushSupplier_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_StructuredProxyPushSupplier :
    public virtual _objref_ProxySupplier,
    public virtual CosNotifyComm::_objref_StructuredPushSupplier
  {
  public:
    // IDL operations
    void connect_structured_push_consumer(::CosNotifyComm::StructuredPushConsumer_ptr push_consumer);
    void suspend_connection();
    void resume_connection();

    // Constructors
    inline _objref_StructuredProxyPushSupplier()  { _PR_setobj(0); }  // nil
    _objref_StructuredProxyPushSupplier(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_StructuredProxyPushSupplier();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_StructuredProxyPushSupplier(const _objref_StructuredProxyPushSupplier&);
    _objref_StructuredProxyPushSupplier& operator = (const _objref_StructuredProxyPushSupplier&);
    // not implemented

    friend class StructuredProxyPushSupplier;
  };

  class _pof_StructuredProxyPushSupplier : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_StructuredProxyPushSupplier() : _OMNI_NS(proxyObjectFactory)(StructuredProxyPushSupplier::_PD_repoId) {}
    virtual ~_pof_StructuredProxyPushSupplier();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_StructuredProxyPushSupplier :
    public virtual _impl_ProxySupplier,
    public virtual CosNotifyComm::_impl_StructuredPushSupplier
  {
  public:
    virtual ~_impl_StructuredProxyPushSupplier();

    virtual void connect_structured_push_consumer(::CosNotifyComm::StructuredPushConsumer_ptr push_consumer) = 0;
    virtual void suspend_connection() = 0;
    virtual void resume_connection() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StructuredProxyPushSupplier;

#ifndef __CosNotifyChannelAdmin_mSequenceProxyPushSupplier__
#define __CosNotifyChannelAdmin_mSequenceProxyPushSupplier__
  class SequenceProxyPushSupplier;
  class _objref_SequenceProxyPushSupplier;
  class _impl_SequenceProxyPushSupplier;
  
  typedef _objref_SequenceProxyPushSupplier* SequenceProxyPushSupplier_ptr;
  typedef SequenceProxyPushSupplier_ptr SequenceProxyPushSupplierRef;

  class SequenceProxyPushSupplier_Helper {
  public:
    typedef SequenceProxyPushSupplier_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SequenceProxyPushSupplier, SequenceProxyPushSupplier_Helper> SequenceProxyPushSupplier_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SequenceProxyPushSupplier,SequenceProxyPushSupplier_Helper > SequenceProxyPushSupplier_out;

#endif

  // interface SequenceProxyPushSupplier
  class SequenceProxyPushSupplier {
  public:
    // Declarations for this interface type.
    typedef SequenceProxyPushSupplier_ptr _ptr_type;
    typedef SequenceProxyPushSupplier_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_SequenceProxyPushSupplier :
    public virtual _objref_ProxySupplier,
    public virtual CosNotifyComm::_objref_SequencePushSupplier
  {
  public:
    // IDL operations
    void connect_sequence_push_consumer(::CosNotifyComm::SequencePushConsumer_ptr push_consumer);
    void suspend_connection();
    void resume_connection();

    // Constructors
    inline _objref_SequenceProxyPushSupplier()  { _PR_setobj(0); }  // nil
    _objref_SequenceProxyPushSupplier(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_SequenceProxyPushSupplier();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_SequenceProxyPushSupplier(const _objref_SequenceProxyPushSupplier&);
    _objref_SequenceProxyPushSupplier& operator = (const _objref_SequenceProxyPushSupplier&);
    // not implemented

    friend class SequenceProxyPushSupplier;
  };

  class _pof_SequenceProxyPushSupplier : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_SequenceProxyPushSupplier() : _OMNI_NS(proxyObjectFactory)(SequenceProxyPushSupplier::_PD_repoId) {}
    virtual ~_pof_SequenceProxyPushSupplier();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_SequenceProxyPushSupplier :
    public virtual _impl_ProxySupplier,
    public virtual CosNotifyComm::_impl_SequencePushSupplier
  {
  public:
    virtual ~_impl_SequenceProxyPushSupplier();

    virtual void connect_sequence_push_consumer(::CosNotifyComm::SequencePushConsumer_ptr push_consumer) = 0;
    virtual void suspend_connection() = 0;
    virtual void resume_connection() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SequenceProxyPushSupplier;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProxyID;

  typedef ::CORBA::Long ProxyID;
  typedef ::CORBA::Long_out ProxyID_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProxyIDSeq;

  class ProxyIDSeq_var;

  class ProxyIDSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ProxyID, 4, 4 >  {
  public:
    typedef ProxyIDSeq_var _var_type;
    inline ProxyIDSeq() {}
    inline ProxyIDSeq(const ProxyIDSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ProxyID, 4, 4 > (_s) {}

    inline ProxyIDSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ProxyID, 4, 4 > (_max) {}
    inline ProxyIDSeq(_CORBA_ULong _max, _CORBA_ULong _len, ProxyID* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ProxyID, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline ProxyIDSeq& operator = (const ProxyIDSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ProxyID, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class ProxyIDSeq_out;

  class ProxyIDSeq_var {
  public:
    inline ProxyIDSeq_var() : _pd_seq(0) {}
    inline ProxyIDSeq_var(ProxyIDSeq* _s) : _pd_seq(_s) {}
    inline ProxyIDSeq_var(const ProxyIDSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new ProxyIDSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~ProxyIDSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline ProxyIDSeq_var& operator = (ProxyIDSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ProxyIDSeq_var& operator = (const ProxyIDSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new ProxyIDSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ProxyID& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ProxyIDSeq* operator -> () { return _pd_seq; }
    inline const ProxyIDSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ProxyIDSeq& () const { return *_pd_seq; }
#else
    inline operator const ProxyIDSeq& () const { return *_pd_seq; }
    inline operator ProxyIDSeq& () { return *_pd_seq; }
#endif
      
    inline const ProxyIDSeq& in() const { return *_pd_seq; }
    inline ProxyIDSeq&       inout()    { return *_pd_seq; }
    inline ProxyIDSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ProxyIDSeq* _retn() { ProxyIDSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ProxyIDSeq_out;
    
  private:
    ProxyIDSeq* _pd_seq;
  };

  class ProxyIDSeq_out {
  public:
    inline ProxyIDSeq_out(ProxyIDSeq*& _s) : _data(_s) { _data = 0; }
    inline ProxyIDSeq_out(ProxyIDSeq_var& _s)
      : _data(_s._pd_seq) { _s = (ProxyIDSeq*) 0; }
    inline ProxyIDSeq_out(const ProxyIDSeq_out& _s) : _data(_s._data) {}
    inline ProxyIDSeq_out& operator = (const ProxyIDSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ProxyIDSeq_out& operator = (ProxyIDSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator ProxyIDSeq*&()  { return _data; }
    inline ProxyIDSeq*& ptr()       { return _data; }
    inline ProxyIDSeq* operator->() { return _data; }

    inline ProxyID& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ProxyIDSeq*& _data;

  private:
    ProxyIDSeq_out();
    ProxyIDSeq_out& operator=(const ProxyIDSeq_var&);
  };

  enum ClientType { ANY_EVENT, STRUCTURED_EVENT, SEQUENCE_EVENT /*, __max_ClientType=0xffffffff */ };
  typedef ClientType& ClientType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ClientType;

  enum InterFilterGroupOperator { AND_OP, OR_OP /*, __max_InterFilterGroupOperator=0xffffffff */ };
  typedef InterFilterGroupOperator& InterFilterGroupOperator_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InterFilterGroupOperator;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AdminID;

  typedef ::CORBA::Long AdminID;
  typedef ::CORBA::Long_out AdminID_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AdminIDSeq;

  class AdminIDSeq_var;

  class AdminIDSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< AdminID, 4, 4 >  {
  public:
    typedef AdminIDSeq_var _var_type;
    inline AdminIDSeq() {}
    inline AdminIDSeq(const AdminIDSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< AdminID, 4, 4 > (_s) {}

    inline AdminIDSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< AdminID, 4, 4 > (_max) {}
    inline AdminIDSeq(_CORBA_ULong _max, _CORBA_ULong _len, AdminID* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< AdminID, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline AdminIDSeq& operator = (const AdminIDSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< AdminID, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class AdminIDSeq_out;

  class AdminIDSeq_var {
  public:
    inline AdminIDSeq_var() : _pd_seq(0) {}
    inline AdminIDSeq_var(AdminIDSeq* _s) : _pd_seq(_s) {}
    inline AdminIDSeq_var(const AdminIDSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new AdminIDSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~AdminIDSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline AdminIDSeq_var& operator = (AdminIDSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline AdminIDSeq_var& operator = (const AdminIDSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new AdminIDSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline AdminID& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline AdminIDSeq* operator -> () { return _pd_seq; }
    inline const AdminIDSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator AdminIDSeq& () const { return *_pd_seq; }
#else
    inline operator const AdminIDSeq& () const { return *_pd_seq; }
    inline operator AdminIDSeq& () { return *_pd_seq; }
#endif
      
    inline const AdminIDSeq& in() const { return *_pd_seq; }
    inline AdminIDSeq&       inout()    { return *_pd_seq; }
    inline AdminIDSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline AdminIDSeq* _retn() { AdminIDSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class AdminIDSeq_out;
    
  private:
    AdminIDSeq* _pd_seq;
  };

  class AdminIDSeq_out {
  public:
    inline AdminIDSeq_out(AdminIDSeq*& _s) : _data(_s) { _data = 0; }
    inline AdminIDSeq_out(AdminIDSeq_var& _s)
      : _data(_s._pd_seq) { _s = (AdminIDSeq*) 0; }
    inline AdminIDSeq_out(const AdminIDSeq_out& _s) : _data(_s._data) {}
    inline AdminIDSeq_out& operator = (const AdminIDSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline AdminIDSeq_out& operator = (AdminIDSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator AdminIDSeq*&()  { return _data; }
    inline AdminIDSeq*& ptr()       { return _data; }
    inline AdminIDSeq* operator->() { return _data; }

    inline AdminID& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    AdminIDSeq*& _data;

  private:
    AdminIDSeq_out();
    AdminIDSeq_out& operator=(const AdminIDSeq_var&);
  };

  class AdminNotFound : public ::CORBA::UserException {
  public:
    
    

    inline AdminNotFound() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    AdminNotFound(const AdminNotFound&);
    
    AdminNotFound& operator=(const AdminNotFound&);
    virtual ~AdminNotFound();
    virtual void _raise() const;
    static AdminNotFound* _downcast(::CORBA::Exception*);
    static const AdminNotFound* _downcast(const ::CORBA::Exception*);
    static inline AdminNotFound* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AdminNotFound;

  class ProxyNotFound : public ::CORBA::UserException {
  public:
    
    

    inline ProxyNotFound() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    ProxyNotFound(const ProxyNotFound&);
    
    ProxyNotFound& operator=(const ProxyNotFound&);
    virtual ~ProxyNotFound();
    virtual void _raise() const;
    static ProxyNotFound* _downcast(::CORBA::Exception*);
    static const ProxyNotFound* _downcast(const ::CORBA::Exception*);
    static inline ProxyNotFound* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProxyNotFound;

  struct AdminLimit {
    typedef _CORBA_ConstrType_Variable_Var<AdminLimit> _var_type;

    
    ::CORBA::String_member name;

    CosNotification::PropertyValue value;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef AdminLimit::_var_type AdminLimit_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< AdminLimit,AdminLimit_var > AdminLimit_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AdminLimit;

  class AdminLimitExceeded : public ::CORBA::UserException {
  public:
    
    AdminLimit admin_property_err;

  

    inline AdminLimitExceeded() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    AdminLimitExceeded(const AdminLimitExceeded&);
    AdminLimitExceeded(const AdminLimit& i_admin_property_err);
    AdminLimitExceeded& operator=(const AdminLimitExceeded&);
    virtual ~AdminLimitExceeded();
    virtual void _raise() const;
    static AdminLimitExceeded* _downcast(::CORBA::Exception*);
    static const AdminLimitExceeded* _downcast(const ::CORBA::Exception*);
    static inline AdminLimitExceeded* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AdminLimitExceeded;

#ifndef __CosNotifyChannelAdmin_mConsumerAdmin__
#define __CosNotifyChannelAdmin_mConsumerAdmin__
  class ConsumerAdmin;
  class _objref_ConsumerAdmin;
  class _impl_ConsumerAdmin;
  
  typedef _objref_ConsumerAdmin* ConsumerAdmin_ptr;
  typedef ConsumerAdmin_ptr ConsumerAdminRef;

  class ConsumerAdmin_Helper {
  public:
    typedef ConsumerAdmin_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ConsumerAdmin, ConsumerAdmin_Helper> ConsumerAdmin_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ConsumerAdmin,ConsumerAdmin_Helper > ConsumerAdmin_out;

#endif

  // interface ConsumerAdmin
  class ConsumerAdmin {
  public:
    // Declarations for this interface type.
    typedef ConsumerAdmin_ptr _ptr_type;
    typedef ConsumerAdmin_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ConsumerAdmin :
    public virtual CosNotification::_objref_QoSAdmin,
    public virtual CosNotifyComm::_objref_NotifySubscribe,
    public virtual CosNotifyFilter::_objref_FilterAdmin,
    public virtual CosEventChannelAdmin::_objref_ConsumerAdmin
  {
  public:
    // IDL operations
    AdminID MyID();
    EventChannel_ptr MyChannel();
    InterFilterGroupOperator MyOperator();
    CosNotifyFilter::MappingFilter_ptr priority_filter();
    void priority_filter(::CosNotifyFilter::MappingFilter_ptr _v);
    CosNotifyFilter::MappingFilter_ptr lifetime_filter();
    void lifetime_filter(::CosNotifyFilter::MappingFilter_ptr _v);
    ProxyIDSeq* pull_suppliers();
    ProxyIDSeq* push_suppliers();
    ProxySupplier_ptr get_proxy_supplier(::CosNotifyChannelAdmin::ProxyID proxy_id);
    ProxySupplier_ptr obtain_notification_pull_supplier(::CosNotifyChannelAdmin::ClientType ctype, ::CosNotifyChannelAdmin::ProxyID& proxy_id);
    ProxySupplier_ptr obtain_notification_push_supplier(::CosNotifyChannelAdmin::ClientType ctype, ::CosNotifyChannelAdmin::ProxyID& proxy_id);
    void destroy();

    // Constructors
    inline _objref_ConsumerAdmin()  { _PR_setobj(0); }  // nil
    _objref_ConsumerAdmin(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ConsumerAdmin();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ConsumerAdmin(const _objref_ConsumerAdmin&);
    _objref_ConsumerAdmin& operator = (const _objref_ConsumerAdmin&);
    // not implemented

    friend class ConsumerAdmin;
  };

  class _pof_ConsumerAdmin : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ConsumerAdmin() : _OMNI_NS(proxyObjectFactory)(ConsumerAdmin::_PD_repoId) {}
    virtual ~_pof_ConsumerAdmin();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ConsumerAdmin :
    public virtual CosNotification::_impl_QoSAdmin,
    public virtual CosNotifyComm::_impl_NotifySubscribe,
    public virtual CosNotifyFilter::_impl_FilterAdmin,
    public virtual CosEventChannelAdmin::_impl_ConsumerAdmin
  {
  public:
    virtual ~_impl_ConsumerAdmin();

    virtual AdminID MyID() = 0;
    virtual EventChannel_ptr MyChannel() = 0;
    virtual InterFilterGroupOperator MyOperator() = 0;
    virtual CosNotifyFilter::MappingFilter_ptr priority_filter() = 0;
    virtual void priority_filter(::CosNotifyFilter::MappingFilter_ptr _v) = 0;
    virtual CosNotifyFilter::MappingFilter_ptr lifetime_filter() = 0;
    virtual void lifetime_filter(::CosNotifyFilter::MappingFilter_ptr _v) = 0;
    virtual ProxyIDSeq* pull_suppliers() = 0;
    virtual ProxyIDSeq* push_suppliers() = 0;
    virtual ProxySupplier_ptr get_proxy_supplier(::CosNotifyChannelAdmin::ProxyID proxy_id) = 0;
    virtual ProxySupplier_ptr obtain_notification_pull_supplier(::CosNotifyChannelAdmin::ClientType ctype, ::CosNotifyChannelAdmin::ProxyID& proxy_id) = 0;
    virtual ProxySupplier_ptr obtain_notification_push_supplier(::CosNotifyChannelAdmin::ClientType ctype, ::CosNotifyChannelAdmin::ProxyID& proxy_id) = 0;
    virtual void destroy() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConsumerAdmin;

#ifndef __CosNotifyChannelAdmin_mSupplierAdmin__
#define __CosNotifyChannelAdmin_mSupplierAdmin__
  class SupplierAdmin;
  class _objref_SupplierAdmin;
  class _impl_SupplierAdmin;
  
  typedef _objref_SupplierAdmin* SupplierAdmin_ptr;
  typedef SupplierAdmin_ptr SupplierAdminRef;

  class SupplierAdmin_Helper {
  public:
    typedef SupplierAdmin_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SupplierAdmin, SupplierAdmin_Helper> SupplierAdmin_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SupplierAdmin,SupplierAdmin_Helper > SupplierAdmin_out;

#endif

  // interface SupplierAdmin
  class SupplierAdmin {
  public:
    // Declarations for this interface type.
    typedef SupplierAdmin_ptr _ptr_type;
    typedef SupplierAdmin_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_SupplierAdmin :
    public virtual CosNotification::_objref_QoSAdmin,
    public virtual CosNotifyComm::_objref_NotifyPublish,
    public virtual CosNotifyFilter::_objref_FilterAdmin,
    public virtual CosEventChannelAdmin::_objref_SupplierAdmin
  {
  public:
    // IDL operations
    AdminID MyID();
    EventChannel_ptr MyChannel();
    InterFilterGroupOperator MyOperator();
    ProxyIDSeq* pull_consumers();
    ProxyIDSeq* push_consumers();
    ProxyConsumer_ptr get_proxy_consumer(::CosNotifyChannelAdmin::ProxyID proxy_id);
    ProxyConsumer_ptr obtain_notification_pull_consumer(::CosNotifyChannelAdmin::ClientType ctype, ::CosNotifyChannelAdmin::ProxyID& proxy_id);
    ProxyConsumer_ptr obtain_notification_push_consumer(::CosNotifyChannelAdmin::ClientType ctype, ::CosNotifyChannelAdmin::ProxyID& proxy_id);
    void destroy();

    // Constructors
    inline _objref_SupplierAdmin()  { _PR_setobj(0); }  // nil
    _objref_SupplierAdmin(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_SupplierAdmin();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_SupplierAdmin(const _objref_SupplierAdmin&);
    _objref_SupplierAdmin& operator = (const _objref_SupplierAdmin&);
    // not implemented

    friend class SupplierAdmin;
  };

  class _pof_SupplierAdmin : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_SupplierAdmin() : _OMNI_NS(proxyObjectFactory)(SupplierAdmin::_PD_repoId) {}
    virtual ~_pof_SupplierAdmin();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_SupplierAdmin :
    public virtual CosNotification::_impl_QoSAdmin,
    public virtual CosNotifyComm::_impl_NotifyPublish,
    public virtual CosNotifyFilter::_impl_FilterAdmin,
    public virtual CosEventChannelAdmin::_impl_SupplierAdmin
  {
  public:
    virtual ~_impl_SupplierAdmin();

    virtual AdminID MyID() = 0;
    virtual EventChannel_ptr MyChannel() = 0;
    virtual InterFilterGroupOperator MyOperator() = 0;
    virtual ProxyIDSeq* pull_consumers() = 0;
    virtual ProxyIDSeq* push_consumers() = 0;
    virtual ProxyConsumer_ptr get_proxy_consumer(::CosNotifyChannelAdmin::ProxyID proxy_id) = 0;
    virtual ProxyConsumer_ptr obtain_notification_pull_consumer(::CosNotifyChannelAdmin::ClientType ctype, ::CosNotifyChannelAdmin::ProxyID& proxy_id) = 0;
    virtual ProxyConsumer_ptr obtain_notification_push_consumer(::CosNotifyChannelAdmin::ClientType ctype, ::CosNotifyChannelAdmin::ProxyID& proxy_id) = 0;
    virtual void destroy() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SupplierAdmin;

#ifndef __CosNotifyChannelAdmin_mEventChannel__
#define __CosNotifyChannelAdmin_mEventChannel__
  class EventChannel;
  class _objref_EventChannel;
  class _impl_EventChannel;
  
  typedef _objref_EventChannel* EventChannel_ptr;
  typedef EventChannel_ptr EventChannelRef;

  class EventChannel_Helper {
  public:
    typedef EventChannel_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_EventChannel, EventChannel_Helper> EventChannel_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_EventChannel,EventChannel_Helper > EventChannel_out;

#endif

  // interface EventChannel
  class EventChannel {
  public:
    // Declarations for this interface type.
    typedef EventChannel_ptr _ptr_type;
    typedef EventChannel_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_EventChannel :
    public virtual CosNotification::_objref_QoSAdmin,
    public virtual CosNotification::_objref_AdminPropertiesAdmin,
    public virtual CosEventChannelAdmin::_objref_EventChannel
  {
  public:
    // IDL operations
    EventChannelFactory_ptr MyFactory();
    ConsumerAdmin_ptr default_consumer_admin();
    SupplierAdmin_ptr default_supplier_admin();
    CosNotifyFilter::FilterFactory_ptr default_filter_factory();
    ConsumerAdmin_ptr new_for_consumers(::CosNotifyChannelAdmin::InterFilterGroupOperator op, ::CosNotifyChannelAdmin::AdminID& id);
    SupplierAdmin_ptr new_for_suppliers(::CosNotifyChannelAdmin::InterFilterGroupOperator op, ::CosNotifyChannelAdmin::AdminID& id);
    ConsumerAdmin_ptr get_consumeradmin(::CosNotifyChannelAdmin::AdminID id);
    SupplierAdmin_ptr get_supplieradmin(::CosNotifyChannelAdmin::AdminID id);
    AdminIDSeq* get_all_consumeradmins();
    AdminIDSeq* get_all_supplieradmins();

    // Constructors
    inline _objref_EventChannel()  { _PR_setobj(0); }  // nil
    _objref_EventChannel(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_EventChannel();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_EventChannel(const _objref_EventChannel&);
    _objref_EventChannel& operator = (const _objref_EventChannel&);
    // not implemented

    friend class EventChannel;
  };

  class _pof_EventChannel : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_EventChannel() : _OMNI_NS(proxyObjectFactory)(EventChannel::_PD_repoId) {}
    virtual ~_pof_EventChannel();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_EventChannel :
    public virtual CosNotification::_impl_QoSAdmin,
    public virtual CosNotification::_impl_AdminPropertiesAdmin,
    public virtual CosEventChannelAdmin::_impl_EventChannel
  {
  public:
    virtual ~_impl_EventChannel();

    virtual EventChannelFactory_ptr MyFactory() = 0;
    virtual ConsumerAdmin_ptr default_consumer_admin() = 0;
    virtual SupplierAdmin_ptr default_supplier_admin() = 0;
    virtual CosNotifyFilter::FilterFactory_ptr default_filter_factory() = 0;
    virtual ConsumerAdmin_ptr new_for_consumers(::CosNotifyChannelAdmin::InterFilterGroupOperator op, ::CosNotifyChannelAdmin::AdminID& id) = 0;
    virtual SupplierAdmin_ptr new_for_suppliers(::CosNotifyChannelAdmin::InterFilterGroupOperator op, ::CosNotifyChannelAdmin::AdminID& id) = 0;
    virtual ConsumerAdmin_ptr get_consumeradmin(::CosNotifyChannelAdmin::AdminID id) = 0;
    virtual SupplierAdmin_ptr get_supplieradmin(::CosNotifyChannelAdmin::AdminID id) = 0;
    virtual AdminIDSeq* get_all_consumeradmins() = 0;
    virtual AdminIDSeq* get_all_supplieradmins() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventChannel;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ChannelID;

  typedef ::CORBA::Long ChannelID;
  typedef ::CORBA::Long_out ChannelID_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ChannelIDSeq;

  class ChannelIDSeq_var;

  class ChannelIDSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ChannelID, 4, 4 >  {
  public:
    typedef ChannelIDSeq_var _var_type;
    inline ChannelIDSeq() {}
    inline ChannelIDSeq(const ChannelIDSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ChannelID, 4, 4 > (_s) {}

    inline ChannelIDSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ChannelID, 4, 4 > (_max) {}
    inline ChannelIDSeq(_CORBA_ULong _max, _CORBA_ULong _len, ChannelID* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ChannelID, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline ChannelIDSeq& operator = (const ChannelIDSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ChannelID, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class ChannelIDSeq_out;

  class ChannelIDSeq_var {
  public:
    inline ChannelIDSeq_var() : _pd_seq(0) {}
    inline ChannelIDSeq_var(ChannelIDSeq* _s) : _pd_seq(_s) {}
    inline ChannelIDSeq_var(const ChannelIDSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new ChannelIDSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~ChannelIDSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline ChannelIDSeq_var& operator = (ChannelIDSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ChannelIDSeq_var& operator = (const ChannelIDSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new ChannelIDSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ChannelID& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ChannelIDSeq* operator -> () { return _pd_seq; }
    inline const ChannelIDSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ChannelIDSeq& () const { return *_pd_seq; }
#else
    inline operator const ChannelIDSeq& () const { return *_pd_seq; }
    inline operator ChannelIDSeq& () { return *_pd_seq; }
#endif
      
    inline const ChannelIDSeq& in() const { return *_pd_seq; }
    inline ChannelIDSeq&       inout()    { return *_pd_seq; }
    inline ChannelIDSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ChannelIDSeq* _retn() { ChannelIDSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ChannelIDSeq_out;
    
  private:
    ChannelIDSeq* _pd_seq;
  };

  class ChannelIDSeq_out {
  public:
    inline ChannelIDSeq_out(ChannelIDSeq*& _s) : _data(_s) { _data = 0; }
    inline ChannelIDSeq_out(ChannelIDSeq_var& _s)
      : _data(_s._pd_seq) { _s = (ChannelIDSeq*) 0; }
    inline ChannelIDSeq_out(const ChannelIDSeq_out& _s) : _data(_s._data) {}
    inline ChannelIDSeq_out& operator = (const ChannelIDSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ChannelIDSeq_out& operator = (ChannelIDSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator ChannelIDSeq*&()  { return _data; }
    inline ChannelIDSeq*& ptr()       { return _data; }
    inline ChannelIDSeq* operator->() { return _data; }

    inline ChannelID& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ChannelIDSeq*& _data;

  private:
    ChannelIDSeq_out();
    ChannelIDSeq_out& operator=(const ChannelIDSeq_var&);
  };

  class ChannelNotFound : public ::CORBA::UserException {
  public:
    
    

    inline ChannelNotFound() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    ChannelNotFound(const ChannelNotFound&);
    
    ChannelNotFound& operator=(const ChannelNotFound&);
    virtual ~ChannelNotFound();
    virtual void _raise() const;
    static ChannelNotFound* _downcast(::CORBA::Exception*);
    static const ChannelNotFound* _downcast(const ::CORBA::Exception*);
    static inline ChannelNotFound* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ChannelNotFound;

#ifndef __CosNotifyChannelAdmin_mEventChannelFactory__
#define __CosNotifyChannelAdmin_mEventChannelFactory__
  class EventChannelFactory;
  class _objref_EventChannelFactory;
  class _impl_EventChannelFactory;
  
  typedef _objref_EventChannelFactory* EventChannelFactory_ptr;
  typedef EventChannelFactory_ptr EventChannelFactoryRef;

  class EventChannelFactory_Helper {
  public:
    typedef EventChannelFactory_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_EventChannelFactory, EventChannelFactory_Helper> EventChannelFactory_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_EventChannelFactory,EventChannelFactory_Helper > EventChannelFactory_out;

#endif

  // interface EventChannelFactory
  class EventChannelFactory {
  public:
    // Declarations for this interface type.
    typedef EventChannelFactory_ptr _ptr_type;
    typedef EventChannelFactory_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_EventChannelFactory :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    EventChannel_ptr create_channel(const ::CosNotification::QoSProperties& initial_qos, const ::CosNotification::AdminProperties& initial_admin, ::CosNotifyChannelAdmin::ChannelID& id);
    ChannelIDSeq* get_all_channels();
    EventChannel_ptr get_event_channel(::CosNotifyChannelAdmin::ChannelID id);

    // Constructors
    inline _objref_EventChannelFactory()  { _PR_setobj(0); }  // nil
    _objref_EventChannelFactory(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_EventChannelFactory();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_EventChannelFactory(const _objref_EventChannelFactory&);
    _objref_EventChannelFactory& operator = (const _objref_EventChannelFactory&);
    // not implemented

    friend class EventChannelFactory;
  };

  class _pof_EventChannelFactory : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_EventChannelFactory() : _OMNI_NS(proxyObjectFactory)(EventChannelFactory::_PD_repoId) {}
    virtual ~_pof_EventChannelFactory();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_EventChannelFactory :
    public virtual omniServant
  {
  public:
    virtual ~_impl_EventChannelFactory();

    virtual EventChannel_ptr create_channel(const ::CosNotification::QoSProperties& initial_qos, const ::CosNotification::AdminProperties& initial_admin, ::CosNotifyChannelAdmin::ChannelID& id) = 0;
    virtual ChannelIDSeq* get_all_channels() = 0;
    virtual EventChannel_ptr get_event_channel(::CosNotifyChannelAdmin::ChannelID id) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventChannelFactory;

_CORBA_MODULE_END



_CORBA_MODULE POA_CosNotifyChannelAdmin
_CORBA_MODULE_BEG

  class ProxyConsumer :
    public virtual CosNotifyChannelAdmin::_impl_ProxyConsumer,
    public virtual POA_CosNotification::QoSAdmin,
      public virtual POA_CosNotifyFilter::FilterAdmin
  {
  public:
    virtual ~ProxyConsumer();

    inline ::CosNotifyChannelAdmin::ProxyConsumer_ptr _this() {
      return (::CosNotifyChannelAdmin::ProxyConsumer_ptr) _do_this(::CosNotifyChannelAdmin::ProxyConsumer::_PD_repoId);
    }
  };

  class ProxySupplier :
    public virtual CosNotifyChannelAdmin::_impl_ProxySupplier,
    public virtual POA_CosNotification::QoSAdmin,
      public virtual POA_CosNotifyFilter::FilterAdmin
  {
  public:
    virtual ~ProxySupplier();

    inline ::CosNotifyChannelAdmin::ProxySupplier_ptr _this() {
      return (::CosNotifyChannelAdmin::ProxySupplier_ptr) _do_this(::CosNotifyChannelAdmin::ProxySupplier::_PD_repoId);
    }
  };

  class ProxyPushConsumer :
    public virtual CosNotifyChannelAdmin::_impl_ProxyPushConsumer,
    public virtual ProxyConsumer,
      public virtual POA_CosNotifyComm::PushConsumer
  {
  public:
    virtual ~ProxyPushConsumer();

    inline ::CosNotifyChannelAdmin::ProxyPushConsumer_ptr _this() {
      return (::CosNotifyChannelAdmin::ProxyPushConsumer_ptr) _do_this(::CosNotifyChannelAdmin::ProxyPushConsumer::_PD_repoId);
    }
  };

  class StructuredProxyPushConsumer :
    public virtual CosNotifyChannelAdmin::_impl_StructuredProxyPushConsumer,
    public virtual ProxyConsumer,
      public virtual POA_CosNotifyComm::StructuredPushConsumer
  {
  public:
    virtual ~StructuredProxyPushConsumer();

    inline ::CosNotifyChannelAdmin::StructuredProxyPushConsumer_ptr _this() {
      return (::CosNotifyChannelAdmin::StructuredProxyPushConsumer_ptr) _do_this(::CosNotifyChannelAdmin::StructuredProxyPushConsumer::_PD_repoId);
    }
  };

  class SequenceProxyPushConsumer :
    public virtual CosNotifyChannelAdmin::_impl_SequenceProxyPushConsumer,
    public virtual ProxyConsumer,
      public virtual POA_CosNotifyComm::SequencePushConsumer
  {
  public:
    virtual ~SequenceProxyPushConsumer();

    inline ::CosNotifyChannelAdmin::SequenceProxyPushConsumer_ptr _this() {
      return (::CosNotifyChannelAdmin::SequenceProxyPushConsumer_ptr) _do_this(::CosNotifyChannelAdmin::SequenceProxyPushConsumer::_PD_repoId);
    }
  };

  class ProxyPullSupplier :
    public virtual CosNotifyChannelAdmin::_impl_ProxyPullSupplier,
    public virtual ProxySupplier,
      public virtual POA_CosNotifyComm::PullSupplier
  {
  public:
    virtual ~ProxyPullSupplier();

    inline ::CosNotifyChannelAdmin::ProxyPullSupplier_ptr _this() {
      return (::CosNotifyChannelAdmin::ProxyPullSupplier_ptr) _do_this(::CosNotifyChannelAdmin::ProxyPullSupplier::_PD_repoId);
    }
  };

  class StructuredProxyPullSupplier :
    public virtual CosNotifyChannelAdmin::_impl_StructuredProxyPullSupplier,
    public virtual ProxySupplier,
      public virtual POA_CosNotifyComm::StructuredPullSupplier
  {
  public:
    virtual ~StructuredProxyPullSupplier();

    inline ::CosNotifyChannelAdmin::StructuredProxyPullSupplier_ptr _this() {
      return (::CosNotifyChannelAdmin::StructuredProxyPullSupplier_ptr) _do_this(::CosNotifyChannelAdmin::StructuredProxyPullSupplier::_PD_repoId);
    }
  };

  class SequenceProxyPullSupplier :
    public virtual CosNotifyChannelAdmin::_impl_SequenceProxyPullSupplier,
    public virtual ProxySupplier,
      public virtual POA_CosNotifyComm::SequencePullSupplier
  {
  public:
    virtual ~SequenceProxyPullSupplier();

    inline ::CosNotifyChannelAdmin::SequenceProxyPullSupplier_ptr _this() {
      return (::CosNotifyChannelAdmin::SequenceProxyPullSupplier_ptr) _do_this(::CosNotifyChannelAdmin::SequenceProxyPullSupplier::_PD_repoId);
    }
  };

  class ProxyPullConsumer :
    public virtual CosNotifyChannelAdmin::_impl_ProxyPullConsumer,
    public virtual ProxyConsumer,
      public virtual POA_CosNotifyComm::PullConsumer
  {
  public:
    virtual ~ProxyPullConsumer();

    inline ::CosNotifyChannelAdmin::ProxyPullConsumer_ptr _this() {
      return (::CosNotifyChannelAdmin::ProxyPullConsumer_ptr) _do_this(::CosNotifyChannelAdmin::ProxyPullConsumer::_PD_repoId);
    }
  };

  class StructuredProxyPullConsumer :
    public virtual CosNotifyChannelAdmin::_impl_StructuredProxyPullConsumer,
    public virtual ProxyConsumer,
      public virtual POA_CosNotifyComm::StructuredPullConsumer
  {
  public:
    virtual ~StructuredProxyPullConsumer();

    inline ::CosNotifyChannelAdmin::StructuredProxyPullConsumer_ptr _this() {
      return (::CosNotifyChannelAdmin::StructuredProxyPullConsumer_ptr) _do_this(::CosNotifyChannelAdmin::StructuredProxyPullConsumer::_PD_repoId);
    }
  };

  class SequenceProxyPullConsumer :
    public virtual CosNotifyChannelAdmin::_impl_SequenceProxyPullConsumer,
    public virtual ProxyConsumer,
      public virtual POA_CosNotifyComm::SequencePullConsumer
  {
  public:
    virtual ~SequenceProxyPullConsumer();

    inline ::CosNotifyChannelAdmin::SequenceProxyPullConsumer_ptr _this() {
      return (::CosNotifyChannelAdmin::SequenceProxyPullConsumer_ptr) _do_this(::CosNotifyChannelAdmin::SequenceProxyPullConsumer::_PD_repoId);
    }
  };

  class ProxyPushSupplier :
    public virtual CosNotifyChannelAdmin::_impl_ProxyPushSupplier,
    public virtual ProxySupplier,
      public virtual POA_CosNotifyComm::PushSupplier
  {
  public:
    virtual ~ProxyPushSupplier();

    inline ::CosNotifyChannelAdmin::ProxyPushSupplier_ptr _this() {
      return (::CosNotifyChannelAdmin::ProxyPushSupplier_ptr) _do_this(::CosNotifyChannelAdmin::ProxyPushSupplier::_PD_repoId);
    }
  };

  class StructuredProxyPushSupplier :
    public virtual CosNotifyChannelAdmin::_impl_StructuredProxyPushSupplier,
    public virtual ProxySupplier,
      public virtual POA_CosNotifyComm::StructuredPushSupplier
  {
  public:
    virtual ~StructuredProxyPushSupplier();

    inline ::CosNotifyChannelAdmin::StructuredProxyPushSupplier_ptr _this() {
      return (::CosNotifyChannelAdmin::StructuredProxyPushSupplier_ptr) _do_this(::CosNotifyChannelAdmin::StructuredProxyPushSupplier::_PD_repoId);
    }
  };

  class SequenceProxyPushSupplier :
    public virtual CosNotifyChannelAdmin::_impl_SequenceProxyPushSupplier,
    public virtual ProxySupplier,
      public virtual POA_CosNotifyComm::SequencePushSupplier
  {
  public:
    virtual ~SequenceProxyPushSupplier();

    inline ::CosNotifyChannelAdmin::SequenceProxyPushSupplier_ptr _this() {
      return (::CosNotifyChannelAdmin::SequenceProxyPushSupplier_ptr) _do_this(::CosNotifyChannelAdmin::SequenceProxyPushSupplier::_PD_repoId);
    }
  };

  class ConsumerAdmin :
    public virtual CosNotifyChannelAdmin::_impl_ConsumerAdmin,
    public virtual POA_CosNotification::QoSAdmin,
      public virtual POA_CosNotifyComm::NotifySubscribe,
      public virtual POA_CosNotifyFilter::FilterAdmin,
      public virtual POA_CosEventChannelAdmin::ConsumerAdmin
  {
  public:
    virtual ~ConsumerAdmin();

    inline ::CosNotifyChannelAdmin::ConsumerAdmin_ptr _this() {
      return (::CosNotifyChannelAdmin::ConsumerAdmin_ptr) _do_this(::CosNotifyChannelAdmin::ConsumerAdmin::_PD_repoId);
    }
  };

  class SupplierAdmin :
    public virtual CosNotifyChannelAdmin::_impl_SupplierAdmin,
    public virtual POA_CosNotification::QoSAdmin,
      public virtual POA_CosNotifyComm::NotifyPublish,
      public virtual POA_CosNotifyFilter::FilterAdmin,
      public virtual POA_CosEventChannelAdmin::SupplierAdmin
  {
  public:
    virtual ~SupplierAdmin();

    inline ::CosNotifyChannelAdmin::SupplierAdmin_ptr _this() {
      return (::CosNotifyChannelAdmin::SupplierAdmin_ptr) _do_this(::CosNotifyChannelAdmin::SupplierAdmin::_PD_repoId);
    }
  };

  class EventChannel :
    public virtual CosNotifyChannelAdmin::_impl_EventChannel,
    public virtual POA_CosNotification::QoSAdmin,
      public virtual POA_CosNotification::AdminPropertiesAdmin,
      public virtual POA_CosEventChannelAdmin::EventChannel
  {
  public:
    virtual ~EventChannel();

    inline ::CosNotifyChannelAdmin::EventChannel_ptr _this() {
      return (::CosNotifyChannelAdmin::EventChannel_ptr) _do_this(::CosNotifyChannelAdmin::EventChannel::_PD_repoId);
    }
  };

  class EventChannelFactory :
    public virtual CosNotifyChannelAdmin::_impl_EventChannelFactory,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~EventChannelFactory();

    inline ::CosNotifyChannelAdmin::EventChannelFactory_ptr _this() {
      return (::CosNotifyChannelAdmin::EventChannelFactory_ptr) _do_this(::CosNotifyChannelAdmin::EventChannelFactory::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_CosNotifyChannelAdmin
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::ConnectionAlreadyActive& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::ConnectionAlreadyActive* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyChannelAdmin::ConnectionAlreadyActive*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::ConnectionAlreadyInactive& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::ConnectionAlreadyInactive* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyChannelAdmin::ConnectionAlreadyInactive*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::NotConnected& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::NotConnected* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyChannelAdmin::NotConnected*& _sp);

inline void operator >>=(CosNotifyChannelAdmin::ProxyType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CosNotifyChannelAdmin::ProxyType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CosNotifyChannelAdmin::PULL_TYPED) {
    _e = (CosNotifyChannelAdmin::ProxyType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyType& _s);

inline void operator >>=(CosNotifyChannelAdmin::ObtainInfoMode _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CosNotifyChannelAdmin::ObtainInfoMode& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CosNotifyChannelAdmin::NONE_NOW_UPDATES_ON) {
    _e = (CosNotifyChannelAdmin::ObtainInfoMode) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ObtainInfoMode _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::ObtainInfoMode& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyConsumer_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyConsumer_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyConsumer_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ProxySupplier_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ProxySupplier_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::ProxySupplier_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyPushConsumer_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyPushConsumer_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyPushConsumer_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::StructuredProxyPushConsumer_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::StructuredProxyPushConsumer_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::StructuredProxyPushConsumer_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::SequenceProxyPushConsumer_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::SequenceProxyPushConsumer_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::SequenceProxyPushConsumer_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyPullSupplier_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyPullSupplier_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyPullSupplier_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::StructuredProxyPullSupplier_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::StructuredProxyPullSupplier_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::StructuredProxyPullSupplier_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::SequenceProxyPullSupplier_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::SequenceProxyPullSupplier_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::SequenceProxyPullSupplier_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyPullConsumer_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyPullConsumer_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyPullConsumer_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::StructuredProxyPullConsumer_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::StructuredProxyPullConsumer_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::StructuredProxyPullConsumer_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::SequenceProxyPullConsumer_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::SequenceProxyPullConsumer_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::SequenceProxyPullConsumer_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyPushSupplier_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyPushSupplier_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyPushSupplier_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::StructuredProxyPushSupplier_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::StructuredProxyPushSupplier_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::StructuredProxyPushSupplier_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::SequenceProxyPushSupplier_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::SequenceProxyPushSupplier_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::SequenceProxyPushSupplier_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::ProxyIDSeq& _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyIDSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::ProxyIDSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyChannelAdmin::ProxyIDSeq*& _sp);

inline void operator >>=(CosNotifyChannelAdmin::ClientType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CosNotifyChannelAdmin::ClientType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CosNotifyChannelAdmin::SEQUENCE_EVENT) {
    _e = (CosNotifyChannelAdmin::ClientType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ClientType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::ClientType& _s);

inline void operator >>=(CosNotifyChannelAdmin::InterFilterGroupOperator _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CosNotifyChannelAdmin::InterFilterGroupOperator& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CosNotifyChannelAdmin::OR_OP) {
    _e = (CosNotifyChannelAdmin::InterFilterGroupOperator) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::InterFilterGroupOperator _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::InterFilterGroupOperator& _s);

void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::AdminIDSeq& _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::AdminIDSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::AdminIDSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyChannelAdmin::AdminIDSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::AdminNotFound& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::AdminNotFound* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyChannelAdmin::AdminNotFound*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::ProxyNotFound& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::ProxyNotFound* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyChannelAdmin::ProxyNotFound*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::AdminLimit& _s);
extern void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::AdminLimit* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::AdminLimit*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyChannelAdmin::AdminLimit*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::AdminLimitExceeded& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::AdminLimitExceeded* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyChannelAdmin::AdminLimitExceeded*& _sp);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ConsumerAdmin_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ConsumerAdmin_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::ConsumerAdmin_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::SupplierAdmin_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::SupplierAdmin_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::SupplierAdmin_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::EventChannel_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::EventChannel_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::EventChannel_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::ChannelIDSeq& _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::ChannelIDSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::ChannelIDSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyChannelAdmin::ChannelIDSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::ChannelNotFound& _s);
void operator<<=(::CORBA::Any& _a, const CosNotifyChannelAdmin::ChannelNotFound* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyChannelAdmin::ChannelNotFound*& _sp);

void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::EventChannelFactory_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotifyChannelAdmin::EventChannelFactory_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyChannelAdmin::EventChannelFactory_ptr& _s);



inline void
CosNotifyChannelAdmin::ProxyConsumer::_marshalObjRef(::CosNotifyChannelAdmin::ProxyConsumer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::ProxySupplier::_marshalObjRef(::CosNotifyChannelAdmin::ProxySupplier_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::ProxyPushConsumer::_marshalObjRef(::CosNotifyChannelAdmin::ProxyPushConsumer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::StructuredProxyPushConsumer::_marshalObjRef(::CosNotifyChannelAdmin::StructuredProxyPushConsumer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::SequenceProxyPushConsumer::_marshalObjRef(::CosNotifyChannelAdmin::SequenceProxyPushConsumer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::ProxyPullSupplier::_marshalObjRef(::CosNotifyChannelAdmin::ProxyPullSupplier_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::StructuredProxyPullSupplier::_marshalObjRef(::CosNotifyChannelAdmin::StructuredProxyPullSupplier_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::SequenceProxyPullSupplier::_marshalObjRef(::CosNotifyChannelAdmin::SequenceProxyPullSupplier_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::ProxyPullConsumer::_marshalObjRef(::CosNotifyChannelAdmin::ProxyPullConsumer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::StructuredProxyPullConsumer::_marshalObjRef(::CosNotifyChannelAdmin::StructuredProxyPullConsumer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::SequenceProxyPullConsumer::_marshalObjRef(::CosNotifyChannelAdmin::SequenceProxyPullConsumer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::ProxyPushSupplier::_marshalObjRef(::CosNotifyChannelAdmin::ProxyPushSupplier_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::StructuredProxyPushSupplier::_marshalObjRef(::CosNotifyChannelAdmin::StructuredProxyPushSupplier_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::SequenceProxyPushSupplier::_marshalObjRef(::CosNotifyChannelAdmin::SequenceProxyPushSupplier_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::ConsumerAdmin::_marshalObjRef(::CosNotifyChannelAdmin::ConsumerAdmin_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::SupplierAdmin::_marshalObjRef(::CosNotifyChannelAdmin::SupplierAdmin_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::EventChannel::_marshalObjRef(::CosNotifyChannelAdmin::EventChannel_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotifyChannelAdmin::EventChannelFactory::_marshalObjRef(::CosNotifyChannelAdmin::EventChannelFactory_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}



#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_CosNotifyChannelAdmin
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_CosNotifyChannelAdmin
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_CosNotifyChannelAdmin
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_CosNotifyChannelAdmin
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosNotifyChannelAdmin
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosNotifyChannelAdmin
#endif

#endif  // __CosNotifyChannelAdmin_hh__

