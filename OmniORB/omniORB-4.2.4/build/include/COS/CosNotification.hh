// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __CosNotification_hh__
#define __CosNotification_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_CosNotification
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_CosNotification
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosNotification
#endif


#include "COS_sysdep.h"



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE CosNotification

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Istring;

  typedef char* Istring;
  typedef ::CORBA::String_var Istring_var;
  typedef ::CORBA::String_out Istring_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PropertyName;

  typedef char* PropertyName;
  typedef ::CORBA::String_var PropertyName_var;
  typedef ::CORBA::String_out PropertyName_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PropertyValue;

  typedef ::CORBA::Any PropertyValue;
  typedef ::CORBA::Any_var PropertyValue_var;
  typedef ::CORBA::Any_out PropertyValue_out;

  struct Property {
    typedef _CORBA_ConstrType_Variable_Var<Property> _var_type;

    
    ::CORBA::String_member name;

    PropertyValue value;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Property::_var_type Property_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Property,Property_var > Property_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Property;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PropertySeq;

  class PropertySeq_var;

  class PropertySeq : public _CORBA_Unbounded_Sequence< Property >  {
  public:
    typedef PropertySeq_var _var_type;
    inline PropertySeq() {}
    inline PropertySeq(const PropertySeq& _s)
      : _CORBA_Unbounded_Sequence< Property > (_s) {}

    inline PropertySeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Property > (_max) {}
    inline PropertySeq(_CORBA_ULong _max, _CORBA_ULong _len, Property* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Property > (_max, _len, _val, _rel) {}

  

    inline PropertySeq& operator = (const PropertySeq& _s) {
      _CORBA_Unbounded_Sequence< Property > ::operator=(_s);
      return *this;
    }
  };

  class PropertySeq_out;

  class PropertySeq_var {
  public:
    inline PropertySeq_var() : _pd_seq(0) {}
    inline PropertySeq_var(PropertySeq* _s) : _pd_seq(_s) {}
    inline PropertySeq_var(const PropertySeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new PropertySeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~PropertySeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline PropertySeq_var& operator = (PropertySeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline PropertySeq_var& operator = (const PropertySeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new PropertySeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline Property& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline PropertySeq* operator -> () { return _pd_seq; }
    inline const PropertySeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator PropertySeq& () const { return *_pd_seq; }
#else
    inline operator const PropertySeq& () const { return *_pd_seq; }
    inline operator PropertySeq& () { return *_pd_seq; }
#endif
      
    inline const PropertySeq& in() const { return *_pd_seq; }
    inline PropertySeq&       inout()    { return *_pd_seq; }
    inline PropertySeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline PropertySeq* _retn() { PropertySeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class PropertySeq_out;
    
  private:
    PropertySeq* _pd_seq;
  };

  class PropertySeq_out {
  public:
    inline PropertySeq_out(PropertySeq*& _s) : _data(_s) { _data = 0; }
    inline PropertySeq_out(PropertySeq_var& _s)
      : _data(_s._pd_seq) { _s = (PropertySeq*) 0; }
    inline PropertySeq_out(const PropertySeq_out& _s) : _data(_s._data) {}
    inline PropertySeq_out& operator = (const PropertySeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline PropertySeq_out& operator = (PropertySeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator PropertySeq*&()  { return _data; }
    inline PropertySeq*& ptr()       { return _data; }
    inline PropertySeq* operator->() { return _data; }

    inline Property& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    PropertySeq*& _data;

  private:
    PropertySeq_out();
    PropertySeq_out& operator=(const PropertySeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OptionalHeaderFields;

  typedef PropertySeq OptionalHeaderFields;
  typedef PropertySeq_var OptionalHeaderFields_var;
  typedef PropertySeq_out OptionalHeaderFields_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FilterableEventBody;

  typedef PropertySeq FilterableEventBody;
  typedef PropertySeq_var FilterableEventBody_var;
  typedef PropertySeq_out FilterableEventBody_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_QoSProperties;

  typedef PropertySeq QoSProperties;
  typedef PropertySeq_var QoSProperties_var;
  typedef PropertySeq_out QoSProperties_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AdminProperties;

  typedef PropertySeq AdminProperties;
  typedef PropertySeq_var AdminProperties_var;
  typedef PropertySeq_out AdminProperties_out;

  struct EventType {
    typedef _CORBA_ConstrType_Variable_Var<EventType> _var_type;

    
    ::CORBA::String_member domain_name;

    ::CORBA::String_member type_name;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef EventType::_var_type EventType_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< EventType,EventType_var > EventType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventType;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventTypeSeq;

  class EventTypeSeq_var;

  class EventTypeSeq : public _CORBA_Unbounded_Sequence< EventType >  {
  public:
    typedef EventTypeSeq_var _var_type;
    inline EventTypeSeq() {}
    inline EventTypeSeq(const EventTypeSeq& _s)
      : _CORBA_Unbounded_Sequence< EventType > (_s) {}

    inline EventTypeSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< EventType > (_max) {}
    inline EventTypeSeq(_CORBA_ULong _max, _CORBA_ULong _len, EventType* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< EventType > (_max, _len, _val, _rel) {}

  

    inline EventTypeSeq& operator = (const EventTypeSeq& _s) {
      _CORBA_Unbounded_Sequence< EventType > ::operator=(_s);
      return *this;
    }
  };

  class EventTypeSeq_out;

  class EventTypeSeq_var {
  public:
    inline EventTypeSeq_var() : _pd_seq(0) {}
    inline EventTypeSeq_var(EventTypeSeq* _s) : _pd_seq(_s) {}
    inline EventTypeSeq_var(const EventTypeSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new EventTypeSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~EventTypeSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline EventTypeSeq_var& operator = (EventTypeSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline EventTypeSeq_var& operator = (const EventTypeSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new EventTypeSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline EventType& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline EventTypeSeq* operator -> () { return _pd_seq; }
    inline const EventTypeSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator EventTypeSeq& () const { return *_pd_seq; }
#else
    inline operator const EventTypeSeq& () const { return *_pd_seq; }
    inline operator EventTypeSeq& () { return *_pd_seq; }
#endif
      
    inline const EventTypeSeq& in() const { return *_pd_seq; }
    inline EventTypeSeq&       inout()    { return *_pd_seq; }
    inline EventTypeSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline EventTypeSeq* _retn() { EventTypeSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class EventTypeSeq_out;
    
  private:
    EventTypeSeq* _pd_seq;
  };

  class EventTypeSeq_out {
  public:
    inline EventTypeSeq_out(EventTypeSeq*& _s) : _data(_s) { _data = 0; }
    inline EventTypeSeq_out(EventTypeSeq_var& _s)
      : _data(_s._pd_seq) { _s = (EventTypeSeq*) 0; }
    inline EventTypeSeq_out(const EventTypeSeq_out& _s) : _data(_s._data) {}
    inline EventTypeSeq_out& operator = (const EventTypeSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline EventTypeSeq_out& operator = (EventTypeSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator EventTypeSeq*&()  { return _data; }
    inline EventTypeSeq*& ptr()       { return _data; }
    inline EventTypeSeq* operator->() { return _data; }

    inline EventType& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    EventTypeSeq*& _data;

  private:
    EventTypeSeq_out();
    EventTypeSeq_out& operator=(const EventTypeSeq_var&);
  };

  struct PropertyRange {
    typedef _CORBA_ConstrType_Variable_Var<PropertyRange> _var_type;

    
    PropertyValue low_val;

    PropertyValue high_val;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PropertyRange::_var_type PropertyRange_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< PropertyRange,PropertyRange_var > PropertyRange_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PropertyRange;

  struct NamedPropertyRange {
    typedef _CORBA_ConstrType_Variable_Var<NamedPropertyRange> _var_type;

    
    ::CORBA::String_member name;

    PropertyRange range;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef NamedPropertyRange::_var_type NamedPropertyRange_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< NamedPropertyRange,NamedPropertyRange_var > NamedPropertyRange_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NamedPropertyRange;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NamedPropertyRangeSeq;

  class NamedPropertyRangeSeq_var;

  class NamedPropertyRangeSeq : public _CORBA_Unbounded_Sequence< NamedPropertyRange >  {
  public:
    typedef NamedPropertyRangeSeq_var _var_type;
    inline NamedPropertyRangeSeq() {}
    inline NamedPropertyRangeSeq(const NamedPropertyRangeSeq& _s)
      : _CORBA_Unbounded_Sequence< NamedPropertyRange > (_s) {}

    inline NamedPropertyRangeSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< NamedPropertyRange > (_max) {}
    inline NamedPropertyRangeSeq(_CORBA_ULong _max, _CORBA_ULong _len, NamedPropertyRange* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< NamedPropertyRange > (_max, _len, _val, _rel) {}

  

    inline NamedPropertyRangeSeq& operator = (const NamedPropertyRangeSeq& _s) {
      _CORBA_Unbounded_Sequence< NamedPropertyRange > ::operator=(_s);
      return *this;
    }
  };

  class NamedPropertyRangeSeq_out;

  class NamedPropertyRangeSeq_var {
  public:
    inline NamedPropertyRangeSeq_var() : _pd_seq(0) {}
    inline NamedPropertyRangeSeq_var(NamedPropertyRangeSeq* _s) : _pd_seq(_s) {}
    inline NamedPropertyRangeSeq_var(const NamedPropertyRangeSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new NamedPropertyRangeSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~NamedPropertyRangeSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline NamedPropertyRangeSeq_var& operator = (NamedPropertyRangeSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline NamedPropertyRangeSeq_var& operator = (const NamedPropertyRangeSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new NamedPropertyRangeSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline NamedPropertyRange& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline NamedPropertyRangeSeq* operator -> () { return _pd_seq; }
    inline const NamedPropertyRangeSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator NamedPropertyRangeSeq& () const { return *_pd_seq; }
#else
    inline operator const NamedPropertyRangeSeq& () const { return *_pd_seq; }
    inline operator NamedPropertyRangeSeq& () { return *_pd_seq; }
#endif
      
    inline const NamedPropertyRangeSeq& in() const { return *_pd_seq; }
    inline NamedPropertyRangeSeq&       inout()    { return *_pd_seq; }
    inline NamedPropertyRangeSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline NamedPropertyRangeSeq* _retn() { NamedPropertyRangeSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class NamedPropertyRangeSeq_out;
    
  private:
    NamedPropertyRangeSeq* _pd_seq;
  };

  class NamedPropertyRangeSeq_out {
  public:
    inline NamedPropertyRangeSeq_out(NamedPropertyRangeSeq*& _s) : _data(_s) { _data = 0; }
    inline NamedPropertyRangeSeq_out(NamedPropertyRangeSeq_var& _s)
      : _data(_s._pd_seq) { _s = (NamedPropertyRangeSeq*) 0; }
    inline NamedPropertyRangeSeq_out(const NamedPropertyRangeSeq_out& _s) : _data(_s._data) {}
    inline NamedPropertyRangeSeq_out& operator = (const NamedPropertyRangeSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline NamedPropertyRangeSeq_out& operator = (NamedPropertyRangeSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator NamedPropertyRangeSeq*&()  { return _data; }
    inline NamedPropertyRangeSeq*& ptr()       { return _data; }
    inline NamedPropertyRangeSeq* operator->() { return _data; }

    inline NamedPropertyRange& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    NamedPropertyRangeSeq*& _data;

  private:
    NamedPropertyRangeSeq_out();
    NamedPropertyRangeSeq_out& operator=(const NamedPropertyRangeSeq_var&);
  };

  enum QoSError_code { UNSUPPORTED_PROPERTY, UNAVAILABLE_PROPERTY, UNSUPPORTED_VALUE, UNAVAILABLE_VALUE, BAD_PROPERTY, BAD_TYPE, BAD_VALUE /*, __max_QoSError_code=0xffffffff */ };
  typedef QoSError_code& QoSError_code_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_QoSError_code;

  struct PropertyError {
    typedef _CORBA_ConstrType_Variable_Var<PropertyError> _var_type;

    
    QoSError_code code;

    ::CORBA::String_member name;

    PropertyRange available_range;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PropertyError::_var_type PropertyError_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< PropertyError,PropertyError_var > PropertyError_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PropertyError;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PropertyErrorSeq;

  class PropertyErrorSeq_var;

  class PropertyErrorSeq : public _CORBA_Unbounded_Sequence< PropertyError >  {
  public:
    typedef PropertyErrorSeq_var _var_type;
    inline PropertyErrorSeq() {}
    inline PropertyErrorSeq(const PropertyErrorSeq& _s)
      : _CORBA_Unbounded_Sequence< PropertyError > (_s) {}

    inline PropertyErrorSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< PropertyError > (_max) {}
    inline PropertyErrorSeq(_CORBA_ULong _max, _CORBA_ULong _len, PropertyError* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< PropertyError > (_max, _len, _val, _rel) {}

  

    inline PropertyErrorSeq& operator = (const PropertyErrorSeq& _s) {
      _CORBA_Unbounded_Sequence< PropertyError > ::operator=(_s);
      return *this;
    }
  };

  class PropertyErrorSeq_out;

  class PropertyErrorSeq_var {
  public:
    inline PropertyErrorSeq_var() : _pd_seq(0) {}
    inline PropertyErrorSeq_var(PropertyErrorSeq* _s) : _pd_seq(_s) {}
    inline PropertyErrorSeq_var(const PropertyErrorSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new PropertyErrorSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~PropertyErrorSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline PropertyErrorSeq_var& operator = (PropertyErrorSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline PropertyErrorSeq_var& operator = (const PropertyErrorSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new PropertyErrorSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline PropertyError& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline PropertyErrorSeq* operator -> () { return _pd_seq; }
    inline const PropertyErrorSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator PropertyErrorSeq& () const { return *_pd_seq; }
#else
    inline operator const PropertyErrorSeq& () const { return *_pd_seq; }
    inline operator PropertyErrorSeq& () { return *_pd_seq; }
#endif
      
    inline const PropertyErrorSeq& in() const { return *_pd_seq; }
    inline PropertyErrorSeq&       inout()    { return *_pd_seq; }
    inline PropertyErrorSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline PropertyErrorSeq* _retn() { PropertyErrorSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class PropertyErrorSeq_out;
    
  private:
    PropertyErrorSeq* _pd_seq;
  };

  class PropertyErrorSeq_out {
  public:
    inline PropertyErrorSeq_out(PropertyErrorSeq*& _s) : _data(_s) { _data = 0; }
    inline PropertyErrorSeq_out(PropertyErrorSeq_var& _s)
      : _data(_s._pd_seq) { _s = (PropertyErrorSeq*) 0; }
    inline PropertyErrorSeq_out(const PropertyErrorSeq_out& _s) : _data(_s._data) {}
    inline PropertyErrorSeq_out& operator = (const PropertyErrorSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline PropertyErrorSeq_out& operator = (PropertyErrorSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator PropertyErrorSeq*&()  { return _data; }
    inline PropertyErrorSeq*& ptr()       { return _data; }
    inline PropertyErrorSeq* operator->() { return _data; }

    inline PropertyError& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    PropertyErrorSeq*& _data;

  private:
    PropertyErrorSeq_out();
    PropertyErrorSeq_out& operator=(const PropertyErrorSeq_var&);
  };

  class UnsupportedQoS : public ::CORBA::UserException {
  public:
    
    PropertyErrorSeq qos_err;

  

    inline UnsupportedQoS() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    UnsupportedQoS(const UnsupportedQoS&);
    UnsupportedQoS(const PropertyErrorSeq i_qos_err);
    UnsupportedQoS& operator=(const UnsupportedQoS&);
    virtual ~UnsupportedQoS();
    virtual void _raise() const;
    static UnsupportedQoS* _downcast(::CORBA::Exception*);
    static const UnsupportedQoS* _downcast(const ::CORBA::Exception*);
    static inline UnsupportedQoS* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnsupportedQoS;

  class UnsupportedAdmin : public ::CORBA::UserException {
  public:
    
    PropertyErrorSeq admin_err;

  

    inline UnsupportedAdmin() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    UnsupportedAdmin(const UnsupportedAdmin&);
    UnsupportedAdmin(const PropertyErrorSeq i_admin_err);
    UnsupportedAdmin& operator=(const UnsupportedAdmin&);
    virtual ~UnsupportedAdmin();
    virtual void _raise() const;
    static UnsupportedAdmin* _downcast(::CORBA::Exception*);
    static const UnsupportedAdmin* _downcast(const ::CORBA::Exception*);
    static inline UnsupportedAdmin* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnsupportedAdmin;

  struct FixedEventHeader {
    typedef _CORBA_ConstrType_Variable_Var<FixedEventHeader> _var_type;

    
    EventType event_type;

    ::CORBA::String_member event_name;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef FixedEventHeader::_var_type FixedEventHeader_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< FixedEventHeader,FixedEventHeader_var > FixedEventHeader_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FixedEventHeader;

  struct EventHeader {
    typedef _CORBA_ConstrType_Variable_Var<EventHeader> _var_type;

    
    FixedEventHeader fixed_header;

    OptionalHeaderFields variable_header;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef EventHeader::_var_type EventHeader_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< EventHeader,EventHeader_var > EventHeader_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventHeader;

  struct StructuredEvent {
    typedef _CORBA_ConstrType_Variable_Var<StructuredEvent> _var_type;

    
    EventHeader header;

    FilterableEventBody filterable_data;

    ::CORBA::Any remainder_of_body;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef StructuredEvent::_var_type StructuredEvent_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< StructuredEvent,StructuredEvent_var > StructuredEvent_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StructuredEvent;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventBatch;

  class EventBatch_var;

  class EventBatch : public _CORBA_Unbounded_Sequence< StructuredEvent >  {
  public:
    typedef EventBatch_var _var_type;
    inline EventBatch() {}
    inline EventBatch(const EventBatch& _s)
      : _CORBA_Unbounded_Sequence< StructuredEvent > (_s) {}

    inline EventBatch(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< StructuredEvent > (_max) {}
    inline EventBatch(_CORBA_ULong _max, _CORBA_ULong _len, StructuredEvent* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< StructuredEvent > (_max, _len, _val, _rel) {}

  

    inline EventBatch& operator = (const EventBatch& _s) {
      _CORBA_Unbounded_Sequence< StructuredEvent > ::operator=(_s);
      return *this;
    }
  };

  class EventBatch_out;

  class EventBatch_var {
  public:
    inline EventBatch_var() : _pd_seq(0) {}
    inline EventBatch_var(EventBatch* _s) : _pd_seq(_s) {}
    inline EventBatch_var(const EventBatch_var& _s) {
      if (_s._pd_seq)  _pd_seq = new EventBatch(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~EventBatch_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline EventBatch_var& operator = (EventBatch* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline EventBatch_var& operator = (const EventBatch_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new EventBatch;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline StructuredEvent& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline EventBatch* operator -> () { return _pd_seq; }
    inline const EventBatch* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator EventBatch& () const { return *_pd_seq; }
#else
    inline operator const EventBatch& () const { return *_pd_seq; }
    inline operator EventBatch& () { return *_pd_seq; }
#endif
      
    inline const EventBatch& in() const { return *_pd_seq; }
    inline EventBatch&       inout()    { return *_pd_seq; }
    inline EventBatch*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline EventBatch* _retn() { EventBatch* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class EventBatch_out;
    
  private:
    EventBatch* _pd_seq;
  };

  class EventBatch_out {
  public:
    inline EventBatch_out(EventBatch*& _s) : _data(_s) { _data = 0; }
    inline EventBatch_out(EventBatch_var& _s)
      : _data(_s._pd_seq) { _s = (EventBatch*) 0; }
    inline EventBatch_out(const EventBatch_out& _s) : _data(_s._data) {}
    inline EventBatch_out& operator = (const EventBatch_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline EventBatch_out& operator = (EventBatch* _s) {
      _data = _s;
      return *this;
    }
    inline operator EventBatch*&()  { return _data; }
    inline EventBatch*& ptr()       { return _data; }
    inline EventBatch* operator->() { return _data; }

    inline StructuredEvent& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    EventBatch*& _data;

  private:
    EventBatch_out();
    EventBatch_out& operator=(const EventBatch_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * EventReliability;

  _CORBA_MODULE_VARINT const ::CORBA::Short BestEffort _init_in_decl_( = 0 );

  _CORBA_MODULE_VARINT const ::CORBA::Short Persistent _init_in_decl_( = 1 );

  _CORBA_MODULE_VAR _core_attr const char * ConnectionReliability;

  _CORBA_MODULE_VAR _core_attr const char * Priority;

  _CORBA_MODULE_VARINT const ::CORBA::Short LowestPriority _init_in_decl_( = -32767 );

  _CORBA_MODULE_VARINT const ::CORBA::Short HighestPriority _init_in_decl_( = 32767 );

  _CORBA_MODULE_VARINT const ::CORBA::Short DefaultPriority _init_in_decl_( = 0 );

  _CORBA_MODULE_VAR _core_attr const char * StartTime;

  _CORBA_MODULE_VAR _core_attr const char * StopTime;

  _CORBA_MODULE_VAR _core_attr const char * Timeout;

  _CORBA_MODULE_VAR _core_attr const char * OrderPolicy;

  _CORBA_MODULE_VARINT const ::CORBA::Short AnyOrder _init_in_decl_( = 0 );

  _CORBA_MODULE_VARINT const ::CORBA::Short FifoOrder _init_in_decl_( = 1 );

  _CORBA_MODULE_VARINT const ::CORBA::Short PriorityOrder _init_in_decl_( = 2 );

  _CORBA_MODULE_VARINT const ::CORBA::Short DeadlineOrder _init_in_decl_( = 3 );

  _CORBA_MODULE_VAR _core_attr const char * DiscardPolicy;

  _CORBA_MODULE_VARINT const ::CORBA::Short LifoOrder _init_in_decl_( = 4 );

  _CORBA_MODULE_VAR _core_attr const char * MaximumBatchSize;

  _CORBA_MODULE_VAR _core_attr const char * PacingInterval;

  _CORBA_MODULE_VAR _core_attr const char * StartTimeSupported;

  _CORBA_MODULE_VAR _core_attr const char * StopTimeSupported;

  _CORBA_MODULE_VAR _core_attr const char * MaxEventsPerConsumer;

#ifndef __CosNotification_mQoSAdmin__
#define __CosNotification_mQoSAdmin__
  class QoSAdmin;
  class _objref_QoSAdmin;
  class _impl_QoSAdmin;
  
  typedef _objref_QoSAdmin* QoSAdmin_ptr;
  typedef QoSAdmin_ptr QoSAdminRef;

  class QoSAdmin_Helper {
  public:
    typedef QoSAdmin_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_QoSAdmin, QoSAdmin_Helper> QoSAdmin_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_QoSAdmin,QoSAdmin_Helper > QoSAdmin_out;

#endif

  // interface QoSAdmin
  class QoSAdmin {
  public:
    // Declarations for this interface type.
    typedef QoSAdmin_ptr _ptr_type;
    typedef QoSAdmin_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_QoSAdmin :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    QoSProperties* get_qos();
    void set_qos(const ::CosNotification::QoSProperties& qos);
    void validate_qos(const ::CosNotification::QoSProperties& required_qos, ::CosNotification::NamedPropertyRangeSeq_out available_qos);

    // Constructors
    inline _objref_QoSAdmin()  { _PR_setobj(0); }  // nil
    _objref_QoSAdmin(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_QoSAdmin();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_QoSAdmin(const _objref_QoSAdmin&);
    _objref_QoSAdmin& operator = (const _objref_QoSAdmin&);
    // not implemented

    friend class QoSAdmin;
  };

  class _pof_QoSAdmin : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_QoSAdmin() : _OMNI_NS(proxyObjectFactory)(QoSAdmin::_PD_repoId) {}
    virtual ~_pof_QoSAdmin();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_QoSAdmin :
    public virtual omniServant
  {
  public:
    virtual ~_impl_QoSAdmin();

    virtual QoSProperties* get_qos() = 0;
    virtual void set_qos(const ::CosNotification::QoSProperties& qos) = 0;
    virtual void validate_qos(const ::CosNotification::QoSProperties& required_qos, ::CosNotification::NamedPropertyRangeSeq_out available_qos) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_QoSAdmin;

  _CORBA_MODULE_VAR _core_attr const char * MaxQueueLength;

  _CORBA_MODULE_VAR _core_attr const char * MaxConsumers;

  _CORBA_MODULE_VAR _core_attr const char * MaxSuppliers;

  _CORBA_MODULE_VAR _core_attr const char * RejectNewEvents;

#ifndef __CosNotification_mAdminPropertiesAdmin__
#define __CosNotification_mAdminPropertiesAdmin__
  class AdminPropertiesAdmin;
  class _objref_AdminPropertiesAdmin;
  class _impl_AdminPropertiesAdmin;
  
  typedef _objref_AdminPropertiesAdmin* AdminPropertiesAdmin_ptr;
  typedef AdminPropertiesAdmin_ptr AdminPropertiesAdminRef;

  class AdminPropertiesAdmin_Helper {
  public:
    typedef AdminPropertiesAdmin_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_AdminPropertiesAdmin, AdminPropertiesAdmin_Helper> AdminPropertiesAdmin_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_AdminPropertiesAdmin,AdminPropertiesAdmin_Helper > AdminPropertiesAdmin_out;

#endif

  // interface AdminPropertiesAdmin
  class AdminPropertiesAdmin {
  public:
    // Declarations for this interface type.
    typedef AdminPropertiesAdmin_ptr _ptr_type;
    typedef AdminPropertiesAdmin_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_AdminPropertiesAdmin :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    AdminProperties* get_admin();
    void set_admin(const ::CosNotification::AdminProperties& admin);

    // Constructors
    inline _objref_AdminPropertiesAdmin()  { _PR_setobj(0); }  // nil
    _objref_AdminPropertiesAdmin(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_AdminPropertiesAdmin();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_AdminPropertiesAdmin(const _objref_AdminPropertiesAdmin&);
    _objref_AdminPropertiesAdmin& operator = (const _objref_AdminPropertiesAdmin&);
    // not implemented

    friend class AdminPropertiesAdmin;
  };

  class _pof_AdminPropertiesAdmin : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_AdminPropertiesAdmin() : _OMNI_NS(proxyObjectFactory)(AdminPropertiesAdmin::_PD_repoId) {}
    virtual ~_pof_AdminPropertiesAdmin();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_AdminPropertiesAdmin :
    public virtual omniServant
  {
  public:
    virtual ~_impl_AdminPropertiesAdmin();

    virtual AdminProperties* get_admin() = 0;
    virtual void set_admin(const ::CosNotification::AdminProperties& admin) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AdminPropertiesAdmin;

_CORBA_MODULE_END



_CORBA_MODULE POA_CosNotification
_CORBA_MODULE_BEG

  class QoSAdmin :
    public virtual CosNotification::_impl_QoSAdmin,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~QoSAdmin();

    inline ::CosNotification::QoSAdmin_ptr _this() {
      return (::CosNotification::QoSAdmin_ptr) _do_this(::CosNotification::QoSAdmin::_PD_repoId);
    }
  };

  class AdminPropertiesAdmin :
    public virtual CosNotification::_impl_AdminPropertiesAdmin,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~AdminPropertiesAdmin();

    inline ::CosNotification::AdminPropertiesAdmin_ptr _this() {
      return (::CosNotification::AdminPropertiesAdmin_ptr) _do_this(::CosNotification::AdminPropertiesAdmin::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_CosNotification
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const CosNotification::Property& _s);
extern void operator<<=(::CORBA::Any& _a, CosNotification::Property* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::Property*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::Property*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotification::PropertySeq& _s);
void operator<<=(::CORBA::Any& _a, CosNotification::PropertySeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::PropertySeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::PropertySeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CosNotification::EventType& _s);
extern void operator<<=(::CORBA::Any& _a, CosNotification::EventType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::EventType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::EventType*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotification::EventTypeSeq& _s);
void operator<<=(::CORBA::Any& _a, CosNotification::EventTypeSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::EventTypeSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::EventTypeSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CosNotification::PropertyRange& _s);
extern void operator<<=(::CORBA::Any& _a, CosNotification::PropertyRange* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::PropertyRange*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::PropertyRange*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CosNotification::NamedPropertyRange& _s);
extern void operator<<=(::CORBA::Any& _a, CosNotification::NamedPropertyRange* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::NamedPropertyRange*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::NamedPropertyRange*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotification::NamedPropertyRangeSeq& _s);
void operator<<=(::CORBA::Any& _a, CosNotification::NamedPropertyRangeSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::NamedPropertyRangeSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::NamedPropertyRangeSeq*& _sp);

inline void operator >>=(CosNotification::QoSError_code _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CosNotification::QoSError_code& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CosNotification::BAD_VALUE) {
    _e = (CosNotification::QoSError_code) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CosNotification::QoSError_code _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::QoSError_code& _s);

extern void operator<<=(::CORBA::Any& _a, const CosNotification::PropertyError& _s);
extern void operator<<=(::CORBA::Any& _a, CosNotification::PropertyError* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::PropertyError*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::PropertyError*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotification::PropertyErrorSeq& _s);
void operator<<=(::CORBA::Any& _a, CosNotification::PropertyErrorSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::PropertyErrorSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::PropertyErrorSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotification::UnsupportedQoS& _s);
void operator<<=(::CORBA::Any& _a, const CosNotification::UnsupportedQoS* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::UnsupportedQoS*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotification::UnsupportedAdmin& _s);
void operator<<=(::CORBA::Any& _a, const CosNotification::UnsupportedAdmin* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::UnsupportedAdmin*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CosNotification::FixedEventHeader& _s);
extern void operator<<=(::CORBA::Any& _a, CosNotification::FixedEventHeader* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::FixedEventHeader*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::FixedEventHeader*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CosNotification::EventHeader& _s);
extern void operator<<=(::CORBA::Any& _a, CosNotification::EventHeader* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::EventHeader*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::EventHeader*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CosNotification::StructuredEvent& _s);
extern void operator<<=(::CORBA::Any& _a, CosNotification::StructuredEvent* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::StructuredEvent*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::StructuredEvent*& _sp);

void operator<<=(::CORBA::Any& _a, const CosNotification::EventBatch& _s);
void operator<<=(::CORBA::Any& _a, CosNotification::EventBatch* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::EventBatch*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosNotification::EventBatch*& _sp);

void operator<<=(::CORBA::Any& _a, CosNotification::QoSAdmin_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotification::QoSAdmin_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::QoSAdmin_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosNotification::AdminPropertiesAdmin_ptr _s);
void operator<<=(::CORBA::Any& _a, CosNotification::AdminPropertiesAdmin_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosNotification::AdminPropertiesAdmin_ptr& _s);



inline void
CosNotification::QoSAdmin::_marshalObjRef(::CosNotification::QoSAdmin_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosNotification::AdminPropertiesAdmin::_marshalObjRef(::CosNotification::AdminPropertiesAdmin_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}



#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_CosNotification
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_CosNotification
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_CosNotification
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_CosNotification
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosNotification
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosNotification
#endif

#endif  // __CosNotification_hh__

