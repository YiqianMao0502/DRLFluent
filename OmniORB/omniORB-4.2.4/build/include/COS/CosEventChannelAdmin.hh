// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __CosEventChannelAdmin_hh__
#define __CosEventChannelAdmin_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_CosEventChannelAdmin
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_CosEventChannelAdmin
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosEventChannelAdmin
#endif


#include "COS_sysdep.h"
#ifndef __CosEventComm_hh_EXTERNAL_GUARD__
#define __CosEventComm_hh_EXTERNAL_GUARD__
#include "CosEventComm.hh"
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE CosEventChannelAdmin

_CORBA_MODULE_BEG

  class AlreadyConnected : public ::CORBA::UserException {
  public:
    
    

    inline AlreadyConnected() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    AlreadyConnected(const AlreadyConnected&);
    
    AlreadyConnected& operator=(const AlreadyConnected&);
    virtual ~AlreadyConnected();
    virtual void _raise() const;
    static AlreadyConnected* _downcast(::CORBA::Exception*);
    static const AlreadyConnected* _downcast(const ::CORBA::Exception*);
    static inline AlreadyConnected* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AlreadyConnected;

  class TypeError : public ::CORBA::UserException {
  public:
    
    

    inline TypeError() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    TypeError(const TypeError&);
    
    TypeError& operator=(const TypeError&);
    virtual ~TypeError();
    virtual void _raise() const;
    static TypeError* _downcast(::CORBA::Exception*);
    static const TypeError* _downcast(const ::CORBA::Exception*);
    static inline TypeError* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TypeError;

#ifndef __CosEventChannelAdmin_mProxyPushConsumer__
#define __CosEventChannelAdmin_mProxyPushConsumer__
  class ProxyPushConsumer;
  class _objref_ProxyPushConsumer;
  class _impl_ProxyPushConsumer;
  
  typedef _objref_ProxyPushConsumer* ProxyPushConsumer_ptr;
  typedef ProxyPushConsumer_ptr ProxyPushConsumerRef;

  class ProxyPushConsumer_Helper {
  public:
    typedef ProxyPushConsumer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ProxyPushConsumer, ProxyPushConsumer_Helper> ProxyPushConsumer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ProxyPushConsumer,ProxyPushConsumer_Helper > ProxyPushConsumer_out;

#endif

  // interface ProxyPushConsumer
  class ProxyPushConsumer {
  public:
    // Declarations for this interface type.
    typedef ProxyPushConsumer_ptr _ptr_type;
    typedef ProxyPushConsumer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ProxyPushConsumer :
    public virtual CosEventComm::_objref_PushConsumer
  {
  public:
    // IDL operations
    void connect_push_supplier(::CosEventComm::PushSupplier_ptr push_supplier);

    // Constructors
    inline _objref_ProxyPushConsumer()  { _PR_setobj(0); }  // nil
    _objref_ProxyPushConsumer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ProxyPushConsumer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ProxyPushConsumer(const _objref_ProxyPushConsumer&);
    _objref_ProxyPushConsumer& operator = (const _objref_ProxyPushConsumer&);
    // not implemented

    friend class ProxyPushConsumer;
  };

  class _pof_ProxyPushConsumer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ProxyPushConsumer() : _OMNI_NS(proxyObjectFactory)(ProxyPushConsumer::_PD_repoId) {}
    virtual ~_pof_ProxyPushConsumer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ProxyPushConsumer :
    public virtual CosEventComm::_impl_PushConsumer
  {
  public:
    virtual ~_impl_ProxyPushConsumer();

    virtual void connect_push_supplier(::CosEventComm::PushSupplier_ptr push_supplier) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProxyPushConsumer;

#ifndef __CosEventChannelAdmin_mProxyPullSupplier__
#define __CosEventChannelAdmin_mProxyPullSupplier__
  class ProxyPullSupplier;
  class _objref_ProxyPullSupplier;
  class _impl_ProxyPullSupplier;
  
  typedef _objref_ProxyPullSupplier* ProxyPullSupplier_ptr;
  typedef ProxyPullSupplier_ptr ProxyPullSupplierRef;

  class ProxyPullSupplier_Helper {
  public:
    typedef ProxyPullSupplier_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ProxyPullSupplier, ProxyPullSupplier_Helper> ProxyPullSupplier_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ProxyPullSupplier,ProxyPullSupplier_Helper > ProxyPullSupplier_out;

#endif

  // interface ProxyPullSupplier
  class ProxyPullSupplier {
  public:
    // Declarations for this interface type.
    typedef ProxyPullSupplier_ptr _ptr_type;
    typedef ProxyPullSupplier_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ProxyPullSupplier :
    public virtual CosEventComm::_objref_PullSupplier
  {
  public:
    // IDL operations
    void connect_pull_consumer(::CosEventComm::PullConsumer_ptr pull_consumer);

    // Constructors
    inline _objref_ProxyPullSupplier()  { _PR_setobj(0); }  // nil
    _objref_ProxyPullSupplier(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ProxyPullSupplier();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ProxyPullSupplier(const _objref_ProxyPullSupplier&);
    _objref_ProxyPullSupplier& operator = (const _objref_ProxyPullSupplier&);
    // not implemented

    friend class ProxyPullSupplier;
  };

  class _pof_ProxyPullSupplier : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ProxyPullSupplier() : _OMNI_NS(proxyObjectFactory)(ProxyPullSupplier::_PD_repoId) {}
    virtual ~_pof_ProxyPullSupplier();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ProxyPullSupplier :
    public virtual CosEventComm::_impl_PullSupplier
  {
  public:
    virtual ~_impl_ProxyPullSupplier();

    virtual void connect_pull_consumer(::CosEventComm::PullConsumer_ptr pull_consumer) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProxyPullSupplier;

#ifndef __CosEventChannelAdmin_mProxyPullConsumer__
#define __CosEventChannelAdmin_mProxyPullConsumer__
  class ProxyPullConsumer;
  class _objref_ProxyPullConsumer;
  class _impl_ProxyPullConsumer;
  
  typedef _objref_ProxyPullConsumer* ProxyPullConsumer_ptr;
  typedef ProxyPullConsumer_ptr ProxyPullConsumerRef;

  class ProxyPullConsumer_Helper {
  public:
    typedef ProxyPullConsumer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ProxyPullConsumer, ProxyPullConsumer_Helper> ProxyPullConsumer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ProxyPullConsumer,ProxyPullConsumer_Helper > ProxyPullConsumer_out;

#endif

  // interface ProxyPullConsumer
  class ProxyPullConsumer {
  public:
    // Declarations for this interface type.
    typedef ProxyPullConsumer_ptr _ptr_type;
    typedef ProxyPullConsumer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ProxyPullConsumer :
    public virtual CosEventComm::_objref_PullConsumer
  {
  public:
    // IDL operations
    void connect_pull_supplier(::CosEventComm::PullSupplier_ptr pull_supplier);

    // Constructors
    inline _objref_ProxyPullConsumer()  { _PR_setobj(0); }  // nil
    _objref_ProxyPullConsumer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ProxyPullConsumer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ProxyPullConsumer(const _objref_ProxyPullConsumer&);
    _objref_ProxyPullConsumer& operator = (const _objref_ProxyPullConsumer&);
    // not implemented

    friend class ProxyPullConsumer;
  };

  class _pof_ProxyPullConsumer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ProxyPullConsumer() : _OMNI_NS(proxyObjectFactory)(ProxyPullConsumer::_PD_repoId) {}
    virtual ~_pof_ProxyPullConsumer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ProxyPullConsumer :
    public virtual CosEventComm::_impl_PullConsumer
  {
  public:
    virtual ~_impl_ProxyPullConsumer();

    virtual void connect_pull_supplier(::CosEventComm::PullSupplier_ptr pull_supplier) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProxyPullConsumer;

#ifndef __CosEventChannelAdmin_mProxyPushSupplier__
#define __CosEventChannelAdmin_mProxyPushSupplier__
  class ProxyPushSupplier;
  class _objref_ProxyPushSupplier;
  class _impl_ProxyPushSupplier;
  
  typedef _objref_ProxyPushSupplier* ProxyPushSupplier_ptr;
  typedef ProxyPushSupplier_ptr ProxyPushSupplierRef;

  class ProxyPushSupplier_Helper {
  public:
    typedef ProxyPushSupplier_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ProxyPushSupplier, ProxyPushSupplier_Helper> ProxyPushSupplier_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ProxyPushSupplier,ProxyPushSupplier_Helper > ProxyPushSupplier_out;

#endif

  // interface ProxyPushSupplier
  class ProxyPushSupplier {
  public:
    // Declarations for this interface type.
    typedef ProxyPushSupplier_ptr _ptr_type;
    typedef ProxyPushSupplier_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ProxyPushSupplier :
    public virtual CosEventComm::_objref_PushSupplier
  {
  public:
    // IDL operations
    void connect_push_consumer(::CosEventComm::PushConsumer_ptr push_consumer);

    // Constructors
    inline _objref_ProxyPushSupplier()  { _PR_setobj(0); }  // nil
    _objref_ProxyPushSupplier(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ProxyPushSupplier();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ProxyPushSupplier(const _objref_ProxyPushSupplier&);
    _objref_ProxyPushSupplier& operator = (const _objref_ProxyPushSupplier&);
    // not implemented

    friend class ProxyPushSupplier;
  };

  class _pof_ProxyPushSupplier : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ProxyPushSupplier() : _OMNI_NS(proxyObjectFactory)(ProxyPushSupplier::_PD_repoId) {}
    virtual ~_pof_ProxyPushSupplier();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ProxyPushSupplier :
    public virtual CosEventComm::_impl_PushSupplier
  {
  public:
    virtual ~_impl_ProxyPushSupplier();

    virtual void connect_push_consumer(::CosEventComm::PushConsumer_ptr push_consumer) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProxyPushSupplier;

#ifndef __CosEventChannelAdmin_mConsumerAdmin__
#define __CosEventChannelAdmin_mConsumerAdmin__
  class ConsumerAdmin;
  class _objref_ConsumerAdmin;
  class _impl_ConsumerAdmin;
  
  typedef _objref_ConsumerAdmin* ConsumerAdmin_ptr;
  typedef ConsumerAdmin_ptr ConsumerAdminRef;

  class ConsumerAdmin_Helper {
  public:
    typedef ConsumerAdmin_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ConsumerAdmin, ConsumerAdmin_Helper> ConsumerAdmin_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ConsumerAdmin,ConsumerAdmin_Helper > ConsumerAdmin_out;

#endif

  // interface ConsumerAdmin
  class ConsumerAdmin {
  public:
    // Declarations for this interface type.
    typedef ConsumerAdmin_ptr _ptr_type;
    typedef ConsumerAdmin_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ConsumerAdmin :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    ProxyPushSupplier_ptr obtain_push_supplier();
    ProxyPullSupplier_ptr obtain_pull_supplier();

    // Constructors
    inline _objref_ConsumerAdmin()  { _PR_setobj(0); }  // nil
    _objref_ConsumerAdmin(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ConsumerAdmin();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ConsumerAdmin(const _objref_ConsumerAdmin&);
    _objref_ConsumerAdmin& operator = (const _objref_ConsumerAdmin&);
    // not implemented

    friend class ConsumerAdmin;
  };

  class _pof_ConsumerAdmin : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ConsumerAdmin() : _OMNI_NS(proxyObjectFactory)(ConsumerAdmin::_PD_repoId) {}
    virtual ~_pof_ConsumerAdmin();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ConsumerAdmin :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ConsumerAdmin();

    virtual ProxyPushSupplier_ptr obtain_push_supplier() = 0;
    virtual ProxyPullSupplier_ptr obtain_pull_supplier() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConsumerAdmin;

#ifndef __CosEventChannelAdmin_mSupplierAdmin__
#define __CosEventChannelAdmin_mSupplierAdmin__
  class SupplierAdmin;
  class _objref_SupplierAdmin;
  class _impl_SupplierAdmin;
  
  typedef _objref_SupplierAdmin* SupplierAdmin_ptr;
  typedef SupplierAdmin_ptr SupplierAdminRef;

  class SupplierAdmin_Helper {
  public:
    typedef SupplierAdmin_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_SupplierAdmin, SupplierAdmin_Helper> SupplierAdmin_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_SupplierAdmin,SupplierAdmin_Helper > SupplierAdmin_out;

#endif

  // interface SupplierAdmin
  class SupplierAdmin {
  public:
    // Declarations for this interface type.
    typedef SupplierAdmin_ptr _ptr_type;
    typedef SupplierAdmin_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_SupplierAdmin :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    ProxyPushConsumer_ptr obtain_push_consumer();
    ProxyPullConsumer_ptr obtain_pull_consumer();

    // Constructors
    inline _objref_SupplierAdmin()  { _PR_setobj(0); }  // nil
    _objref_SupplierAdmin(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_SupplierAdmin();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_SupplierAdmin(const _objref_SupplierAdmin&);
    _objref_SupplierAdmin& operator = (const _objref_SupplierAdmin&);
    // not implemented

    friend class SupplierAdmin;
  };

  class _pof_SupplierAdmin : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_SupplierAdmin() : _OMNI_NS(proxyObjectFactory)(SupplierAdmin::_PD_repoId) {}
    virtual ~_pof_SupplierAdmin();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_SupplierAdmin :
    public virtual omniServant
  {
  public:
    virtual ~_impl_SupplierAdmin();

    virtual ProxyPushConsumer_ptr obtain_push_consumer() = 0;
    virtual ProxyPullConsumer_ptr obtain_pull_consumer() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SupplierAdmin;

#ifndef __CosEventChannelAdmin_mEventChannel__
#define __CosEventChannelAdmin_mEventChannel__
  class EventChannel;
  class _objref_EventChannel;
  class _impl_EventChannel;
  
  typedef _objref_EventChannel* EventChannel_ptr;
  typedef EventChannel_ptr EventChannelRef;

  class EventChannel_Helper {
  public:
    typedef EventChannel_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_EventChannel, EventChannel_Helper> EventChannel_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_EventChannel,EventChannel_Helper > EventChannel_out;

#endif

  // interface EventChannel
  class EventChannel {
  public:
    // Declarations for this interface type.
    typedef EventChannel_ptr _ptr_type;
    typedef EventChannel_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_EventChannel :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    ConsumerAdmin_ptr for_consumers();
    SupplierAdmin_ptr for_suppliers();
    void destroy();

    // Constructors
    inline _objref_EventChannel()  { _PR_setobj(0); }  // nil
    _objref_EventChannel(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_EventChannel();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_EventChannel(const _objref_EventChannel&);
    _objref_EventChannel& operator = (const _objref_EventChannel&);
    // not implemented

    friend class EventChannel;
  };

  class _pof_EventChannel : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_EventChannel() : _OMNI_NS(proxyObjectFactory)(EventChannel::_PD_repoId) {}
    virtual ~_pof_EventChannel();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_EventChannel :
    public virtual omniServant
  {
  public:
    virtual ~_impl_EventChannel();

    virtual ConsumerAdmin_ptr for_consumers() = 0;
    virtual SupplierAdmin_ptr for_suppliers() = 0;
    virtual void destroy() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EventChannel;

_CORBA_MODULE_END



_CORBA_MODULE POA_CosEventChannelAdmin
_CORBA_MODULE_BEG

  class ProxyPushConsumer :
    public virtual CosEventChannelAdmin::_impl_ProxyPushConsumer,
    public virtual POA_CosEventComm::PushConsumer
  {
  public:
    virtual ~ProxyPushConsumer();

    inline ::CosEventChannelAdmin::ProxyPushConsumer_ptr _this() {
      return (::CosEventChannelAdmin::ProxyPushConsumer_ptr) _do_this(::CosEventChannelAdmin::ProxyPushConsumer::_PD_repoId);
    }
  };

  class ProxyPullSupplier :
    public virtual CosEventChannelAdmin::_impl_ProxyPullSupplier,
    public virtual POA_CosEventComm::PullSupplier
  {
  public:
    virtual ~ProxyPullSupplier();

    inline ::CosEventChannelAdmin::ProxyPullSupplier_ptr _this() {
      return (::CosEventChannelAdmin::ProxyPullSupplier_ptr) _do_this(::CosEventChannelAdmin::ProxyPullSupplier::_PD_repoId);
    }
  };

  class ProxyPullConsumer :
    public virtual CosEventChannelAdmin::_impl_ProxyPullConsumer,
    public virtual POA_CosEventComm::PullConsumer
  {
  public:
    virtual ~ProxyPullConsumer();

    inline ::CosEventChannelAdmin::ProxyPullConsumer_ptr _this() {
      return (::CosEventChannelAdmin::ProxyPullConsumer_ptr) _do_this(::CosEventChannelAdmin::ProxyPullConsumer::_PD_repoId);
    }
  };

  class ProxyPushSupplier :
    public virtual CosEventChannelAdmin::_impl_ProxyPushSupplier,
    public virtual POA_CosEventComm::PushSupplier
  {
  public:
    virtual ~ProxyPushSupplier();

    inline ::CosEventChannelAdmin::ProxyPushSupplier_ptr _this() {
      return (::CosEventChannelAdmin::ProxyPushSupplier_ptr) _do_this(::CosEventChannelAdmin::ProxyPushSupplier::_PD_repoId);
    }
  };

  class ConsumerAdmin :
    public virtual CosEventChannelAdmin::_impl_ConsumerAdmin,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ConsumerAdmin();

    inline ::CosEventChannelAdmin::ConsumerAdmin_ptr _this() {
      return (::CosEventChannelAdmin::ConsumerAdmin_ptr) _do_this(::CosEventChannelAdmin::ConsumerAdmin::_PD_repoId);
    }
  };

  class SupplierAdmin :
    public virtual CosEventChannelAdmin::_impl_SupplierAdmin,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~SupplierAdmin();

    inline ::CosEventChannelAdmin::SupplierAdmin_ptr _this() {
      return (::CosEventChannelAdmin::SupplierAdmin_ptr) _do_this(::CosEventChannelAdmin::SupplierAdmin::_PD_repoId);
    }
  };

  class EventChannel :
    public virtual CosEventChannelAdmin::_impl_EventChannel,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~EventChannel();

    inline ::CosEventChannelAdmin::EventChannel_ptr _this() {
      return (::CosEventChannelAdmin::EventChannel_ptr) _do_this(::CosEventChannelAdmin::EventChannel::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_CosEventChannelAdmin
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const CosEventChannelAdmin::AlreadyConnected& _s);
void operator<<=(::CORBA::Any& _a, const CosEventChannelAdmin::AlreadyConnected* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosEventChannelAdmin::AlreadyConnected*& _sp);

void operator<<=(::CORBA::Any& _a, const CosEventChannelAdmin::TypeError& _s);
void operator<<=(::CORBA::Any& _a, const CosEventChannelAdmin::TypeError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosEventChannelAdmin::TypeError*& _sp);

void operator<<=(::CORBA::Any& _a, CosEventChannelAdmin::ProxyPushConsumer_ptr _s);
void operator<<=(::CORBA::Any& _a, CosEventChannelAdmin::ProxyPushConsumer_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosEventChannelAdmin::ProxyPushConsumer_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosEventChannelAdmin::ProxyPullSupplier_ptr _s);
void operator<<=(::CORBA::Any& _a, CosEventChannelAdmin::ProxyPullSupplier_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosEventChannelAdmin::ProxyPullSupplier_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosEventChannelAdmin::ProxyPullConsumer_ptr _s);
void operator<<=(::CORBA::Any& _a, CosEventChannelAdmin::ProxyPullConsumer_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosEventChannelAdmin::ProxyPullConsumer_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosEventChannelAdmin::ProxyPushSupplier_ptr _s);
void operator<<=(::CORBA::Any& _a, CosEventChannelAdmin::ProxyPushSupplier_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosEventChannelAdmin::ProxyPushSupplier_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosEventChannelAdmin::ConsumerAdmin_ptr _s);
void operator<<=(::CORBA::Any& _a, CosEventChannelAdmin::ConsumerAdmin_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosEventChannelAdmin::ConsumerAdmin_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosEventChannelAdmin::SupplierAdmin_ptr _s);
void operator<<=(::CORBA::Any& _a, CosEventChannelAdmin::SupplierAdmin_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosEventChannelAdmin::SupplierAdmin_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosEventChannelAdmin::EventChannel_ptr _s);
void operator<<=(::CORBA::Any& _a, CosEventChannelAdmin::EventChannel_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosEventChannelAdmin::EventChannel_ptr& _s);



inline void
CosEventChannelAdmin::ProxyPushConsumer::_marshalObjRef(::CosEventChannelAdmin::ProxyPushConsumer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosEventChannelAdmin::ProxyPullSupplier::_marshalObjRef(::CosEventChannelAdmin::ProxyPullSupplier_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosEventChannelAdmin::ProxyPullConsumer::_marshalObjRef(::CosEventChannelAdmin::ProxyPullConsumer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosEventChannelAdmin::ProxyPushSupplier::_marshalObjRef(::CosEventChannelAdmin::ProxyPushSupplier_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosEventChannelAdmin::ConsumerAdmin::_marshalObjRef(::CosEventChannelAdmin::ConsumerAdmin_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosEventChannelAdmin::SupplierAdmin::_marshalObjRef(::CosEventChannelAdmin::SupplierAdmin_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosEventChannelAdmin::EventChannel::_marshalObjRef(::CosEventChannelAdmin::EventChannel_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}



#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_CosEventChannelAdmin
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_CosEventChannelAdmin
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_CosEventChannelAdmin
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_CosEventChannelAdmin
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosEventChannelAdmin
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosEventChannelAdmin
#endif

#endif  // __CosEventChannelAdmin_hh__

