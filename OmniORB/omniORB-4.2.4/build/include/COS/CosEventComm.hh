// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __CosEventComm_hh__
#define __CosEventComm_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_CosEventComm
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_CosEventComm
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosEventComm
#endif


#include "COS_sysdep.h"



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE CosEventComm

_CORBA_MODULE_BEG

  class Disconnected : public ::CORBA::UserException {
  public:
    
    

    inline Disconnected() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    Disconnected(const Disconnected&);
    
    Disconnected& operator=(const Disconnected&);
    virtual ~Disconnected();
    virtual void _raise() const;
    static Disconnected* _downcast(::CORBA::Exception*);
    static const Disconnected* _downcast(const ::CORBA::Exception*);
    static inline Disconnected* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Disconnected;

#ifndef __CosEventComm_mPushConsumer__
#define __CosEventComm_mPushConsumer__
  class PushConsumer;
  class _objref_PushConsumer;
  class _impl_PushConsumer;
  
  typedef _objref_PushConsumer* PushConsumer_ptr;
  typedef PushConsumer_ptr PushConsumerRef;

  class PushConsumer_Helper {
  public:
    typedef PushConsumer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_PushConsumer, PushConsumer_Helper> PushConsumer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_PushConsumer,PushConsumer_Helper > PushConsumer_out;

#endif

  // interface PushConsumer
  class PushConsumer {
  public:
    // Declarations for this interface type.
    typedef PushConsumer_ptr _ptr_type;
    typedef PushConsumer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_PushConsumer :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    void push(const ::CORBA::Any& data);
    void disconnect_push_consumer();

    // Constructors
    inline _objref_PushConsumer()  { _PR_setobj(0); }  // nil
    _objref_PushConsumer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_PushConsumer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_PushConsumer(const _objref_PushConsumer&);
    _objref_PushConsumer& operator = (const _objref_PushConsumer&);
    // not implemented

    friend class PushConsumer;
  };

  class _pof_PushConsumer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_PushConsumer() : _OMNI_NS(proxyObjectFactory)(PushConsumer::_PD_repoId) {}
    virtual ~_pof_PushConsumer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_PushConsumer :
    public virtual omniServant
  {
  public:
    virtual ~_impl_PushConsumer();

    virtual void push(const ::CORBA::Any& data) = 0;
    virtual void disconnect_push_consumer() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PushConsumer;

#ifndef __CosEventComm_mPushSupplier__
#define __CosEventComm_mPushSupplier__
  class PushSupplier;
  class _objref_PushSupplier;
  class _impl_PushSupplier;
  
  typedef _objref_PushSupplier* PushSupplier_ptr;
  typedef PushSupplier_ptr PushSupplierRef;

  class PushSupplier_Helper {
  public:
    typedef PushSupplier_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_PushSupplier, PushSupplier_Helper> PushSupplier_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_PushSupplier,PushSupplier_Helper > PushSupplier_out;

#endif

  // interface PushSupplier
  class PushSupplier {
  public:
    // Declarations for this interface type.
    typedef PushSupplier_ptr _ptr_type;
    typedef PushSupplier_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_PushSupplier :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    void disconnect_push_supplier();

    // Constructors
    inline _objref_PushSupplier()  { _PR_setobj(0); }  // nil
    _objref_PushSupplier(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_PushSupplier();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_PushSupplier(const _objref_PushSupplier&);
    _objref_PushSupplier& operator = (const _objref_PushSupplier&);
    // not implemented

    friend class PushSupplier;
  };

  class _pof_PushSupplier : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_PushSupplier() : _OMNI_NS(proxyObjectFactory)(PushSupplier::_PD_repoId) {}
    virtual ~_pof_PushSupplier();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_PushSupplier :
    public virtual omniServant
  {
  public:
    virtual ~_impl_PushSupplier();

    virtual void disconnect_push_supplier() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PushSupplier;

#ifndef __CosEventComm_mPullSupplier__
#define __CosEventComm_mPullSupplier__
  class PullSupplier;
  class _objref_PullSupplier;
  class _impl_PullSupplier;
  
  typedef _objref_PullSupplier* PullSupplier_ptr;
  typedef PullSupplier_ptr PullSupplierRef;

  class PullSupplier_Helper {
  public:
    typedef PullSupplier_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_PullSupplier, PullSupplier_Helper> PullSupplier_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_PullSupplier,PullSupplier_Helper > PullSupplier_out;

#endif

  // interface PullSupplier
  class PullSupplier {
  public:
    // Declarations for this interface type.
    typedef PullSupplier_ptr _ptr_type;
    typedef PullSupplier_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_PullSupplier :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    ::CORBA::Any* pull();
    ::CORBA::Any* try_pull(::CORBA::Boolean& has_event);
    void disconnect_pull_supplier();

    // Constructors
    inline _objref_PullSupplier()  { _PR_setobj(0); }  // nil
    _objref_PullSupplier(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_PullSupplier();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_PullSupplier(const _objref_PullSupplier&);
    _objref_PullSupplier& operator = (const _objref_PullSupplier&);
    // not implemented

    friend class PullSupplier;
  };

  class _pof_PullSupplier : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_PullSupplier() : _OMNI_NS(proxyObjectFactory)(PullSupplier::_PD_repoId) {}
    virtual ~_pof_PullSupplier();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_PullSupplier :
    public virtual omniServant
  {
  public:
    virtual ~_impl_PullSupplier();

    virtual ::CORBA::Any* pull() = 0;
    virtual ::CORBA::Any* try_pull(::CORBA::Boolean& has_event) = 0;
    virtual void disconnect_pull_supplier() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PullSupplier;

#ifndef __CosEventComm_mPullConsumer__
#define __CosEventComm_mPullConsumer__
  class PullConsumer;
  class _objref_PullConsumer;
  class _impl_PullConsumer;
  
  typedef _objref_PullConsumer* PullConsumer_ptr;
  typedef PullConsumer_ptr PullConsumerRef;

  class PullConsumer_Helper {
  public:
    typedef PullConsumer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_PullConsumer, PullConsumer_Helper> PullConsumer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_PullConsumer,PullConsumer_Helper > PullConsumer_out;

#endif

  // interface PullConsumer
  class PullConsumer {
  public:
    // Declarations for this interface type.
    typedef PullConsumer_ptr _ptr_type;
    typedef PullConsumer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_PullConsumer :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    void disconnect_pull_consumer();

    // Constructors
    inline _objref_PullConsumer()  { _PR_setobj(0); }  // nil
    _objref_PullConsumer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_PullConsumer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_PullConsumer(const _objref_PullConsumer&);
    _objref_PullConsumer& operator = (const _objref_PullConsumer&);
    // not implemented

    friend class PullConsumer;
  };

  class _pof_PullConsumer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_PullConsumer() : _OMNI_NS(proxyObjectFactory)(PullConsumer::_PD_repoId) {}
    virtual ~_pof_PullConsumer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_PullConsumer :
    public virtual omniServant
  {
  public:
    virtual ~_impl_PullConsumer();

    virtual void disconnect_pull_consumer() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PullConsumer;

_CORBA_MODULE_END



_CORBA_MODULE POA_CosEventComm
_CORBA_MODULE_BEG

  class PushConsumer :
    public virtual CosEventComm::_impl_PushConsumer,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~PushConsumer();

    inline ::CosEventComm::PushConsumer_ptr _this() {
      return (::CosEventComm::PushConsumer_ptr) _do_this(::CosEventComm::PushConsumer::_PD_repoId);
    }
  };

  class PushSupplier :
    public virtual CosEventComm::_impl_PushSupplier,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~PushSupplier();

    inline ::CosEventComm::PushSupplier_ptr _this() {
      return (::CosEventComm::PushSupplier_ptr) _do_this(::CosEventComm::PushSupplier::_PD_repoId);
    }
  };

  class PullSupplier :
    public virtual CosEventComm::_impl_PullSupplier,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~PullSupplier();

    inline ::CosEventComm::PullSupplier_ptr _this() {
      return (::CosEventComm::PullSupplier_ptr) _do_this(::CosEventComm::PullSupplier::_PD_repoId);
    }
  };

  class PullConsumer :
    public virtual CosEventComm::_impl_PullConsumer,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~PullConsumer();

    inline ::CosEventComm::PullConsumer_ptr _this() {
      return (::CosEventComm::PullConsumer_ptr) _do_this(::CosEventComm::PullConsumer::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_CosEventComm
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const CosEventComm::Disconnected& _s);
void operator<<=(::CORBA::Any& _a, const CosEventComm::Disconnected* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CosEventComm::Disconnected*& _sp);

void operator<<=(::CORBA::Any& _a, CosEventComm::PushConsumer_ptr _s);
void operator<<=(::CORBA::Any& _a, CosEventComm::PushConsumer_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosEventComm::PushConsumer_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosEventComm::PushSupplier_ptr _s);
void operator<<=(::CORBA::Any& _a, CosEventComm::PushSupplier_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosEventComm::PushSupplier_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosEventComm::PullSupplier_ptr _s);
void operator<<=(::CORBA::Any& _a, CosEventComm::PullSupplier_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosEventComm::PullSupplier_ptr& _s);

void operator<<=(::CORBA::Any& _a, CosEventComm::PullConsumer_ptr _s);
void operator<<=(::CORBA::Any& _a, CosEventComm::PullConsumer_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CosEventComm::PullConsumer_ptr& _s);



inline void
CosEventComm::PushConsumer::_marshalObjRef(::CosEventComm::PushConsumer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosEventComm::PushSupplier::_marshalObjRef(::CosEventComm::PushSupplier_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosEventComm::PullSupplier::_marshalObjRef(::CosEventComm::PullSupplier_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CosEventComm::PullConsumer::_marshalObjRef(::CosEventComm::PullConsumer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}



#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_CosEventComm
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_CosEventComm
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_CosEventComm
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_CosEventComm
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosEventComm
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_CosEventComm
#endif

#endif  // __CosEventComm_hh__

