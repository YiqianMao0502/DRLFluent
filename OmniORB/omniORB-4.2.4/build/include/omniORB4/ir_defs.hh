// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __ir_defs_hh__
#define __ir_defs_hh__

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ScopedName;

typedef char* ScopedName;
typedef ::CORBA::String_var ScopedName_var;
typedef ::CORBA::String_out ScopedName_out;

enum DefinitionKind { dk_none, dk_all, dk_Attribute, dk_Constant, dk_Exception, dk_Interface, dk_Module, dk_Operation, dk_Typedef, dk_Alias, dk_Struct, dk_Union, dk_Enum, dk_Primitive, dk_String, dk_Sequence, dk_Array, dk_Repository, dk_Wstring, dk_Fixed, dk_Value, dk_ValueBox, dk_ValueMember, dk_Native, dk_AbstractInterface /*, __max_DefinitionKind=0xffffffff */ };
typedef DefinitionKind& DefinitionKind_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DefinitionKind;

#ifndef __CORBA_mIRObject__
#define __CORBA_mIRObject__
class IRObject;
class _objref_IRObject;
class _impl_IRObject;

typedef _objref_IRObject* IRObject_ptr;
typedef IRObject_ptr IRObjectRef;

class IRObject_Helper {
public:
  typedef IRObject_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_IRObject, IRObject_Helper> IRObject_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_IRObject,IRObject_Helper > IRObject_out;

#endif

// interface IRObject
class IRObject {
public:
  // Declarations for this interface type.
  typedef IRObject_ptr _ptr_type;
  typedef IRObject_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_IRObject :
  public virtual ::CORBA::Object,
  public virtual omniObjRef
{
public:
  // IDL operations
  DefinitionKind def_kind();
  void destroy();

  // Constructors
  inline _objref_IRObject()  { _PR_setobj(0); }  // nil
  _objref_IRObject(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_IRObject();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_IRObject(const _objref_IRObject&);
  _objref_IRObject& operator = (const _objref_IRObject&);
  // not implemented

  friend class IRObject;
};

class _pof_IRObject : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_IRObject() : _OMNI_NS(proxyObjectFactory)(IRObject::_PD_repoId) {}
  virtual ~_pof_IRObject();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_IRObject :
  public virtual omniServant
{
public:
  virtual ~_impl_IRObject();

  virtual DefinitionKind def_kind() = 0;
  virtual void destroy() = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_IRObject;

#ifndef __CORBA_mContained__
#define __CORBA_mContained__
class Contained;
class _objref_Contained;
class _impl_Contained;

typedef _objref_Contained* Contained_ptr;
typedef Contained_ptr ContainedRef;

class Contained_Helper {
public:
  typedef Contained_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_Contained, Contained_Helper> Contained_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_Contained,Contained_Helper > Contained_out;

#endif

#ifndef __CORBA_mRepository__
#define __CORBA_mRepository__
class Repository;
class _objref_Repository;
class _impl_Repository;

typedef _objref_Repository* Repository_ptr;
typedef Repository_ptr RepositoryRef;

class Repository_Helper {
public:
  typedef Repository_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_Repository, Repository_Helper> Repository_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_Repository,Repository_Helper > Repository_out;

#endif

#ifndef __CORBA_mContainer__
#define __CORBA_mContainer__
class Container;
class _objref_Container;
class _impl_Container;

typedef _objref_Container* Container_ptr;
typedef Container_ptr ContainerRef;

class Container_Helper {
public:
  typedef Container_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_Container, Container_Helper> Container_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_Container,Container_Helper > Container_out;

#endif

#ifndef __CORBA_mContained__
#define __CORBA_mContained__
class Contained;
class _objref_Contained;
class _impl_Contained;

typedef _objref_Contained* Contained_ptr;
typedef Contained_ptr ContainedRef;

class Contained_Helper {
public:
  typedef Contained_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_Contained, Contained_Helper> Contained_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_Contained,Contained_Helper > Contained_out;

#endif

// interface Contained
class Contained {
public:
  // Declarations for this interface type.
  typedef Contained_ptr _ptr_type;
  typedef Contained_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  struct Description {
    typedef _CORBA_ConstrType_Variable_Var<Description> _var_type;

    
    DefinitionKind kind;

    ::CORBA::Any value;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Description::_var_type Description_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Description,Description_var > Description_out;

  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_Description;


};

class _objref_Contained :
  public virtual _objref_IRObject
{
public:
  // IDL operations
  char* id();
  void id(const char* _v);
  char* name();
  void name(const char* _v);
  char* version();
  void version(const char* _v);
  Container_ptr defined_in();
  char* absolute_name();
  Repository_ptr containing_repository();
  Contained::Description* describe();
  void move(::CORBA::Container_ptr new_container, const char* new_name, const char* new_version);

  // Constructors
  inline _objref_Contained()  { _PR_setobj(0); }  // nil
  _objref_Contained(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_Contained();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_Contained(const _objref_Contained&);
  _objref_Contained& operator = (const _objref_Contained&);
  // not implemented

  friend class Contained;
};

class _pof_Contained : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_Contained() : _OMNI_NS(proxyObjectFactory)(Contained::_PD_repoId) {}
  virtual ~_pof_Contained();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_Contained :
  public virtual _impl_IRObject
{
public:
  virtual ~_impl_Contained();

  virtual char* id() = 0;
  virtual void id(const char* _v) = 0;
  virtual char* name() = 0;
  virtual void name(const char* _v) = 0;
  virtual char* version() = 0;
  virtual void version(const char* _v) = 0;
  virtual Container_ptr defined_in() = 0;
  virtual char* absolute_name() = 0;
  virtual Repository_ptr containing_repository() = 0;
  virtual Contained::Description* describe() = 0;
  virtual void move(::CORBA::Container_ptr new_container, const char* new_name, const char* new_version) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Contained;

#ifndef __CORBA_mModuleDef__
#define __CORBA_mModuleDef__
class ModuleDef;
class _objref_ModuleDef;
class _impl_ModuleDef;

typedef _objref_ModuleDef* ModuleDef_ptr;
typedef ModuleDef_ptr ModuleDefRef;

class ModuleDef_Helper {
public:
  typedef ModuleDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ModuleDef, ModuleDef_Helper> ModuleDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ModuleDef,ModuleDef_Helper > ModuleDef_out;

#endif

#ifndef __CORBA_mConstantDef__
#define __CORBA_mConstantDef__
class ConstantDef;
class _objref_ConstantDef;
class _impl_ConstantDef;

typedef _objref_ConstantDef* ConstantDef_ptr;
typedef ConstantDef_ptr ConstantDefRef;

class ConstantDef_Helper {
public:
  typedef ConstantDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ConstantDef, ConstantDef_Helper> ConstantDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ConstantDef,ConstantDef_Helper > ConstantDef_out;

#endif

#ifndef __CORBA_mIDLType__
#define __CORBA_mIDLType__
class IDLType;
class _objref_IDLType;
class _impl_IDLType;

typedef _objref_IDLType* IDLType_ptr;
typedef IDLType_ptr IDLTypeRef;

class IDLType_Helper {
public:
  typedef IDLType_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_IDLType, IDLType_Helper> IDLType_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_IDLType,IDLType_Helper > IDLType_out;

#endif

#ifndef __CORBA_mStructDef__
#define __CORBA_mStructDef__
class StructDef;
class _objref_StructDef;
class _impl_StructDef;

typedef _objref_StructDef* StructDef_ptr;
typedef StructDef_ptr StructDefRef;

class StructDef_Helper {
public:
  typedef StructDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_StructDef, StructDef_Helper> StructDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_StructDef,StructDef_Helper > StructDef_out;

#endif

#ifndef __CORBA_mUnionDef__
#define __CORBA_mUnionDef__
class UnionDef;
class _objref_UnionDef;
class _impl_UnionDef;

typedef _objref_UnionDef* UnionDef_ptr;
typedef UnionDef_ptr UnionDefRef;

class UnionDef_Helper {
public:
  typedef UnionDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_UnionDef, UnionDef_Helper> UnionDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_UnionDef,UnionDef_Helper > UnionDef_out;

#endif

#ifndef __CORBA_mEnumDef__
#define __CORBA_mEnumDef__
class EnumDef;
class _objref_EnumDef;
class _impl_EnumDef;

typedef _objref_EnumDef* EnumDef_ptr;
typedef EnumDef_ptr EnumDefRef;

class EnumDef_Helper {
public:
  typedef EnumDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_EnumDef, EnumDef_Helper> EnumDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_EnumDef,EnumDef_Helper > EnumDef_out;

#endif

#ifndef __CORBA_mAliasDef__
#define __CORBA_mAliasDef__
class AliasDef;
class _objref_AliasDef;
class _impl_AliasDef;

typedef _objref_AliasDef* AliasDef_ptr;
typedef AliasDef_ptr AliasDefRef;

class AliasDef_Helper {
public:
  typedef AliasDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_AliasDef, AliasDef_Helper> AliasDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_AliasDef,AliasDef_Helper > AliasDef_out;

#endif

#ifndef __CORBA_mInterfaceDef__
#define __CORBA_mInterfaceDef__
class InterfaceDef;
class _objref_InterfaceDef;
class _impl_InterfaceDef;

typedef _objref_InterfaceDef* InterfaceDef_ptr;
typedef InterfaceDef_ptr InterfaceDefRef;

class InterfaceDef_Helper {
public:
  typedef InterfaceDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_InterfaceDef, InterfaceDef_Helper> InterfaceDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_InterfaceDef,InterfaceDef_Helper > InterfaceDef_out;

#endif

#ifndef __CORBA_mValueDef__
#define __CORBA_mValueDef__
class ValueDef;
class _objref_ValueDef;
class _impl_ValueDef;

typedef _objref_ValueDef* ValueDef_ptr;
typedef ValueDef_ptr ValueDefRef;

class ValueDef_Helper {
public:
  typedef ValueDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ValueDef, ValueDef_Helper> ValueDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ValueDef,ValueDef_Helper > ValueDef_out;

#endif

#ifndef __CORBA_mValueBoxDef__
#define __CORBA_mValueBoxDef__
class ValueBoxDef;
class _objref_ValueBoxDef;
class _impl_ValueBoxDef;

typedef _objref_ValueBoxDef* ValueBoxDef_ptr;
typedef ValueBoxDef_ptr ValueBoxDefRef;

class ValueBoxDef_Helper {
public:
  typedef ValueBoxDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ValueBoxDef, ValueBoxDef_Helper> ValueBoxDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ValueBoxDef,ValueBoxDef_Helper > ValueBoxDef_out;

#endif

#ifndef __CORBA_mExceptionDef__
#define __CORBA_mExceptionDef__
class ExceptionDef;
class _objref_ExceptionDef;
class _impl_ExceptionDef;

typedef _objref_ExceptionDef* ExceptionDef_ptr;
typedef ExceptionDef_ptr ExceptionDefRef;

class ExceptionDef_Helper {
public:
  typedef ExceptionDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ExceptionDef, ExceptionDef_Helper> ExceptionDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ExceptionDef,ExceptionDef_Helper > ExceptionDef_out;

#endif

#ifndef __CORBA_mNativeDef__
#define __CORBA_mNativeDef__
class NativeDef;
class _objref_NativeDef;
class _impl_NativeDef;

typedef _objref_NativeDef* NativeDef_ptr;
typedef NativeDef_ptr NativeDefRef;

class NativeDef_Helper {
public:
  typedef NativeDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_NativeDef, NativeDef_Helper> NativeDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_NativeDef,NativeDef_Helper > NativeDef_out;

#endif

#ifndef __CORBA_mAbstractInterfaceDef__
#define __CORBA_mAbstractInterfaceDef__
class AbstractInterfaceDef;
class _objref_AbstractInterfaceDef;
class _impl_AbstractInterfaceDef;

typedef _objref_AbstractInterfaceDef* AbstractInterfaceDef_ptr;
typedef AbstractInterfaceDef_ptr AbstractInterfaceDefRef;

class AbstractInterfaceDef_Helper {
public:
  typedef AbstractInterfaceDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper> AbstractInterfaceDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_AbstractInterfaceDef,AbstractInterfaceDef_Helper > AbstractInterfaceDef_out;

#endif

#ifndef __CORBA_mWstringDef__
#define __CORBA_mWstringDef__
class WstringDef;
class _objref_WstringDef;
class _impl_WstringDef;

typedef _objref_WstringDef* WstringDef_ptr;
typedef WstringDef_ptr WstringDefRef;

class WstringDef_Helper {
public:
  typedef WstringDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_WstringDef, WstringDef_Helper> WstringDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_WstringDef,WstringDef_Helper > WstringDef_out;

#endif

#ifndef __CORBA_mFixedDef__
#define __CORBA_mFixedDef__
class FixedDef;
class _objref_FixedDef;
class _impl_FixedDef;

typedef _objref_FixedDef* FixedDef_ptr;
typedef FixedDef_ptr FixedDefRef;

class FixedDef_Helper {
public:
  typedef FixedDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_FixedDef, FixedDef_Helper> FixedDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_FixedDef,FixedDef_Helper > FixedDef_out;

#endif

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InterfaceDefSeq;

class InterfaceDefSeq_var;

class InterfaceDefSeq : public _CORBA_Unbounded_Sequence_ObjRef< _objref_InterfaceDef, _CORBA_ObjRef_Element< _objref_InterfaceDef, InterfaceDef_Helper> , InterfaceDef_Helper >  {
public:
  typedef InterfaceDefSeq_var _var_type;
  inline InterfaceDefSeq() {}
  inline InterfaceDefSeq(const InterfaceDefSeq& _s)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_InterfaceDef, _CORBA_ObjRef_Element< _objref_InterfaceDef, InterfaceDef_Helper> , InterfaceDef_Helper > (_s) {}

  inline InterfaceDefSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_InterfaceDef, _CORBA_ObjRef_Element< _objref_InterfaceDef, InterfaceDef_Helper> , InterfaceDef_Helper > (_max) {}
  inline InterfaceDefSeq(_CORBA_ULong _max, _CORBA_ULong _len, InterfaceDef_ptr* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_InterfaceDef, _CORBA_ObjRef_Element< _objref_InterfaceDef, InterfaceDef_Helper> , InterfaceDef_Helper > (_max, _len, _val, _rel) {}



  inline InterfaceDefSeq& operator = (const InterfaceDefSeq& _s) {
    _CORBA_Unbounded_Sequence_ObjRef< _objref_InterfaceDef, _CORBA_ObjRef_Element< _objref_InterfaceDef, InterfaceDef_Helper> , InterfaceDef_Helper > ::operator=(_s);
    return *this;
  }
};

class InterfaceDefSeq_out;

class InterfaceDefSeq_var {
public:
  inline InterfaceDefSeq_var() : _pd_seq(0) {}
  inline InterfaceDefSeq_var(InterfaceDefSeq* _s) : _pd_seq(_s) {}
  inline InterfaceDefSeq_var(const InterfaceDefSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new InterfaceDefSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~InterfaceDefSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline InterfaceDefSeq_var& operator = (InterfaceDefSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline InterfaceDefSeq_var& operator = (const InterfaceDefSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new InterfaceDefSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline _CORBA_ObjRef_Element< _objref_InterfaceDef, InterfaceDef_Helper>  operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline InterfaceDefSeq* operator -> () { return _pd_seq; }
  inline const InterfaceDefSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator InterfaceDefSeq& () const { return *_pd_seq; }
#else
  inline operator const InterfaceDefSeq& () const { return *_pd_seq; }
  inline operator InterfaceDefSeq& () { return *_pd_seq; }
#endif
    
  inline const InterfaceDefSeq& in() const { return *_pd_seq; }
  inline InterfaceDefSeq&       inout()    { return *_pd_seq; }
  inline InterfaceDefSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline InterfaceDefSeq* _retn() { InterfaceDefSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class InterfaceDefSeq_out;
  
private:
  InterfaceDefSeq* _pd_seq;
};

class InterfaceDefSeq_out {
public:
  inline InterfaceDefSeq_out(InterfaceDefSeq*& _s) : _data(_s) { _data = 0; }
  inline InterfaceDefSeq_out(InterfaceDefSeq_var& _s)
    : _data(_s._pd_seq) { _s = (InterfaceDefSeq*) 0; }
  inline InterfaceDefSeq_out(const InterfaceDefSeq_out& _s) : _data(_s._data) {}
  inline InterfaceDefSeq_out& operator = (const InterfaceDefSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline InterfaceDefSeq_out& operator = (InterfaceDefSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator InterfaceDefSeq*&()  { return _data; }
  inline InterfaceDefSeq*& ptr()       { return _data; }
  inline InterfaceDefSeq* operator->() { return _data; }

  inline _CORBA_ObjRef_Element< _objref_InterfaceDef, InterfaceDef_Helper>  operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  InterfaceDefSeq*& _data;

private:
  InterfaceDefSeq_out();
  InterfaceDefSeq_out& operator=(const InterfaceDefSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ValueDefSeq;

class ValueDefSeq_var;

class ValueDefSeq : public _CORBA_Unbounded_Sequence_ObjRef< _objref_ValueDef, _CORBA_ObjRef_Element< _objref_ValueDef, ValueDef_Helper> , ValueDef_Helper >  {
public:
  typedef ValueDefSeq_var _var_type;
  inline ValueDefSeq() {}
  inline ValueDefSeq(const ValueDefSeq& _s)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_ValueDef, _CORBA_ObjRef_Element< _objref_ValueDef, ValueDef_Helper> , ValueDef_Helper > (_s) {}

  inline ValueDefSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_ValueDef, _CORBA_ObjRef_Element< _objref_ValueDef, ValueDef_Helper> , ValueDef_Helper > (_max) {}
  inline ValueDefSeq(_CORBA_ULong _max, _CORBA_ULong _len, ValueDef_ptr* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_ValueDef, _CORBA_ObjRef_Element< _objref_ValueDef, ValueDef_Helper> , ValueDef_Helper > (_max, _len, _val, _rel) {}



  inline ValueDefSeq& operator = (const ValueDefSeq& _s) {
    _CORBA_Unbounded_Sequence_ObjRef< _objref_ValueDef, _CORBA_ObjRef_Element< _objref_ValueDef, ValueDef_Helper> , ValueDef_Helper > ::operator=(_s);
    return *this;
  }
};

class ValueDefSeq_out;

class ValueDefSeq_var {
public:
  inline ValueDefSeq_var() : _pd_seq(0) {}
  inline ValueDefSeq_var(ValueDefSeq* _s) : _pd_seq(_s) {}
  inline ValueDefSeq_var(const ValueDefSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new ValueDefSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ValueDefSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline ValueDefSeq_var& operator = (ValueDefSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline ValueDefSeq_var& operator = (const ValueDefSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new ValueDefSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline _CORBA_ObjRef_Element< _objref_ValueDef, ValueDef_Helper>  operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline ValueDefSeq* operator -> () { return _pd_seq; }
  inline const ValueDefSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator ValueDefSeq& () const { return *_pd_seq; }
#else
  inline operator const ValueDefSeq& () const { return *_pd_seq; }
  inline operator ValueDefSeq& () { return *_pd_seq; }
#endif
    
  inline const ValueDefSeq& in() const { return *_pd_seq; }
  inline ValueDefSeq&       inout()    { return *_pd_seq; }
  inline ValueDefSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline ValueDefSeq* _retn() { ValueDefSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class ValueDefSeq_out;
  
private:
  ValueDefSeq* _pd_seq;
};

class ValueDefSeq_out {
public:
  inline ValueDefSeq_out(ValueDefSeq*& _s) : _data(_s) { _data = 0; }
  inline ValueDefSeq_out(ValueDefSeq_var& _s)
    : _data(_s._pd_seq) { _s = (ValueDefSeq*) 0; }
  inline ValueDefSeq_out(const ValueDefSeq_out& _s) : _data(_s._data) {}
  inline ValueDefSeq_out& operator = (const ValueDefSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline ValueDefSeq_out& operator = (ValueDefSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator ValueDefSeq*&()  { return _data; }
  inline ValueDefSeq*& ptr()       { return _data; }
  inline ValueDefSeq* operator->() { return _data; }

  inline _CORBA_ObjRef_Element< _objref_ValueDef, ValueDef_Helper>  operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  ValueDefSeq*& _data;

private:
  ValueDefSeq_out();
  ValueDefSeq_out& operator=(const ValueDefSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AbstractInterfaceDefSeq;

class AbstractInterfaceDefSeq_var;

class AbstractInterfaceDefSeq : public _CORBA_Unbounded_Sequence_ObjRef< _objref_AbstractInterfaceDef, _CORBA_ObjRef_Element< _objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper> , AbstractInterfaceDef_Helper >  {
public:
  typedef AbstractInterfaceDefSeq_var _var_type;
  inline AbstractInterfaceDefSeq() {}
  inline AbstractInterfaceDefSeq(const AbstractInterfaceDefSeq& _s)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_AbstractInterfaceDef, _CORBA_ObjRef_Element< _objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper> , AbstractInterfaceDef_Helper > (_s) {}

  inline AbstractInterfaceDefSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_AbstractInterfaceDef, _CORBA_ObjRef_Element< _objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper> , AbstractInterfaceDef_Helper > (_max) {}
  inline AbstractInterfaceDefSeq(_CORBA_ULong _max, _CORBA_ULong _len, AbstractInterfaceDef_ptr* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_AbstractInterfaceDef, _CORBA_ObjRef_Element< _objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper> , AbstractInterfaceDef_Helper > (_max, _len, _val, _rel) {}



  inline AbstractInterfaceDefSeq& operator = (const AbstractInterfaceDefSeq& _s) {
    _CORBA_Unbounded_Sequence_ObjRef< _objref_AbstractInterfaceDef, _CORBA_ObjRef_Element< _objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper> , AbstractInterfaceDef_Helper > ::operator=(_s);
    return *this;
  }
};

class AbstractInterfaceDefSeq_out;

class AbstractInterfaceDefSeq_var {
public:
  inline AbstractInterfaceDefSeq_var() : _pd_seq(0) {}
  inline AbstractInterfaceDefSeq_var(AbstractInterfaceDefSeq* _s) : _pd_seq(_s) {}
  inline AbstractInterfaceDefSeq_var(const AbstractInterfaceDefSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new AbstractInterfaceDefSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~AbstractInterfaceDefSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline AbstractInterfaceDefSeq_var& operator = (AbstractInterfaceDefSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline AbstractInterfaceDefSeq_var& operator = (const AbstractInterfaceDefSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new AbstractInterfaceDefSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline _CORBA_ObjRef_Element< _objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper>  operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline AbstractInterfaceDefSeq* operator -> () { return _pd_seq; }
  inline const AbstractInterfaceDefSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator AbstractInterfaceDefSeq& () const { return *_pd_seq; }
#else
  inline operator const AbstractInterfaceDefSeq& () const { return *_pd_seq; }
  inline operator AbstractInterfaceDefSeq& () { return *_pd_seq; }
#endif
    
  inline const AbstractInterfaceDefSeq& in() const { return *_pd_seq; }
  inline AbstractInterfaceDefSeq&       inout()    { return *_pd_seq; }
  inline AbstractInterfaceDefSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline AbstractInterfaceDefSeq* _retn() { AbstractInterfaceDefSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class AbstractInterfaceDefSeq_out;
  
private:
  AbstractInterfaceDefSeq* _pd_seq;
};

class AbstractInterfaceDefSeq_out {
public:
  inline AbstractInterfaceDefSeq_out(AbstractInterfaceDefSeq*& _s) : _data(_s) { _data = 0; }
  inline AbstractInterfaceDefSeq_out(AbstractInterfaceDefSeq_var& _s)
    : _data(_s._pd_seq) { _s = (AbstractInterfaceDefSeq*) 0; }
  inline AbstractInterfaceDefSeq_out(const AbstractInterfaceDefSeq_out& _s) : _data(_s._data) {}
  inline AbstractInterfaceDefSeq_out& operator = (const AbstractInterfaceDefSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline AbstractInterfaceDefSeq_out& operator = (AbstractInterfaceDefSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator AbstractInterfaceDefSeq*&()  { return _data; }
  inline AbstractInterfaceDefSeq*& ptr()       { return _data; }
  inline AbstractInterfaceDefSeq* operator->() { return _data; }

  inline _CORBA_ObjRef_Element< _objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper>  operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  AbstractInterfaceDefSeq*& _data;

private:
  AbstractInterfaceDefSeq_out();
  AbstractInterfaceDefSeq_out& operator=(const AbstractInterfaceDefSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ContainedSeq;

class ContainedSeq_var;

class ContainedSeq : public _CORBA_Unbounded_Sequence_ObjRef< _objref_Contained, _CORBA_ObjRef_Element< _objref_Contained, Contained_Helper> , Contained_Helper >  {
public:
  typedef ContainedSeq_var _var_type;
  inline ContainedSeq() {}
  inline ContainedSeq(const ContainedSeq& _s)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_Contained, _CORBA_ObjRef_Element< _objref_Contained, Contained_Helper> , Contained_Helper > (_s) {}

  inline ContainedSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_Contained, _CORBA_ObjRef_Element< _objref_Contained, Contained_Helper> , Contained_Helper > (_max) {}
  inline ContainedSeq(_CORBA_ULong _max, _CORBA_ULong _len, Contained_ptr* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_Contained, _CORBA_ObjRef_Element< _objref_Contained, Contained_Helper> , Contained_Helper > (_max, _len, _val, _rel) {}



  inline ContainedSeq& operator = (const ContainedSeq& _s) {
    _CORBA_Unbounded_Sequence_ObjRef< _objref_Contained, _CORBA_ObjRef_Element< _objref_Contained, Contained_Helper> , Contained_Helper > ::operator=(_s);
    return *this;
  }
};

class ContainedSeq_out;

class ContainedSeq_var {
public:
  inline ContainedSeq_var() : _pd_seq(0) {}
  inline ContainedSeq_var(ContainedSeq* _s) : _pd_seq(_s) {}
  inline ContainedSeq_var(const ContainedSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new ContainedSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ContainedSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline ContainedSeq_var& operator = (ContainedSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline ContainedSeq_var& operator = (const ContainedSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new ContainedSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline _CORBA_ObjRef_Element< _objref_Contained, Contained_Helper>  operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline ContainedSeq* operator -> () { return _pd_seq; }
  inline const ContainedSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator ContainedSeq& () const { return *_pd_seq; }
#else
  inline operator const ContainedSeq& () const { return *_pd_seq; }
  inline operator ContainedSeq& () { return *_pd_seq; }
#endif
    
  inline const ContainedSeq& in() const { return *_pd_seq; }
  inline ContainedSeq&       inout()    { return *_pd_seq; }
  inline ContainedSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline ContainedSeq* _retn() { ContainedSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class ContainedSeq_out;
  
private:
  ContainedSeq* _pd_seq;
};

class ContainedSeq_out {
public:
  inline ContainedSeq_out(ContainedSeq*& _s) : _data(_s) { _data = 0; }
  inline ContainedSeq_out(ContainedSeq_var& _s)
    : _data(_s._pd_seq) { _s = (ContainedSeq*) 0; }
  inline ContainedSeq_out(const ContainedSeq_out& _s) : _data(_s._data) {}
  inline ContainedSeq_out& operator = (const ContainedSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline ContainedSeq_out& operator = (ContainedSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator ContainedSeq*&()  { return _data; }
  inline ContainedSeq*& ptr()       { return _data; }
  inline ContainedSeq* operator->() { return _data; }

  inline _CORBA_ObjRef_Element< _objref_Contained, Contained_Helper>  operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  ContainedSeq*& _data;

private:
  ContainedSeq_out();
  ContainedSeq_out& operator=(const ContainedSeq_var&);
};

struct Initializer {
  typedef _CORBA_ConstrType_Variable_Var<Initializer> _var_type;

  
  StructMemberSeq members;

  ::CORBA::String_member name;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef Initializer::_var_type Initializer_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< Initializer,Initializer_var > Initializer_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Initializer;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InitializerSeq;

class InitializerSeq_var;

class InitializerSeq : public _CORBA_Unbounded_Sequence< Initializer >  {
public:
  typedef InitializerSeq_var _var_type;
  inline InitializerSeq() {}
  inline InitializerSeq(const InitializerSeq& _s)
    : _CORBA_Unbounded_Sequence< Initializer > (_s) {}

  inline InitializerSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< Initializer > (_max) {}
  inline InitializerSeq(_CORBA_ULong _max, _CORBA_ULong _len, Initializer* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< Initializer > (_max, _len, _val, _rel) {}



  inline InitializerSeq& operator = (const InitializerSeq& _s) {
    _CORBA_Unbounded_Sequence< Initializer > ::operator=(_s);
    return *this;
  }
};

class InitializerSeq_out;

class InitializerSeq_var {
public:
  inline InitializerSeq_var() : _pd_seq(0) {}
  inline InitializerSeq_var(InitializerSeq* _s) : _pd_seq(_s) {}
  inline InitializerSeq_var(const InitializerSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new InitializerSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~InitializerSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline InitializerSeq_var& operator = (InitializerSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline InitializerSeq_var& operator = (const InitializerSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new InitializerSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline Initializer& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline InitializerSeq* operator -> () { return _pd_seq; }
  inline const InitializerSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator InitializerSeq& () const { return *_pd_seq; }
#else
  inline operator const InitializerSeq& () const { return *_pd_seq; }
  inline operator InitializerSeq& () { return *_pd_seq; }
#endif
    
  inline const InitializerSeq& in() const { return *_pd_seq; }
  inline InitializerSeq&       inout()    { return *_pd_seq; }
  inline InitializerSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline InitializerSeq* _retn() { InitializerSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class InitializerSeq_out;
  
private:
  InitializerSeq* _pd_seq;
};

class InitializerSeq_out {
public:
  inline InitializerSeq_out(InitializerSeq*& _s) : _data(_s) { _data = 0; }
  inline InitializerSeq_out(InitializerSeq_var& _s)
    : _data(_s._pd_seq) { _s = (InitializerSeq*) 0; }
  inline InitializerSeq_out(const InitializerSeq_out& _s) : _data(_s._data) {}
  inline InitializerSeq_out& operator = (const InitializerSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline InitializerSeq_out& operator = (InitializerSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator InitializerSeq*&()  { return _data; }
  inline InitializerSeq*& ptr()       { return _data; }
  inline InitializerSeq* operator->() { return _data; }

  inline Initializer& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  InitializerSeq*& _data;

private:
  InitializerSeq_out();
  InitializerSeq_out& operator=(const InitializerSeq_var&);
};

#ifndef __CORBA_mContainer__
#define __CORBA_mContainer__
class Container;
class _objref_Container;
class _impl_Container;

typedef _objref_Container* Container_ptr;
typedef Container_ptr ContainerRef;

class Container_Helper {
public:
  typedef Container_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_Container, Container_Helper> Container_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_Container,Container_Helper > Container_out;

#endif

// interface Container
class Container {
public:
  // Declarations for this interface type.
  typedef Container_ptr _ptr_type;
  typedef Container_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  struct Description {
    typedef _CORBA_ConstrType_Variable_Var<Description> _var_type;

    
    _CORBA_ObjRef_Member< _objref_Contained, Contained_Helper>  contained_object;

    DefinitionKind kind;

    ::CORBA::Any value;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Description::_var_type Description_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Description,Description_var > Description_out;

  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_Description;

  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DescriptionSeq;

  class DescriptionSeq_var;

  class DescriptionSeq : public _CORBA_Unbounded_Sequence< Description >  {
  public:
    typedef DescriptionSeq_var _var_type;
    inline DescriptionSeq() {}
    inline DescriptionSeq(const DescriptionSeq& _s)
      : _CORBA_Unbounded_Sequence< Description > (_s) {}

    inline DescriptionSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Description > (_max) {}
    inline DescriptionSeq(_CORBA_ULong _max, _CORBA_ULong _len, Description* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Description > (_max, _len, _val, _rel) {}

  

    inline DescriptionSeq& operator = (const DescriptionSeq& _s) {
      _CORBA_Unbounded_Sequence< Description > ::operator=(_s);
      return *this;
    }
  };

  class DescriptionSeq_out;

  class DescriptionSeq_var {
  public:
    inline DescriptionSeq_var() : _pd_seq(0) {}
    inline DescriptionSeq_var(DescriptionSeq* _s) : _pd_seq(_s) {}
    inline DescriptionSeq_var(const DescriptionSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new DescriptionSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~DescriptionSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline DescriptionSeq_var& operator = (DescriptionSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DescriptionSeq_var& operator = (const DescriptionSeq_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new DescriptionSeq;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline Description& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DescriptionSeq* operator -> () { return _pd_seq; }
    inline const DescriptionSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DescriptionSeq& () const { return *_pd_seq; }
#else
    inline operator const DescriptionSeq& () const { return *_pd_seq; }
    inline operator DescriptionSeq& () { return *_pd_seq; }
#endif
      
    inline const DescriptionSeq& in() const { return *_pd_seq; }
    inline DescriptionSeq&       inout()    { return *_pd_seq; }
    inline DescriptionSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DescriptionSeq* _retn() { DescriptionSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DescriptionSeq_out;
    
  private:
    DescriptionSeq* _pd_seq;
  };

  class DescriptionSeq_out {
  public:
    inline DescriptionSeq_out(DescriptionSeq*& _s) : _data(_s) { _data = 0; }
    inline DescriptionSeq_out(DescriptionSeq_var& _s)
      : _data(_s._pd_seq) { _s = (DescriptionSeq*) 0; }
    inline DescriptionSeq_out(const DescriptionSeq_out& _s) : _data(_s._data) {}
    inline DescriptionSeq_out& operator = (const DescriptionSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DescriptionSeq_out& operator = (DescriptionSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator DescriptionSeq*&()  { return _data; }
    inline DescriptionSeq*& ptr()       { return _data; }
    inline DescriptionSeq* operator->() { return _data; }

    inline Description& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DescriptionSeq*& _data;

  private:
    DescriptionSeq_out();
    DescriptionSeq_out& operator=(const DescriptionSeq_var&);
  };


};

class _objref_Container :
  public virtual _objref_IRObject
{
public:
  // IDL operations
  Contained_ptr lookup(const char* search_name);
  ContainedSeq* contents(::CORBA::DefinitionKind limit_type, ::CORBA::Boolean exclude_inherited);
  ContainedSeq* lookup_name(const char* search_name, ::CORBA::Long levels_to_search, ::CORBA::DefinitionKind limit_type, ::CORBA::Boolean exclude_inherited);
  Container::DescriptionSeq* describe_contents(::CORBA::DefinitionKind limit_type, ::CORBA::Boolean exclude_inherited, ::CORBA::Long max_returned_objs);
  ModuleDef_ptr create_module(const char* id, const char* name, const char* version);
  ConstantDef_ptr create_constant(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr type, const ::CORBA::Any& value);
  StructDef_ptr create_struct(const char* id, const char* name, const char* version, const ::CORBA::StructMemberSeq& members);
  UnionDef_ptr create_union(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr discriminator_type, const ::CORBA::UnionMemberSeq& members);
  EnumDef_ptr create_enum(const char* id, const char* name, const char* version, const ::CORBA::EnumMemberSeq& members);
  AliasDef_ptr create_alias(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr original_type);
  InterfaceDef_ptr create_interface(const char* id, const char* name, const char* version, const ::CORBA::InterfaceDefSeq& base_interfaces);
  ValueDef_ptr create_value(const char* id, const char* name, const char* version, ::CORBA::Boolean is_custom, ::CORBA::Boolean is_abstract, ::CORBA::ValueDef_ptr base_value, ::CORBA::Boolean is_truncatable, const ::CORBA::ValueDefSeq& abstract_base_values, const ::CORBA::InterfaceDefSeq& supported_interfaces, const ::CORBA::InitializerSeq& initializers);
  ValueBoxDef_ptr create_value_box(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr original_type_def);
  ExceptionDef_ptr create_exception(const char* id, const char* name, const char* version, const ::CORBA::StructMemberSeq& members);
  NativeDef_ptr create_native(const char* id, const char* name, const char* version);
  AbstractInterfaceDef_ptr create_abstract_interface(const char* id, const char* name, const char* version, const ::CORBA::AbstractInterfaceDefSeq& base_interfaces);

  // Constructors
  inline _objref_Container()  { _PR_setobj(0); }  // nil
  _objref_Container(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_Container();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_Container(const _objref_Container&);
  _objref_Container& operator = (const _objref_Container&);
  // not implemented

  friend class Container;
};

class _pof_Container : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_Container() : _OMNI_NS(proxyObjectFactory)(Container::_PD_repoId) {}
  virtual ~_pof_Container();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_Container :
  public virtual _impl_IRObject
{
public:
  virtual ~_impl_Container();

  virtual Contained_ptr lookup(const char* search_name) = 0;
  virtual ContainedSeq* contents(::CORBA::DefinitionKind limit_type, ::CORBA::Boolean exclude_inherited) = 0;
  virtual ContainedSeq* lookup_name(const char* search_name, ::CORBA::Long levels_to_search, ::CORBA::DefinitionKind limit_type, ::CORBA::Boolean exclude_inherited) = 0;
  virtual Container::DescriptionSeq* describe_contents(::CORBA::DefinitionKind limit_type, ::CORBA::Boolean exclude_inherited, ::CORBA::Long max_returned_objs) = 0;
  virtual ModuleDef_ptr create_module(const char* id, const char* name, const char* version) = 0;
  virtual ConstantDef_ptr create_constant(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr type, const ::CORBA::Any& value) = 0;
  virtual StructDef_ptr create_struct(const char* id, const char* name, const char* version, const ::CORBA::StructMemberSeq& members) = 0;
  virtual UnionDef_ptr create_union(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr discriminator_type, const ::CORBA::UnionMemberSeq& members) = 0;
  virtual EnumDef_ptr create_enum(const char* id, const char* name, const char* version, const ::CORBA::EnumMemberSeq& members) = 0;
  virtual AliasDef_ptr create_alias(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr original_type) = 0;
  virtual InterfaceDef_ptr create_interface(const char* id, const char* name, const char* version, const ::CORBA::InterfaceDefSeq& base_interfaces) = 0;
  virtual ValueDef_ptr create_value(const char* id, const char* name, const char* version, ::CORBA::Boolean is_custom, ::CORBA::Boolean is_abstract, ::CORBA::ValueDef_ptr base_value, ::CORBA::Boolean is_truncatable, const ::CORBA::ValueDefSeq& abstract_base_values, const ::CORBA::InterfaceDefSeq& supported_interfaces, const ::CORBA::InitializerSeq& initializers) = 0;
  virtual ValueBoxDef_ptr create_value_box(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr original_type_def) = 0;
  virtual ExceptionDef_ptr create_exception(const char* id, const char* name, const char* version, const ::CORBA::StructMemberSeq& members) = 0;
  virtual NativeDef_ptr create_native(const char* id, const char* name, const char* version) = 0;
  virtual AbstractInterfaceDef_ptr create_abstract_interface(const char* id, const char* name, const char* version, const ::CORBA::AbstractInterfaceDefSeq& base_interfaces) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Container;

#ifndef __CORBA_mIDLType__
#define __CORBA_mIDLType__
class IDLType;
class _objref_IDLType;
class _impl_IDLType;

typedef _objref_IDLType* IDLType_ptr;
typedef IDLType_ptr IDLTypeRef;

class IDLType_Helper {
public:
  typedef IDLType_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_IDLType, IDLType_Helper> IDLType_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_IDLType,IDLType_Helper > IDLType_out;

#endif

// interface IDLType
class IDLType {
public:
  // Declarations for this interface type.
  typedef IDLType_ptr _ptr_type;
  typedef IDLType_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_IDLType :
  public virtual _objref_IRObject
{
public:
  // IDL operations
  ::CORBA::TypeCode_ptr type();

  // Constructors
  inline _objref_IDLType()  { _PR_setobj(0); }  // nil
  _objref_IDLType(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_IDLType();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_IDLType(const _objref_IDLType&);
  _objref_IDLType& operator = (const _objref_IDLType&);
  // not implemented

  friend class IDLType;
};

class _pof_IDLType : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_IDLType() : _OMNI_NS(proxyObjectFactory)(IDLType::_PD_repoId) {}
  virtual ~_pof_IDLType();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_IDLType :
  public virtual _impl_IRObject
{
public:
  virtual ~_impl_IDLType();

  virtual ::CORBA::TypeCode_ptr type() = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_IDLType;

#ifndef __CORBA_mPrimitiveDef__
#define __CORBA_mPrimitiveDef__
class PrimitiveDef;
class _objref_PrimitiveDef;
class _impl_PrimitiveDef;

typedef _objref_PrimitiveDef* PrimitiveDef_ptr;
typedef PrimitiveDef_ptr PrimitiveDefRef;

class PrimitiveDef_Helper {
public:
  typedef PrimitiveDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_PrimitiveDef, PrimitiveDef_Helper> PrimitiveDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_PrimitiveDef,PrimitiveDef_Helper > PrimitiveDef_out;

#endif

#ifndef __CORBA_mStringDef__
#define __CORBA_mStringDef__
class StringDef;
class _objref_StringDef;
class _impl_StringDef;

typedef _objref_StringDef* StringDef_ptr;
typedef StringDef_ptr StringDefRef;

class StringDef_Helper {
public:
  typedef StringDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_StringDef, StringDef_Helper> StringDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_StringDef,StringDef_Helper > StringDef_out;

#endif

#ifndef __CORBA_mSequenceDef__
#define __CORBA_mSequenceDef__
class SequenceDef;
class _objref_SequenceDef;
class _impl_SequenceDef;

typedef _objref_SequenceDef* SequenceDef_ptr;
typedef SequenceDef_ptr SequenceDefRef;

class SequenceDef_Helper {
public:
  typedef SequenceDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_SequenceDef, SequenceDef_Helper> SequenceDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_SequenceDef,SequenceDef_Helper > SequenceDef_out;

#endif

#ifndef __CORBA_mArrayDef__
#define __CORBA_mArrayDef__
class ArrayDef;
class _objref_ArrayDef;
class _impl_ArrayDef;

typedef _objref_ArrayDef* ArrayDef_ptr;
typedef ArrayDef_ptr ArrayDefRef;

class ArrayDef_Helper {
public:
  typedef ArrayDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ArrayDef, ArrayDef_Helper> ArrayDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ArrayDef,ArrayDef_Helper > ArrayDef_out;

#endif

enum PrimitiveKind { pk_null, pk_void, pk_short, pk_long, pk_ushort, pk_ulong, pk_float, pk_double, pk_boolean, pk_char, pk_octet, pk_any, pk_TypeCode, pk_Principal, pk_string, pk_objref, pk_longlong, pk_ulonglong, pk_longdouble, pk_wchar, pk_wstring, pk_value_base /*, __max_PrimitiveKind=0xffffffff */ };
typedef PrimitiveKind& PrimitiveKind_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PrimitiveKind;

#ifndef __CORBA_mRepository__
#define __CORBA_mRepository__
class Repository;
class _objref_Repository;
class _impl_Repository;

typedef _objref_Repository* Repository_ptr;
typedef Repository_ptr RepositoryRef;

class Repository_Helper {
public:
  typedef Repository_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_Repository, Repository_Helper> Repository_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_Repository,Repository_Helper > Repository_out;

#endif

// interface Repository
class Repository {
public:
  // Declarations for this interface type.
  typedef Repository_ptr _ptr_type;
  typedef Repository_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_Repository :
  public virtual _objref_Container
{
public:
  // IDL operations
  Contained_ptr lookup_id(const char* search_id);
  ::CORBA::TypeCode_ptr get_canonical_typecode(::CORBA::TypeCode_ptr tc);
  PrimitiveDef_ptr get_primitive(::CORBA::PrimitiveKind kind);
  StringDef_ptr create_string(::CORBA::ULong bound);
  WstringDef_ptr create_wstring(::CORBA::ULong bound);
  SequenceDef_ptr create_sequence(::CORBA::ULong bound, ::CORBA::IDLType_ptr element_type);
  ArrayDef_ptr create_array(::CORBA::ULong length, ::CORBA::IDLType_ptr element_type);
  FixedDef_ptr create_fixed(::CORBA::UShort digits, ::CORBA::Short scale);

  // Constructors
  inline _objref_Repository()  { _PR_setobj(0); }  // nil
  _objref_Repository(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_Repository();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_Repository(const _objref_Repository&);
  _objref_Repository& operator = (const _objref_Repository&);
  // not implemented

  friend class Repository;
};

class _pof_Repository : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_Repository() : _OMNI_NS(proxyObjectFactory)(Repository::_PD_repoId) {}
  virtual ~_pof_Repository();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_Repository :
  public virtual _impl_Container
{
public:
  virtual ~_impl_Repository();

  virtual Contained_ptr lookup_id(const char* search_id) = 0;
  virtual ::CORBA::TypeCode_ptr get_canonical_typecode(::CORBA::TypeCode_ptr tc) = 0;
  virtual PrimitiveDef_ptr get_primitive(::CORBA::PrimitiveKind kind) = 0;
  virtual StringDef_ptr create_string(::CORBA::ULong bound) = 0;
  virtual WstringDef_ptr create_wstring(::CORBA::ULong bound) = 0;
  virtual SequenceDef_ptr create_sequence(::CORBA::ULong bound, ::CORBA::IDLType_ptr element_type) = 0;
  virtual ArrayDef_ptr create_array(::CORBA::ULong length, ::CORBA::IDLType_ptr element_type) = 0;
  virtual FixedDef_ptr create_fixed(::CORBA::UShort digits, ::CORBA::Short scale) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Repository;

#ifndef __CORBA_mModuleDef__
#define __CORBA_mModuleDef__
class ModuleDef;
class _objref_ModuleDef;
class _impl_ModuleDef;

typedef _objref_ModuleDef* ModuleDef_ptr;
typedef ModuleDef_ptr ModuleDefRef;

class ModuleDef_Helper {
public:
  typedef ModuleDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ModuleDef, ModuleDef_Helper> ModuleDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ModuleDef,ModuleDef_Helper > ModuleDef_out;

#endif

// interface ModuleDef
class ModuleDef {
public:
  // Declarations for this interface type.
  typedef ModuleDef_ptr _ptr_type;
  typedef ModuleDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_ModuleDef :
  public virtual _objref_Container,
  public virtual _objref_Contained
{
public:
  // IDL operations
  

  // Constructors
  inline _objref_ModuleDef()  { _PR_setobj(0); }  // nil
  _objref_ModuleDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_ModuleDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_ModuleDef(const _objref_ModuleDef&);
  _objref_ModuleDef& operator = (const _objref_ModuleDef&);
  // not implemented

  friend class ModuleDef;
};

class _pof_ModuleDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_ModuleDef() : _OMNI_NS(proxyObjectFactory)(ModuleDef::_PD_repoId) {}
  virtual ~_pof_ModuleDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_ModuleDef :
  public virtual _impl_Container,
  public virtual _impl_Contained
{
public:
  virtual ~_impl_ModuleDef();

  
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ModuleDef;

struct ModuleDescription {
  typedef _CORBA_ConstrType_Variable_Var<ModuleDescription> _var_type;

  
  ::CORBA::String_member name;

  ::CORBA::String_member id;

  ::CORBA::String_member defined_in;

  ::CORBA::String_member version;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef ModuleDescription::_var_type ModuleDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< ModuleDescription,ModuleDescription_var > ModuleDescription_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ModuleDescription;

#ifndef __CORBA_mConstantDef__
#define __CORBA_mConstantDef__
class ConstantDef;
class _objref_ConstantDef;
class _impl_ConstantDef;

typedef _objref_ConstantDef* ConstantDef_ptr;
typedef ConstantDef_ptr ConstantDefRef;

class ConstantDef_Helper {
public:
  typedef ConstantDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ConstantDef, ConstantDef_Helper> ConstantDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ConstantDef,ConstantDef_Helper > ConstantDef_out;

#endif

// interface ConstantDef
class ConstantDef {
public:
  // Declarations for this interface type.
  typedef ConstantDef_ptr _ptr_type;
  typedef ConstantDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_ConstantDef :
  public virtual _objref_Contained
{
public:
  // IDL operations
  ::CORBA::TypeCode_ptr type();
  IDLType_ptr type_def();
  void type_def(::CORBA::IDLType_ptr _v);
  ::CORBA::Any* value();
  void value(const ::CORBA::Any& _v);

  // Constructors
  inline _objref_ConstantDef()  { _PR_setobj(0); }  // nil
  _objref_ConstantDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_ConstantDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_ConstantDef(const _objref_ConstantDef&);
  _objref_ConstantDef& operator = (const _objref_ConstantDef&);
  // not implemented

  friend class ConstantDef;
};

class _pof_ConstantDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_ConstantDef() : _OMNI_NS(proxyObjectFactory)(ConstantDef::_PD_repoId) {}
  virtual ~_pof_ConstantDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_ConstantDef :
  public virtual _impl_Contained
{
public:
  virtual ~_impl_ConstantDef();

  virtual ::CORBA::TypeCode_ptr type() = 0;
  virtual IDLType_ptr type_def() = 0;
  virtual void type_def(::CORBA::IDLType_ptr _v) = 0;
  virtual ::CORBA::Any* value() = 0;
  virtual void value(const ::CORBA::Any& _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConstantDef;

struct ConstantDescription {
  typedef _CORBA_ConstrType_Variable_Var<ConstantDescription> _var_type;

  
  ::CORBA::String_member name;

  ::CORBA::String_member id;

  ::CORBA::String_member defined_in;

  ::CORBA::String_member version;

  ::CORBA::TypeCode_member type;

  ::CORBA::Any value;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef ConstantDescription::_var_type ConstantDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< ConstantDescription,ConstantDescription_var > ConstantDescription_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConstantDescription;

#ifndef __CORBA_mTypedefDef__
#define __CORBA_mTypedefDef__
class TypedefDef;
class _objref_TypedefDef;
class _impl_TypedefDef;

typedef _objref_TypedefDef* TypedefDef_ptr;
typedef TypedefDef_ptr TypedefDefRef;

class TypedefDef_Helper {
public:
  typedef TypedefDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_TypedefDef, TypedefDef_Helper> TypedefDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_TypedefDef,TypedefDef_Helper > TypedefDef_out;

#endif

// interface TypedefDef
class TypedefDef {
public:
  // Declarations for this interface type.
  typedef TypedefDef_ptr _ptr_type;
  typedef TypedefDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_TypedefDef :
  public virtual _objref_Contained,
  public virtual _objref_IDLType
{
public:
  // IDL operations
  

  // Constructors
  inline _objref_TypedefDef()  { _PR_setobj(0); }  // nil
  _objref_TypedefDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_TypedefDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_TypedefDef(const _objref_TypedefDef&);
  _objref_TypedefDef& operator = (const _objref_TypedefDef&);
  // not implemented

  friend class TypedefDef;
};

class _pof_TypedefDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_TypedefDef() : _OMNI_NS(proxyObjectFactory)(TypedefDef::_PD_repoId) {}
  virtual ~_pof_TypedefDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_TypedefDef :
  public virtual _impl_Contained,
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_TypedefDef();

  
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TypedefDef;

struct TypeDescription {
  typedef _CORBA_ConstrType_Variable_Var<TypeDescription> _var_type;

  
  ::CORBA::String_member name;

  ::CORBA::String_member id;

  ::CORBA::String_member defined_in;

  ::CORBA::String_member version;

  ::CORBA::TypeCode_member type;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef TypeDescription::_var_type TypeDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< TypeDescription,TypeDescription_var > TypeDescription_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TypeDescription;

#ifndef __CORBA_mStructDef__
#define __CORBA_mStructDef__
class StructDef;
class _objref_StructDef;
class _impl_StructDef;

typedef _objref_StructDef* StructDef_ptr;
typedef StructDef_ptr StructDefRef;

class StructDef_Helper {
public:
  typedef StructDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_StructDef, StructDef_Helper> StructDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_StructDef,StructDef_Helper > StructDef_out;

#endif

// interface StructDef
class StructDef {
public:
  // Declarations for this interface type.
  typedef StructDef_ptr _ptr_type;
  typedef StructDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_StructDef :
  public virtual _objref_TypedefDef,
  public virtual _objref_Container
{
public:
  // IDL operations
  StructMemberSeq* members();
  void members(const ::CORBA::StructMemberSeq& _v);

  // Constructors
  inline _objref_StructDef()  { _PR_setobj(0); }  // nil
  _objref_StructDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_StructDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_StructDef(const _objref_StructDef&);
  _objref_StructDef& operator = (const _objref_StructDef&);
  // not implemented

  friend class StructDef;
};

class _pof_StructDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_StructDef() : _OMNI_NS(proxyObjectFactory)(StructDef::_PD_repoId) {}
  virtual ~_pof_StructDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_StructDef :
  public virtual _impl_TypedefDef,
  public virtual _impl_Container
{
public:
  virtual ~_impl_StructDef();

  virtual StructMemberSeq* members() = 0;
  virtual void members(const ::CORBA::StructMemberSeq& _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StructDef;

#ifndef __CORBA_mUnionDef__
#define __CORBA_mUnionDef__
class UnionDef;
class _objref_UnionDef;
class _impl_UnionDef;

typedef _objref_UnionDef* UnionDef_ptr;
typedef UnionDef_ptr UnionDefRef;

class UnionDef_Helper {
public:
  typedef UnionDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_UnionDef, UnionDef_Helper> UnionDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_UnionDef,UnionDef_Helper > UnionDef_out;

#endif

// interface UnionDef
class UnionDef {
public:
  // Declarations for this interface type.
  typedef UnionDef_ptr _ptr_type;
  typedef UnionDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_UnionDef :
  public virtual _objref_TypedefDef,
  public virtual _objref_Container
{
public:
  // IDL operations
  ::CORBA::TypeCode_ptr discriminator_type();
  IDLType_ptr discriminator_type_def();
  void discriminator_type_def(::CORBA::IDLType_ptr _v);
  UnionMemberSeq* members();
  void members(const ::CORBA::UnionMemberSeq& _v);

  // Constructors
  inline _objref_UnionDef()  { _PR_setobj(0); }  // nil
  _objref_UnionDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_UnionDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_UnionDef(const _objref_UnionDef&);
  _objref_UnionDef& operator = (const _objref_UnionDef&);
  // not implemented

  friend class UnionDef;
};

class _pof_UnionDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_UnionDef() : _OMNI_NS(proxyObjectFactory)(UnionDef::_PD_repoId) {}
  virtual ~_pof_UnionDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_UnionDef :
  public virtual _impl_TypedefDef,
  public virtual _impl_Container
{
public:
  virtual ~_impl_UnionDef();

  virtual ::CORBA::TypeCode_ptr discriminator_type() = 0;
  virtual IDLType_ptr discriminator_type_def() = 0;
  virtual void discriminator_type_def(::CORBA::IDLType_ptr _v) = 0;
  virtual UnionMemberSeq* members() = 0;
  virtual void members(const ::CORBA::UnionMemberSeq& _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnionDef;

#ifndef __CORBA_mEnumDef__
#define __CORBA_mEnumDef__
class EnumDef;
class _objref_EnumDef;
class _impl_EnumDef;

typedef _objref_EnumDef* EnumDef_ptr;
typedef EnumDef_ptr EnumDefRef;

class EnumDef_Helper {
public:
  typedef EnumDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_EnumDef, EnumDef_Helper> EnumDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_EnumDef,EnumDef_Helper > EnumDef_out;

#endif

// interface EnumDef
class EnumDef {
public:
  // Declarations for this interface type.
  typedef EnumDef_ptr _ptr_type;
  typedef EnumDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_EnumDef :
  public virtual _objref_TypedefDef
{
public:
  // IDL operations
  EnumMemberSeq* members();
  void members(const ::CORBA::EnumMemberSeq& _v);

  // Constructors
  inline _objref_EnumDef()  { _PR_setobj(0); }  // nil
  _objref_EnumDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_EnumDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_EnumDef(const _objref_EnumDef&);
  _objref_EnumDef& operator = (const _objref_EnumDef&);
  // not implemented

  friend class EnumDef;
};

class _pof_EnumDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_EnumDef() : _OMNI_NS(proxyObjectFactory)(EnumDef::_PD_repoId) {}
  virtual ~_pof_EnumDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_EnumDef :
  public virtual _impl_TypedefDef
{
public:
  virtual ~_impl_EnumDef();

  virtual EnumMemberSeq* members() = 0;
  virtual void members(const ::CORBA::EnumMemberSeq& _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EnumDef;

#ifndef __CORBA_mAliasDef__
#define __CORBA_mAliasDef__
class AliasDef;
class _objref_AliasDef;
class _impl_AliasDef;

typedef _objref_AliasDef* AliasDef_ptr;
typedef AliasDef_ptr AliasDefRef;

class AliasDef_Helper {
public:
  typedef AliasDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_AliasDef, AliasDef_Helper> AliasDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_AliasDef,AliasDef_Helper > AliasDef_out;

#endif

// interface AliasDef
class AliasDef {
public:
  // Declarations for this interface type.
  typedef AliasDef_ptr _ptr_type;
  typedef AliasDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_AliasDef :
  public virtual _objref_TypedefDef
{
public:
  // IDL operations
  IDLType_ptr original_type_def();
  void original_type_def(::CORBA::IDLType_ptr _v);

  // Constructors
  inline _objref_AliasDef()  { _PR_setobj(0); }  // nil
  _objref_AliasDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_AliasDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_AliasDef(const _objref_AliasDef&);
  _objref_AliasDef& operator = (const _objref_AliasDef&);
  // not implemented

  friend class AliasDef;
};

class _pof_AliasDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_AliasDef() : _OMNI_NS(proxyObjectFactory)(AliasDef::_PD_repoId) {}
  virtual ~_pof_AliasDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_AliasDef :
  public virtual _impl_TypedefDef
{
public:
  virtual ~_impl_AliasDef();

  virtual IDLType_ptr original_type_def() = 0;
  virtual void original_type_def(::CORBA::IDLType_ptr _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AliasDef;

#ifndef __CORBA_mNativeDef__
#define __CORBA_mNativeDef__
class NativeDef;
class _objref_NativeDef;
class _impl_NativeDef;

typedef _objref_NativeDef* NativeDef_ptr;
typedef NativeDef_ptr NativeDefRef;

class NativeDef_Helper {
public:
  typedef NativeDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_NativeDef, NativeDef_Helper> NativeDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_NativeDef,NativeDef_Helper > NativeDef_out;

#endif

// interface NativeDef
class NativeDef {
public:
  // Declarations for this interface type.
  typedef NativeDef_ptr _ptr_type;
  typedef NativeDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_NativeDef :
  public virtual _objref_TypedefDef
{
public:
  // IDL operations
  

  // Constructors
  inline _objref_NativeDef()  { _PR_setobj(0); }  // nil
  _objref_NativeDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_NativeDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_NativeDef(const _objref_NativeDef&);
  _objref_NativeDef& operator = (const _objref_NativeDef&);
  // not implemented

  friend class NativeDef;
};

class _pof_NativeDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_NativeDef() : _OMNI_NS(proxyObjectFactory)(NativeDef::_PD_repoId) {}
  virtual ~_pof_NativeDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_NativeDef :
  public virtual _impl_TypedefDef
{
public:
  virtual ~_impl_NativeDef();

  
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NativeDef;

#ifndef __CORBA_mPrimitiveDef__
#define __CORBA_mPrimitiveDef__
class PrimitiveDef;
class _objref_PrimitiveDef;
class _impl_PrimitiveDef;

typedef _objref_PrimitiveDef* PrimitiveDef_ptr;
typedef PrimitiveDef_ptr PrimitiveDefRef;

class PrimitiveDef_Helper {
public:
  typedef PrimitiveDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_PrimitiveDef, PrimitiveDef_Helper> PrimitiveDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_PrimitiveDef,PrimitiveDef_Helper > PrimitiveDef_out;

#endif

// interface PrimitiveDef
class PrimitiveDef {
public:
  // Declarations for this interface type.
  typedef PrimitiveDef_ptr _ptr_type;
  typedef PrimitiveDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_PrimitiveDef :
  public virtual _objref_IDLType
{
public:
  // IDL operations
  PrimitiveKind kind();

  // Constructors
  inline _objref_PrimitiveDef()  { _PR_setobj(0); }  // nil
  _objref_PrimitiveDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_PrimitiveDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_PrimitiveDef(const _objref_PrimitiveDef&);
  _objref_PrimitiveDef& operator = (const _objref_PrimitiveDef&);
  // not implemented

  friend class PrimitiveDef;
};

class _pof_PrimitiveDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_PrimitiveDef() : _OMNI_NS(proxyObjectFactory)(PrimitiveDef::_PD_repoId) {}
  virtual ~_pof_PrimitiveDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_PrimitiveDef :
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_PrimitiveDef();

  virtual PrimitiveKind kind() = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PrimitiveDef;

#ifndef __CORBA_mStringDef__
#define __CORBA_mStringDef__
class StringDef;
class _objref_StringDef;
class _impl_StringDef;

typedef _objref_StringDef* StringDef_ptr;
typedef StringDef_ptr StringDefRef;

class StringDef_Helper {
public:
  typedef StringDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_StringDef, StringDef_Helper> StringDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_StringDef,StringDef_Helper > StringDef_out;

#endif

// interface StringDef
class StringDef {
public:
  // Declarations for this interface type.
  typedef StringDef_ptr _ptr_type;
  typedef StringDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_StringDef :
  public virtual _objref_IDLType
{
public:
  // IDL operations
  ::CORBA::ULong bound();
  void bound(::CORBA::ULong _v);

  // Constructors
  inline _objref_StringDef()  { _PR_setobj(0); }  // nil
  _objref_StringDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_StringDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_StringDef(const _objref_StringDef&);
  _objref_StringDef& operator = (const _objref_StringDef&);
  // not implemented

  friend class StringDef;
};

class _pof_StringDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_StringDef() : _OMNI_NS(proxyObjectFactory)(StringDef::_PD_repoId) {}
  virtual ~_pof_StringDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_StringDef :
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_StringDef();

  virtual ::CORBA::ULong bound() = 0;
  virtual void bound(::CORBA::ULong _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StringDef;

#ifndef __CORBA_mWstringDef__
#define __CORBA_mWstringDef__
class WstringDef;
class _objref_WstringDef;
class _impl_WstringDef;

typedef _objref_WstringDef* WstringDef_ptr;
typedef WstringDef_ptr WstringDefRef;

class WstringDef_Helper {
public:
  typedef WstringDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_WstringDef, WstringDef_Helper> WstringDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_WstringDef,WstringDef_Helper > WstringDef_out;

#endif

// interface WstringDef
class WstringDef {
public:
  // Declarations for this interface type.
  typedef WstringDef_ptr _ptr_type;
  typedef WstringDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_WstringDef :
  public virtual _objref_IDLType
{
public:
  // IDL operations
  ::CORBA::ULong bound();
  void bound(::CORBA::ULong _v);

  // Constructors
  inline _objref_WstringDef()  { _PR_setobj(0); }  // nil
  _objref_WstringDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_WstringDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_WstringDef(const _objref_WstringDef&);
  _objref_WstringDef& operator = (const _objref_WstringDef&);
  // not implemented

  friend class WstringDef;
};

class _pof_WstringDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_WstringDef() : _OMNI_NS(proxyObjectFactory)(WstringDef::_PD_repoId) {}
  virtual ~_pof_WstringDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_WstringDef :
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_WstringDef();

  virtual ::CORBA::ULong bound() = 0;
  virtual void bound(::CORBA::ULong _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WstringDef;

#ifndef __CORBA_mFixedDef__
#define __CORBA_mFixedDef__
class FixedDef;
class _objref_FixedDef;
class _impl_FixedDef;

typedef _objref_FixedDef* FixedDef_ptr;
typedef FixedDef_ptr FixedDefRef;

class FixedDef_Helper {
public:
  typedef FixedDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_FixedDef, FixedDef_Helper> FixedDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_FixedDef,FixedDef_Helper > FixedDef_out;

#endif

// interface FixedDef
class FixedDef {
public:
  // Declarations for this interface type.
  typedef FixedDef_ptr _ptr_type;
  typedef FixedDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_FixedDef :
  public virtual _objref_IDLType
{
public:
  // IDL operations
  ::CORBA::UShort digits();
  void digits(::CORBA::UShort _v);
  ::CORBA::Short scale();
  void scale(::CORBA::Short _v);

  // Constructors
  inline _objref_FixedDef()  { _PR_setobj(0); }  // nil
  _objref_FixedDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_FixedDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_FixedDef(const _objref_FixedDef&);
  _objref_FixedDef& operator = (const _objref_FixedDef&);
  // not implemented

  friend class FixedDef;
};

class _pof_FixedDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_FixedDef() : _OMNI_NS(proxyObjectFactory)(FixedDef::_PD_repoId) {}
  virtual ~_pof_FixedDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_FixedDef :
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_FixedDef();

  virtual ::CORBA::UShort digits() = 0;
  virtual void digits(::CORBA::UShort _v) = 0;
  virtual ::CORBA::Short scale() = 0;
  virtual void scale(::CORBA::Short _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FixedDef;

#ifndef __CORBA_mSequenceDef__
#define __CORBA_mSequenceDef__
class SequenceDef;
class _objref_SequenceDef;
class _impl_SequenceDef;

typedef _objref_SequenceDef* SequenceDef_ptr;
typedef SequenceDef_ptr SequenceDefRef;

class SequenceDef_Helper {
public:
  typedef SequenceDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_SequenceDef, SequenceDef_Helper> SequenceDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_SequenceDef,SequenceDef_Helper > SequenceDef_out;

#endif

// interface SequenceDef
class SequenceDef {
public:
  // Declarations for this interface type.
  typedef SequenceDef_ptr _ptr_type;
  typedef SequenceDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_SequenceDef :
  public virtual _objref_IDLType
{
public:
  // IDL operations
  ::CORBA::ULong bound();
  void bound(::CORBA::ULong _v);
  ::CORBA::TypeCode_ptr element_type();
  IDLType_ptr element_type_def();
  void element_type_def(::CORBA::IDLType_ptr _v);

  // Constructors
  inline _objref_SequenceDef()  { _PR_setobj(0); }  // nil
  _objref_SequenceDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_SequenceDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_SequenceDef(const _objref_SequenceDef&);
  _objref_SequenceDef& operator = (const _objref_SequenceDef&);
  // not implemented

  friend class SequenceDef;
};

class _pof_SequenceDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_SequenceDef() : _OMNI_NS(proxyObjectFactory)(SequenceDef::_PD_repoId) {}
  virtual ~_pof_SequenceDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_SequenceDef :
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_SequenceDef();

  virtual ::CORBA::ULong bound() = 0;
  virtual void bound(::CORBA::ULong _v) = 0;
  virtual ::CORBA::TypeCode_ptr element_type() = 0;
  virtual IDLType_ptr element_type_def() = 0;
  virtual void element_type_def(::CORBA::IDLType_ptr _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SequenceDef;

#ifndef __CORBA_mArrayDef__
#define __CORBA_mArrayDef__
class ArrayDef;
class _objref_ArrayDef;
class _impl_ArrayDef;

typedef _objref_ArrayDef* ArrayDef_ptr;
typedef ArrayDef_ptr ArrayDefRef;

class ArrayDef_Helper {
public:
  typedef ArrayDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ArrayDef, ArrayDef_Helper> ArrayDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ArrayDef,ArrayDef_Helper > ArrayDef_out;

#endif

// interface ArrayDef
class ArrayDef {
public:
  // Declarations for this interface type.
  typedef ArrayDef_ptr _ptr_type;
  typedef ArrayDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_ArrayDef :
  public virtual _objref_IDLType
{
public:
  // IDL operations
  ::CORBA::ULong length();
  void length(::CORBA::ULong _v);
  ::CORBA::TypeCode_ptr element_type();
  IDLType_ptr element_type_def();
  void element_type_def(::CORBA::IDLType_ptr _v);

  // Constructors
  inline _objref_ArrayDef()  { _PR_setobj(0); }  // nil
  _objref_ArrayDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_ArrayDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_ArrayDef(const _objref_ArrayDef&);
  _objref_ArrayDef& operator = (const _objref_ArrayDef&);
  // not implemented

  friend class ArrayDef;
};

class _pof_ArrayDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_ArrayDef() : _OMNI_NS(proxyObjectFactory)(ArrayDef::_PD_repoId) {}
  virtual ~_pof_ArrayDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_ArrayDef :
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_ArrayDef();

  virtual ::CORBA::ULong length() = 0;
  virtual void length(::CORBA::ULong _v) = 0;
  virtual ::CORBA::TypeCode_ptr element_type() = 0;
  virtual IDLType_ptr element_type_def() = 0;
  virtual void element_type_def(::CORBA::IDLType_ptr _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ArrayDef;

#ifndef __CORBA_mExceptionDef__
#define __CORBA_mExceptionDef__
class ExceptionDef;
class _objref_ExceptionDef;
class _impl_ExceptionDef;

typedef _objref_ExceptionDef* ExceptionDef_ptr;
typedef ExceptionDef_ptr ExceptionDefRef;

class ExceptionDef_Helper {
public:
  typedef ExceptionDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ExceptionDef, ExceptionDef_Helper> ExceptionDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ExceptionDef,ExceptionDef_Helper > ExceptionDef_out;

#endif

// interface ExceptionDef
class ExceptionDef {
public:
  // Declarations for this interface type.
  typedef ExceptionDef_ptr _ptr_type;
  typedef ExceptionDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_ExceptionDef :
  public virtual _objref_Contained,
  public virtual _objref_Container
{
public:
  // IDL operations
  ::CORBA::TypeCode_ptr type();
  StructMemberSeq* members();
  void members(const ::CORBA::StructMemberSeq& _v);

  // Constructors
  inline _objref_ExceptionDef()  { _PR_setobj(0); }  // nil
  _objref_ExceptionDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_ExceptionDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_ExceptionDef(const _objref_ExceptionDef&);
  _objref_ExceptionDef& operator = (const _objref_ExceptionDef&);
  // not implemented

  friend class ExceptionDef;
};

class _pof_ExceptionDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_ExceptionDef() : _OMNI_NS(proxyObjectFactory)(ExceptionDef::_PD_repoId) {}
  virtual ~_pof_ExceptionDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_ExceptionDef :
  public virtual _impl_Contained,
  public virtual _impl_Container
{
public:
  virtual ~_impl_ExceptionDef();

  virtual ::CORBA::TypeCode_ptr type() = 0;
  virtual StructMemberSeq* members() = 0;
  virtual void members(const ::CORBA::StructMemberSeq& _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExceptionDef;

struct ExceptionDescription {
  typedef _CORBA_ConstrType_Variable_Var<ExceptionDescription> _var_type;

  
  ::CORBA::String_member name;

  ::CORBA::String_member id;

  ::CORBA::String_member defined_in;

  ::CORBA::String_member version;

  ::CORBA::TypeCode_member type;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef ExceptionDescription::_var_type ExceptionDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< ExceptionDescription,ExceptionDescription_var > ExceptionDescription_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExceptionDescription;

enum AttributeMode { ATTR_NORMAL, ATTR_READONLY /*, __max_AttributeMode=0xffffffff */ };
typedef AttributeMode& AttributeMode_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AttributeMode;

#ifndef __CORBA_mAttributeDef__
#define __CORBA_mAttributeDef__
class AttributeDef;
class _objref_AttributeDef;
class _impl_AttributeDef;

typedef _objref_AttributeDef* AttributeDef_ptr;
typedef AttributeDef_ptr AttributeDefRef;

class AttributeDef_Helper {
public:
  typedef AttributeDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_AttributeDef, AttributeDef_Helper> AttributeDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_AttributeDef,AttributeDef_Helper > AttributeDef_out;

#endif

// interface AttributeDef
class AttributeDef {
public:
  // Declarations for this interface type.
  typedef AttributeDef_ptr _ptr_type;
  typedef AttributeDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_AttributeDef :
  public virtual _objref_Contained
{
public:
  // IDL operations
  ::CORBA::TypeCode_ptr type();
  IDLType_ptr type_def();
  void type_def(::CORBA::IDLType_ptr _v);
  AttributeMode mode();
  void mode(::CORBA::AttributeMode _v);

  // Constructors
  inline _objref_AttributeDef()  { _PR_setobj(0); }  // nil
  _objref_AttributeDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_AttributeDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_AttributeDef(const _objref_AttributeDef&);
  _objref_AttributeDef& operator = (const _objref_AttributeDef&);
  // not implemented

  friend class AttributeDef;
};

class _pof_AttributeDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_AttributeDef() : _OMNI_NS(proxyObjectFactory)(AttributeDef::_PD_repoId) {}
  virtual ~_pof_AttributeDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_AttributeDef :
  public virtual _impl_Contained
{
public:
  virtual ~_impl_AttributeDef();

  virtual ::CORBA::TypeCode_ptr type() = 0;
  virtual IDLType_ptr type_def() = 0;
  virtual void type_def(::CORBA::IDLType_ptr _v) = 0;
  virtual AttributeMode mode() = 0;
  virtual void mode(::CORBA::AttributeMode _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AttributeDef;

struct AttributeDescription {
  typedef _CORBA_ConstrType_Variable_Var<AttributeDescription> _var_type;

  
  ::CORBA::String_member name;

  ::CORBA::String_member id;

  ::CORBA::String_member defined_in;

  ::CORBA::String_member version;

  ::CORBA::TypeCode_member type;

  AttributeMode mode;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef AttributeDescription::_var_type AttributeDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< AttributeDescription,AttributeDescription_var > AttributeDescription_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AttributeDescription;

enum OperationMode { OP_NORMAL, OP_ONEWAY /*, __max_OperationMode=0xffffffff */ };
typedef OperationMode& OperationMode_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OperationMode;

enum ParameterMode { PARAM_IN, PARAM_OUT, PARAM_INOUT /*, __max_ParameterMode=0xffffffff */ };
typedef ParameterMode& ParameterMode_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ParameterMode;

struct ParameterDescription {
  typedef _CORBA_ConstrType_Variable_Var<ParameterDescription> _var_type;

  
  ::CORBA::String_member name;

  ::CORBA::TypeCode_member type;

  _CORBA_ObjRef_Member< _objref_IDLType, IDLType_Helper>  type_def;

  ParameterMode mode;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef ParameterDescription::_var_type ParameterDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< ParameterDescription,ParameterDescription_var > ParameterDescription_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ParameterDescription;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ParDescriptionSeq;

class ParDescriptionSeq_var;

class ParDescriptionSeq : public _CORBA_Unbounded_Sequence< ParameterDescription >  {
public:
  typedef ParDescriptionSeq_var _var_type;
  inline ParDescriptionSeq() {}
  inline ParDescriptionSeq(const ParDescriptionSeq& _s)
    : _CORBA_Unbounded_Sequence< ParameterDescription > (_s) {}

  inline ParDescriptionSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< ParameterDescription > (_max) {}
  inline ParDescriptionSeq(_CORBA_ULong _max, _CORBA_ULong _len, ParameterDescription* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< ParameterDescription > (_max, _len, _val, _rel) {}



  inline ParDescriptionSeq& operator = (const ParDescriptionSeq& _s) {
    _CORBA_Unbounded_Sequence< ParameterDescription > ::operator=(_s);
    return *this;
  }
};

class ParDescriptionSeq_out;

class ParDescriptionSeq_var {
public:
  inline ParDescriptionSeq_var() : _pd_seq(0) {}
  inline ParDescriptionSeq_var(ParDescriptionSeq* _s) : _pd_seq(_s) {}
  inline ParDescriptionSeq_var(const ParDescriptionSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new ParDescriptionSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ParDescriptionSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline ParDescriptionSeq_var& operator = (ParDescriptionSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline ParDescriptionSeq_var& operator = (const ParDescriptionSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new ParDescriptionSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ParameterDescription& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline ParDescriptionSeq* operator -> () { return _pd_seq; }
  inline const ParDescriptionSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator ParDescriptionSeq& () const { return *_pd_seq; }
#else
  inline operator const ParDescriptionSeq& () const { return *_pd_seq; }
  inline operator ParDescriptionSeq& () { return *_pd_seq; }
#endif
    
  inline const ParDescriptionSeq& in() const { return *_pd_seq; }
  inline ParDescriptionSeq&       inout()    { return *_pd_seq; }
  inline ParDescriptionSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline ParDescriptionSeq* _retn() { ParDescriptionSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class ParDescriptionSeq_out;
  
private:
  ParDescriptionSeq* _pd_seq;
};

class ParDescriptionSeq_out {
public:
  inline ParDescriptionSeq_out(ParDescriptionSeq*& _s) : _data(_s) { _data = 0; }
  inline ParDescriptionSeq_out(ParDescriptionSeq_var& _s)
    : _data(_s._pd_seq) { _s = (ParDescriptionSeq*) 0; }
  inline ParDescriptionSeq_out(const ParDescriptionSeq_out& _s) : _data(_s._data) {}
  inline ParDescriptionSeq_out& operator = (const ParDescriptionSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline ParDescriptionSeq_out& operator = (ParDescriptionSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator ParDescriptionSeq*&()  { return _data; }
  inline ParDescriptionSeq*& ptr()       { return _data; }
  inline ParDescriptionSeq* operator->() { return _data; }

  inline ParameterDescription& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  ParDescriptionSeq*& _data;

private:
  ParDescriptionSeq_out();
  ParDescriptionSeq_out& operator=(const ParDescriptionSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ContextIdentifier;

typedef char* ContextIdentifier;
typedef ::CORBA::String_var ContextIdentifier_var;
typedef ::CORBA::String_out ContextIdentifier_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ContextIdSeq;

class ContextIdSeq_var;

class ContextIdSeq : public _CORBA_Unbounded_Sequence_String {
public:
  typedef ContextIdSeq_var _var_type;
  inline ContextIdSeq() {}
  inline ContextIdSeq(const ContextIdSeq& _s)
    : _CORBA_Unbounded_Sequence_String(_s) {}

  inline ContextIdSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_String(_max) {}
  inline ContextIdSeq(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}



  inline ContextIdSeq& operator = (const ContextIdSeq& _s) {
    _CORBA_Unbounded_Sequence_String::operator=(_s);
    return *this;
  }
};

class ContextIdSeq_out;

class ContextIdSeq_var {
public:
  inline ContextIdSeq_var() : _pd_seq(0) {}
  inline ContextIdSeq_var(ContextIdSeq* _s) : _pd_seq(_s) {}
  inline ContextIdSeq_var(const ContextIdSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new ContextIdSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ContextIdSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline ContextIdSeq_var& operator = (ContextIdSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline ContextIdSeq_var& operator = (const ContextIdSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new ContextIdSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline ContextIdSeq* operator -> () { return _pd_seq; }
  inline const ContextIdSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator ContextIdSeq& () const { return *_pd_seq; }
#else
  inline operator const ContextIdSeq& () const { return *_pd_seq; }
  inline operator ContextIdSeq& () { return *_pd_seq; }
#endif
    
  inline const ContextIdSeq& in() const { return *_pd_seq; }
  inline ContextIdSeq&       inout()    { return *_pd_seq; }
  inline ContextIdSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline ContextIdSeq* _retn() { ContextIdSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class ContextIdSeq_out;
  
private:
  ContextIdSeq* _pd_seq;
};

class ContextIdSeq_out {
public:
  inline ContextIdSeq_out(ContextIdSeq*& _s) : _data(_s) { _data = 0; }
  inline ContextIdSeq_out(ContextIdSeq_var& _s)
    : _data(_s._pd_seq) { _s = (ContextIdSeq*) 0; }
  inline ContextIdSeq_out(const ContextIdSeq_out& _s) : _data(_s._data) {}
  inline ContextIdSeq_out& operator = (const ContextIdSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline ContextIdSeq_out& operator = (ContextIdSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator ContextIdSeq*&()  { return _data; }
  inline ContextIdSeq*& ptr()       { return _data; }
  inline ContextIdSeq* operator->() { return _data; }

  inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  ContextIdSeq*& _data;

private:
  ContextIdSeq_out();
  ContextIdSeq_out& operator=(const ContextIdSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExceptionDefSeq;

class ExceptionDefSeq_var;

class ExceptionDefSeq : public _CORBA_Unbounded_Sequence_ObjRef< _objref_ExceptionDef, _CORBA_ObjRef_Element< _objref_ExceptionDef, ExceptionDef_Helper> , ExceptionDef_Helper >  {
public:
  typedef ExceptionDefSeq_var _var_type;
  inline ExceptionDefSeq() {}
  inline ExceptionDefSeq(const ExceptionDefSeq& _s)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_ExceptionDef, _CORBA_ObjRef_Element< _objref_ExceptionDef, ExceptionDef_Helper> , ExceptionDef_Helper > (_s) {}

  inline ExceptionDefSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_ExceptionDef, _CORBA_ObjRef_Element< _objref_ExceptionDef, ExceptionDef_Helper> , ExceptionDef_Helper > (_max) {}
  inline ExceptionDefSeq(_CORBA_ULong _max, _CORBA_ULong _len, ExceptionDef_ptr* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_ExceptionDef, _CORBA_ObjRef_Element< _objref_ExceptionDef, ExceptionDef_Helper> , ExceptionDef_Helper > (_max, _len, _val, _rel) {}



  inline ExceptionDefSeq& operator = (const ExceptionDefSeq& _s) {
    _CORBA_Unbounded_Sequence_ObjRef< _objref_ExceptionDef, _CORBA_ObjRef_Element< _objref_ExceptionDef, ExceptionDef_Helper> , ExceptionDef_Helper > ::operator=(_s);
    return *this;
  }
};

class ExceptionDefSeq_out;

class ExceptionDefSeq_var {
public:
  inline ExceptionDefSeq_var() : _pd_seq(0) {}
  inline ExceptionDefSeq_var(ExceptionDefSeq* _s) : _pd_seq(_s) {}
  inline ExceptionDefSeq_var(const ExceptionDefSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new ExceptionDefSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ExceptionDefSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline ExceptionDefSeq_var& operator = (ExceptionDefSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline ExceptionDefSeq_var& operator = (const ExceptionDefSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new ExceptionDefSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline _CORBA_ObjRef_Element< _objref_ExceptionDef, ExceptionDef_Helper>  operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline ExceptionDefSeq* operator -> () { return _pd_seq; }
  inline const ExceptionDefSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator ExceptionDefSeq& () const { return *_pd_seq; }
#else
  inline operator const ExceptionDefSeq& () const { return *_pd_seq; }
  inline operator ExceptionDefSeq& () { return *_pd_seq; }
#endif
    
  inline const ExceptionDefSeq& in() const { return *_pd_seq; }
  inline ExceptionDefSeq&       inout()    { return *_pd_seq; }
  inline ExceptionDefSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline ExceptionDefSeq* _retn() { ExceptionDefSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class ExceptionDefSeq_out;
  
private:
  ExceptionDefSeq* _pd_seq;
};

class ExceptionDefSeq_out {
public:
  inline ExceptionDefSeq_out(ExceptionDefSeq*& _s) : _data(_s) { _data = 0; }
  inline ExceptionDefSeq_out(ExceptionDefSeq_var& _s)
    : _data(_s._pd_seq) { _s = (ExceptionDefSeq*) 0; }
  inline ExceptionDefSeq_out(const ExceptionDefSeq_out& _s) : _data(_s._data) {}
  inline ExceptionDefSeq_out& operator = (const ExceptionDefSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline ExceptionDefSeq_out& operator = (ExceptionDefSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator ExceptionDefSeq*&()  { return _data; }
  inline ExceptionDefSeq*& ptr()       { return _data; }
  inline ExceptionDefSeq* operator->() { return _data; }

  inline _CORBA_ObjRef_Element< _objref_ExceptionDef, ExceptionDef_Helper>  operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  ExceptionDefSeq*& _data;

private:
  ExceptionDefSeq_out();
  ExceptionDefSeq_out& operator=(const ExceptionDefSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExcDescriptionSeq;

class ExcDescriptionSeq_var;

class ExcDescriptionSeq : public _CORBA_Unbounded_Sequence< ExceptionDescription >  {
public:
  typedef ExcDescriptionSeq_var _var_type;
  inline ExcDescriptionSeq() {}
  inline ExcDescriptionSeq(const ExcDescriptionSeq& _s)
    : _CORBA_Unbounded_Sequence< ExceptionDescription > (_s) {}

  inline ExcDescriptionSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< ExceptionDescription > (_max) {}
  inline ExcDescriptionSeq(_CORBA_ULong _max, _CORBA_ULong _len, ExceptionDescription* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< ExceptionDescription > (_max, _len, _val, _rel) {}



  inline ExcDescriptionSeq& operator = (const ExcDescriptionSeq& _s) {
    _CORBA_Unbounded_Sequence< ExceptionDescription > ::operator=(_s);
    return *this;
  }
};

class ExcDescriptionSeq_out;

class ExcDescriptionSeq_var {
public:
  inline ExcDescriptionSeq_var() : _pd_seq(0) {}
  inline ExcDescriptionSeq_var(ExcDescriptionSeq* _s) : _pd_seq(_s) {}
  inline ExcDescriptionSeq_var(const ExcDescriptionSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new ExcDescriptionSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ExcDescriptionSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline ExcDescriptionSeq_var& operator = (ExcDescriptionSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline ExcDescriptionSeq_var& operator = (const ExcDescriptionSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new ExcDescriptionSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline ExceptionDescription& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline ExcDescriptionSeq* operator -> () { return _pd_seq; }
  inline const ExcDescriptionSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator ExcDescriptionSeq& () const { return *_pd_seq; }
#else
  inline operator const ExcDescriptionSeq& () const { return *_pd_seq; }
  inline operator ExcDescriptionSeq& () { return *_pd_seq; }
#endif
    
  inline const ExcDescriptionSeq& in() const { return *_pd_seq; }
  inline ExcDescriptionSeq&       inout()    { return *_pd_seq; }
  inline ExcDescriptionSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline ExcDescriptionSeq* _retn() { ExcDescriptionSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class ExcDescriptionSeq_out;
  
private:
  ExcDescriptionSeq* _pd_seq;
};

class ExcDescriptionSeq_out {
public:
  inline ExcDescriptionSeq_out(ExcDescriptionSeq*& _s) : _data(_s) { _data = 0; }
  inline ExcDescriptionSeq_out(ExcDescriptionSeq_var& _s)
    : _data(_s._pd_seq) { _s = (ExcDescriptionSeq*) 0; }
  inline ExcDescriptionSeq_out(const ExcDescriptionSeq_out& _s) : _data(_s._data) {}
  inline ExcDescriptionSeq_out& operator = (const ExcDescriptionSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline ExcDescriptionSeq_out& operator = (ExcDescriptionSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator ExcDescriptionSeq*&()  { return _data; }
  inline ExcDescriptionSeq*& ptr()       { return _data; }
  inline ExcDescriptionSeq* operator->() { return _data; }

  inline ExceptionDescription& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  ExcDescriptionSeq*& _data;

private:
  ExcDescriptionSeq_out();
  ExcDescriptionSeq_out& operator=(const ExcDescriptionSeq_var&);
};

#ifndef __CORBA_mOperationDef__
#define __CORBA_mOperationDef__
class OperationDef;
class _objref_OperationDef;
class _impl_OperationDef;

typedef _objref_OperationDef* OperationDef_ptr;
typedef OperationDef_ptr OperationDefRef;

class OperationDef_Helper {
public:
  typedef OperationDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_OperationDef, OperationDef_Helper> OperationDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_OperationDef,OperationDef_Helper > OperationDef_out;

#endif

// interface OperationDef
class OperationDef {
public:
  // Declarations for this interface type.
  typedef OperationDef_ptr _ptr_type;
  typedef OperationDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_OperationDef :
  public virtual _objref_Contained
{
public:
  // IDL operations
  ::CORBA::TypeCode_ptr result();
  IDLType_ptr result_def();
  void result_def(::CORBA::IDLType_ptr _v);
  ParDescriptionSeq* params();
  void params(const ::CORBA::ParDescriptionSeq& _v);
  OperationMode mode();
  void mode(::CORBA::OperationMode _v);
  ContextIdSeq* contexts();
  void contexts(const ::CORBA::ContextIdSeq& _v);
  ExceptionDefSeq* exceptions();
  void exceptions(const ::CORBA::ExceptionDefSeq& _v);

  // Constructors
  inline _objref_OperationDef()  { _PR_setobj(0); }  // nil
  _objref_OperationDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_OperationDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_OperationDef(const _objref_OperationDef&);
  _objref_OperationDef& operator = (const _objref_OperationDef&);
  // not implemented

  friend class OperationDef;
};

class _pof_OperationDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_OperationDef() : _OMNI_NS(proxyObjectFactory)(OperationDef::_PD_repoId) {}
  virtual ~_pof_OperationDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_OperationDef :
  public virtual _impl_Contained
{
public:
  virtual ~_impl_OperationDef();

  virtual ::CORBA::TypeCode_ptr result() = 0;
  virtual IDLType_ptr result_def() = 0;
  virtual void result_def(::CORBA::IDLType_ptr _v) = 0;
  virtual ParDescriptionSeq* params() = 0;
  virtual void params(const ::CORBA::ParDescriptionSeq& _v) = 0;
  virtual OperationMode mode() = 0;
  virtual void mode(::CORBA::OperationMode _v) = 0;
  virtual ContextIdSeq* contexts() = 0;
  virtual void contexts(const ::CORBA::ContextIdSeq& _v) = 0;
  virtual ExceptionDefSeq* exceptions() = 0;
  virtual void exceptions(const ::CORBA::ExceptionDefSeq& _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OperationDef;

struct OperationDescription {
  typedef _CORBA_ConstrType_Variable_Var<OperationDescription> _var_type;

  
  ::CORBA::String_member name;

  ::CORBA::String_member id;

  ::CORBA::String_member defined_in;

  ::CORBA::String_member version;

  ::CORBA::TypeCode_member result;

  OperationMode mode;

  ContextIdSeq contexts;

  ParDescriptionSeq parameters;

  ExcDescriptionSeq exceptions;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef OperationDescription::_var_type OperationDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< OperationDescription,OperationDescription_var > OperationDescription_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OperationDescription;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RepositoryIdSeq;

class RepositoryIdSeq_var;

class RepositoryIdSeq : public _CORBA_Unbounded_Sequence_String {
public:
  typedef RepositoryIdSeq_var _var_type;
  inline RepositoryIdSeq() {}
  inline RepositoryIdSeq(const RepositoryIdSeq& _s)
    : _CORBA_Unbounded_Sequence_String(_s) {}

  inline RepositoryIdSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_String(_max) {}
  inline RepositoryIdSeq(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}



  inline RepositoryIdSeq& operator = (const RepositoryIdSeq& _s) {
    _CORBA_Unbounded_Sequence_String::operator=(_s);
    return *this;
  }
};

class RepositoryIdSeq_out;

class RepositoryIdSeq_var {
public:
  inline RepositoryIdSeq_var() : _pd_seq(0) {}
  inline RepositoryIdSeq_var(RepositoryIdSeq* _s) : _pd_seq(_s) {}
  inline RepositoryIdSeq_var(const RepositoryIdSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new RepositoryIdSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~RepositoryIdSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline RepositoryIdSeq_var& operator = (RepositoryIdSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline RepositoryIdSeq_var& operator = (const RepositoryIdSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new RepositoryIdSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline RepositoryIdSeq* operator -> () { return _pd_seq; }
  inline const RepositoryIdSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator RepositoryIdSeq& () const { return *_pd_seq; }
#else
  inline operator const RepositoryIdSeq& () const { return *_pd_seq; }
  inline operator RepositoryIdSeq& () { return *_pd_seq; }
#endif
    
  inline const RepositoryIdSeq& in() const { return *_pd_seq; }
  inline RepositoryIdSeq&       inout()    { return *_pd_seq; }
  inline RepositoryIdSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline RepositoryIdSeq* _retn() { RepositoryIdSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class RepositoryIdSeq_out;
  
private:
  RepositoryIdSeq* _pd_seq;
};

class RepositoryIdSeq_out {
public:
  inline RepositoryIdSeq_out(RepositoryIdSeq*& _s) : _data(_s) { _data = 0; }
  inline RepositoryIdSeq_out(RepositoryIdSeq_var& _s)
    : _data(_s._pd_seq) { _s = (RepositoryIdSeq*) 0; }
  inline RepositoryIdSeq_out(const RepositoryIdSeq_out& _s) : _data(_s._data) {}
  inline RepositoryIdSeq_out& operator = (const RepositoryIdSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline RepositoryIdSeq_out& operator = (RepositoryIdSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator RepositoryIdSeq*&()  { return _data; }
  inline RepositoryIdSeq*& ptr()       { return _data; }
  inline RepositoryIdSeq* operator->() { return _data; }

  inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  RepositoryIdSeq*& _data;

private:
  RepositoryIdSeq_out();
  RepositoryIdSeq_out& operator=(const RepositoryIdSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OpDescriptionSeq;

class OpDescriptionSeq_var;

class OpDescriptionSeq : public _CORBA_Unbounded_Sequence< OperationDescription >  {
public:
  typedef OpDescriptionSeq_var _var_type;
  inline OpDescriptionSeq() {}
  inline OpDescriptionSeq(const OpDescriptionSeq& _s)
    : _CORBA_Unbounded_Sequence< OperationDescription > (_s) {}

  inline OpDescriptionSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< OperationDescription > (_max) {}
  inline OpDescriptionSeq(_CORBA_ULong _max, _CORBA_ULong _len, OperationDescription* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< OperationDescription > (_max, _len, _val, _rel) {}



  inline OpDescriptionSeq& operator = (const OpDescriptionSeq& _s) {
    _CORBA_Unbounded_Sequence< OperationDescription > ::operator=(_s);
    return *this;
  }
};

class OpDescriptionSeq_out;

class OpDescriptionSeq_var {
public:
  inline OpDescriptionSeq_var() : _pd_seq(0) {}
  inline OpDescriptionSeq_var(OpDescriptionSeq* _s) : _pd_seq(_s) {}
  inline OpDescriptionSeq_var(const OpDescriptionSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new OpDescriptionSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~OpDescriptionSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline OpDescriptionSeq_var& operator = (OpDescriptionSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline OpDescriptionSeq_var& operator = (const OpDescriptionSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new OpDescriptionSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline OperationDescription& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline OpDescriptionSeq* operator -> () { return _pd_seq; }
  inline const OpDescriptionSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator OpDescriptionSeq& () const { return *_pd_seq; }
#else
  inline operator const OpDescriptionSeq& () const { return *_pd_seq; }
  inline operator OpDescriptionSeq& () { return *_pd_seq; }
#endif
    
  inline const OpDescriptionSeq& in() const { return *_pd_seq; }
  inline OpDescriptionSeq&       inout()    { return *_pd_seq; }
  inline OpDescriptionSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline OpDescriptionSeq* _retn() { OpDescriptionSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class OpDescriptionSeq_out;
  
private:
  OpDescriptionSeq* _pd_seq;
};

class OpDescriptionSeq_out {
public:
  inline OpDescriptionSeq_out(OpDescriptionSeq*& _s) : _data(_s) { _data = 0; }
  inline OpDescriptionSeq_out(OpDescriptionSeq_var& _s)
    : _data(_s._pd_seq) { _s = (OpDescriptionSeq*) 0; }
  inline OpDescriptionSeq_out(const OpDescriptionSeq_out& _s) : _data(_s._data) {}
  inline OpDescriptionSeq_out& operator = (const OpDescriptionSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline OpDescriptionSeq_out& operator = (OpDescriptionSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator OpDescriptionSeq*&()  { return _data; }
  inline OpDescriptionSeq*& ptr()       { return _data; }
  inline OpDescriptionSeq* operator->() { return _data; }

  inline OperationDescription& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  OpDescriptionSeq*& _data;

private:
  OpDescriptionSeq_out();
  OpDescriptionSeq_out& operator=(const OpDescriptionSeq_var&);
};

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AttrDescriptionSeq;

class AttrDescriptionSeq_var;

class AttrDescriptionSeq : public _CORBA_Unbounded_Sequence< AttributeDescription >  {
public:
  typedef AttrDescriptionSeq_var _var_type;
  inline AttrDescriptionSeq() {}
  inline AttrDescriptionSeq(const AttrDescriptionSeq& _s)
    : _CORBA_Unbounded_Sequence< AttributeDescription > (_s) {}

  inline AttrDescriptionSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< AttributeDescription > (_max) {}
  inline AttrDescriptionSeq(_CORBA_ULong _max, _CORBA_ULong _len, AttributeDescription* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< AttributeDescription > (_max, _len, _val, _rel) {}



  inline AttrDescriptionSeq& operator = (const AttrDescriptionSeq& _s) {
    _CORBA_Unbounded_Sequence< AttributeDescription > ::operator=(_s);
    return *this;
  }
};

class AttrDescriptionSeq_out;

class AttrDescriptionSeq_var {
public:
  inline AttrDescriptionSeq_var() : _pd_seq(0) {}
  inline AttrDescriptionSeq_var(AttrDescriptionSeq* _s) : _pd_seq(_s) {}
  inline AttrDescriptionSeq_var(const AttrDescriptionSeq_var& _s) {
    if (_s._pd_seq)  _pd_seq = new AttrDescriptionSeq(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~AttrDescriptionSeq_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline AttrDescriptionSeq_var& operator = (AttrDescriptionSeq* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline AttrDescriptionSeq_var& operator = (const AttrDescriptionSeq_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new AttrDescriptionSeq;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline AttributeDescription& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline AttrDescriptionSeq* operator -> () { return _pd_seq; }
  inline const AttrDescriptionSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator AttrDescriptionSeq& () const { return *_pd_seq; }
#else
  inline operator const AttrDescriptionSeq& () const { return *_pd_seq; }
  inline operator AttrDescriptionSeq& () { return *_pd_seq; }
#endif
    
  inline const AttrDescriptionSeq& in() const { return *_pd_seq; }
  inline AttrDescriptionSeq&       inout()    { return *_pd_seq; }
  inline AttrDescriptionSeq*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline AttrDescriptionSeq* _retn() { AttrDescriptionSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class AttrDescriptionSeq_out;
  
private:
  AttrDescriptionSeq* _pd_seq;
};

class AttrDescriptionSeq_out {
public:
  inline AttrDescriptionSeq_out(AttrDescriptionSeq*& _s) : _data(_s) { _data = 0; }
  inline AttrDescriptionSeq_out(AttrDescriptionSeq_var& _s)
    : _data(_s._pd_seq) { _s = (AttrDescriptionSeq*) 0; }
  inline AttrDescriptionSeq_out(const AttrDescriptionSeq_out& _s) : _data(_s._data) {}
  inline AttrDescriptionSeq_out& operator = (const AttrDescriptionSeq_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline AttrDescriptionSeq_out& operator = (AttrDescriptionSeq* _s) {
    _data = _s;
    return *this;
  }
  inline operator AttrDescriptionSeq*&()  { return _data; }
  inline AttrDescriptionSeq*& ptr()       { return _data; }
  inline AttrDescriptionSeq* operator->() { return _data; }

  inline AttributeDescription& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  AttrDescriptionSeq*& _data;

private:
  AttrDescriptionSeq_out();
  AttrDescriptionSeq_out& operator=(const AttrDescriptionSeq_var&);
};

#ifndef __CORBA_mInterfaceDef__
#define __CORBA_mInterfaceDef__
class InterfaceDef;
class _objref_InterfaceDef;
class _impl_InterfaceDef;

typedef _objref_InterfaceDef* InterfaceDef_ptr;
typedef InterfaceDef_ptr InterfaceDefRef;

class InterfaceDef_Helper {
public:
  typedef InterfaceDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_InterfaceDef, InterfaceDef_Helper> InterfaceDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_InterfaceDef,InterfaceDef_Helper > InterfaceDef_out;

#endif

// interface InterfaceDef
class InterfaceDef {
public:
  // Declarations for this interface type.
  typedef InterfaceDef_ptr _ptr_type;
  typedef InterfaceDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  struct FullInterfaceDescription {
    typedef _CORBA_ConstrType_Variable_Var<FullInterfaceDescription> _var_type;

    
    ::CORBA::String_member name;

    ::CORBA::String_member id;

    ::CORBA::String_member defined_in;

    ::CORBA::String_member version;

    OpDescriptionSeq operations;

    AttrDescriptionSeq attributes;

    RepositoryIdSeq base_interfaces;

    ::CORBA::TypeCode_member type;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef FullInterfaceDescription::_var_type FullInterfaceDescription_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< FullInterfaceDescription,FullInterfaceDescription_var > FullInterfaceDescription_out;

  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_FullInterfaceDescription;


};

class _objref_InterfaceDef :
  public virtual _objref_Container,
  public virtual _objref_Contained,
  public virtual _objref_IDLType
{
public:
  // IDL operations
  InterfaceDefSeq* base_interfaces();
  void base_interfaces(const ::CORBA::InterfaceDefSeq& _v);
  ::CORBA::Boolean is_a(const char* interface_id);
  InterfaceDef::FullInterfaceDescription* describe_interface();
  AttributeDef_ptr create_attribute(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr type, ::CORBA::AttributeMode mode);
  OperationDef_ptr create_operation(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr result, ::CORBA::OperationMode mode, const ::CORBA::ParDescriptionSeq& params, const ::CORBA::ExceptionDefSeq& exceptions, const ::CORBA::ContextIdSeq& contexts);

  // Constructors
  inline _objref_InterfaceDef()  { _PR_setobj(0); }  // nil
  _objref_InterfaceDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_InterfaceDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_InterfaceDef(const _objref_InterfaceDef&);
  _objref_InterfaceDef& operator = (const _objref_InterfaceDef&);
  // not implemented

  friend class InterfaceDef;
};

class _pof_InterfaceDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_InterfaceDef() : _OMNI_NS(proxyObjectFactory)(InterfaceDef::_PD_repoId) {}
  virtual ~_pof_InterfaceDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_InterfaceDef :
  public virtual _impl_Container,
  public virtual _impl_Contained,
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_InterfaceDef();

  virtual InterfaceDefSeq* base_interfaces() = 0;
  virtual void base_interfaces(const ::CORBA::InterfaceDefSeq& _v) = 0;
  virtual ::CORBA::Boolean is_a(const char* interface_id) = 0;
  virtual InterfaceDef::FullInterfaceDescription* describe_interface() = 0;
  virtual AttributeDef_ptr create_attribute(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr type, ::CORBA::AttributeMode mode) = 0;
  virtual OperationDef_ptr create_operation(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr result, ::CORBA::OperationMode mode, const ::CORBA::ParDescriptionSeq& params, const ::CORBA::ExceptionDefSeq& exceptions, const ::CORBA::ContextIdSeq& contexts) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InterfaceDef;

struct InterfaceDescription {
  typedef _CORBA_ConstrType_Variable_Var<InterfaceDescription> _var_type;

  
  ::CORBA::String_member name;

  ::CORBA::String_member id;

  ::CORBA::String_member defined_in;

  ::CORBA::String_member version;

  RepositoryIdSeq base_interfaces;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef InterfaceDescription::_var_type InterfaceDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< InterfaceDescription,InterfaceDescription_var > InterfaceDescription_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InterfaceDescription;

#ifndef __CORBA_mValueMemberDef__
#define __CORBA_mValueMemberDef__
class ValueMemberDef;
class _objref_ValueMemberDef;
class _impl_ValueMemberDef;

typedef _objref_ValueMemberDef* ValueMemberDef_ptr;
typedef ValueMemberDef_ptr ValueMemberDefRef;

class ValueMemberDef_Helper {
public:
  typedef ValueMemberDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ValueMemberDef, ValueMemberDef_Helper> ValueMemberDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ValueMemberDef,ValueMemberDef_Helper > ValueMemberDef_out;

#endif

// interface ValueMemberDef
class ValueMemberDef {
public:
  // Declarations for this interface type.
  typedef ValueMemberDef_ptr _ptr_type;
  typedef ValueMemberDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_ValueMemberDef :
  public virtual _objref_Contained
{
public:
  // IDL operations
  ::CORBA::TypeCode_ptr type();
  IDLType_ptr type_def();
  void type_def(::CORBA::IDLType_ptr _v);
  Visibility access();
  void access(::CORBA::Visibility _v);

  // Constructors
  inline _objref_ValueMemberDef()  { _PR_setobj(0); }  // nil
  _objref_ValueMemberDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_ValueMemberDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_ValueMemberDef(const _objref_ValueMemberDef&);
  _objref_ValueMemberDef& operator = (const _objref_ValueMemberDef&);
  // not implemented

  friend class ValueMemberDef;
};

class _pof_ValueMemberDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_ValueMemberDef() : _OMNI_NS(proxyObjectFactory)(ValueMemberDef::_PD_repoId) {}
  virtual ~_pof_ValueMemberDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_ValueMemberDef :
  public virtual _impl_Contained
{
public:
  virtual ~_impl_ValueMemberDef();

  virtual ::CORBA::TypeCode_ptr type() = 0;
  virtual IDLType_ptr type_def() = 0;
  virtual void type_def(::CORBA::IDLType_ptr _v) = 0;
  virtual Visibility access() = 0;
  virtual void access(::CORBA::Visibility _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ValueMemberDef;

#ifndef __CORBA_mValueDef__
#define __CORBA_mValueDef__
class ValueDef;
class _objref_ValueDef;
class _impl_ValueDef;

typedef _objref_ValueDef* ValueDef_ptr;
typedef ValueDef_ptr ValueDefRef;

class ValueDef_Helper {
public:
  typedef ValueDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ValueDef, ValueDef_Helper> ValueDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ValueDef,ValueDef_Helper > ValueDef_out;

#endif

// interface ValueDef
class ValueDef {
public:
  // Declarations for this interface type.
  typedef ValueDef_ptr _ptr_type;
  typedef ValueDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  struct FullValueDescription {
    typedef _CORBA_ConstrType_Variable_Var<FullValueDescription> _var_type;

    
    ::CORBA::String_member name;

    ::CORBA::String_member id;

    ::CORBA::Boolean is_abstract;

    ::CORBA::Boolean is_custom;

    ::CORBA::String_member defined_in;

    ::CORBA::String_member version;

    OpDescriptionSeq operations;

    AttrDescriptionSeq attributes;

    ValueMemberSeq members;

    InitializerSeq initializers;

    RepositoryIdSeq supported_interfaces;

    RepositoryIdSeq abstract_base_values;

    ::CORBA::Boolean is_truncatable;

    ::CORBA::String_member base_value;

    ::CORBA::TypeCode_member type;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef FullValueDescription::_var_type FullValueDescription_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< FullValueDescription,FullValueDescription_var > FullValueDescription_out;

  static _dyn_attr const ::CORBA::TypeCode_ptr _tc_FullValueDescription;


};

class _objref_ValueDef :
  public virtual _objref_Container,
  public virtual _objref_Contained,
  public virtual _objref_IDLType
{
public:
  // IDL operations
  InterfaceDefSeq* supported_interfaces();
  void supported_interfaces(const ::CORBA::InterfaceDefSeq& _v);
  InitializerSeq* initializers();
  void initializers(const ::CORBA::InitializerSeq& _v);
  ValueDef_ptr base_value();
  void base_value(::CORBA::ValueDef_ptr _v);
  ValueDefSeq* abstract_base_values();
  void abstract_base_values(const ::CORBA::ValueDefSeq& _v);
  ::CORBA::Boolean is_abstract();
  void is_abstract(::CORBA::Boolean _v);
  ::CORBA::Boolean is_custom();
  void is_custom(::CORBA::Boolean _v);
  ::CORBA::Boolean is_truncatable();
  void is_truncatable(::CORBA::Boolean _v);
  ::CORBA::Boolean is_a(const char* id);
  ValueDef::FullValueDescription* describe_value();
  ValueMemberDef_ptr create_value_member(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr type, ::CORBA::Visibility access);
  AttributeDef_ptr create_attribute(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr type, ::CORBA::AttributeMode mode);
  OperationDef_ptr create_operation(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr result, ::CORBA::OperationMode mode, const ::CORBA::ParDescriptionSeq& params, const ::CORBA::ExceptionDefSeq& exceptions, const ::CORBA::ContextIdSeq& contexts);

  // Constructors
  inline _objref_ValueDef()  { _PR_setobj(0); }  // nil
  _objref_ValueDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_ValueDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_ValueDef(const _objref_ValueDef&);
  _objref_ValueDef& operator = (const _objref_ValueDef&);
  // not implemented

  friend class ValueDef;
};

class _pof_ValueDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_ValueDef() : _OMNI_NS(proxyObjectFactory)(ValueDef::_PD_repoId) {}
  virtual ~_pof_ValueDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_ValueDef :
  public virtual _impl_Container,
  public virtual _impl_Contained,
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_ValueDef();

  virtual InterfaceDefSeq* supported_interfaces() = 0;
  virtual void supported_interfaces(const ::CORBA::InterfaceDefSeq& _v) = 0;
  virtual InitializerSeq* initializers() = 0;
  virtual void initializers(const ::CORBA::InitializerSeq& _v) = 0;
  virtual ValueDef_ptr base_value() = 0;
  virtual void base_value(::CORBA::ValueDef_ptr _v) = 0;
  virtual ValueDefSeq* abstract_base_values() = 0;
  virtual void abstract_base_values(const ::CORBA::ValueDefSeq& _v) = 0;
  virtual ::CORBA::Boolean is_abstract() = 0;
  virtual void is_abstract(::CORBA::Boolean _v) = 0;
  virtual ::CORBA::Boolean is_custom() = 0;
  virtual void is_custom(::CORBA::Boolean _v) = 0;
  virtual ::CORBA::Boolean is_truncatable() = 0;
  virtual void is_truncatable(::CORBA::Boolean _v) = 0;
  virtual ::CORBA::Boolean is_a(const char* id) = 0;
  virtual ValueDef::FullValueDescription* describe_value() = 0;
  virtual ValueMemberDef_ptr create_value_member(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr type, ::CORBA::Visibility access) = 0;
  virtual AttributeDef_ptr create_attribute(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr type, ::CORBA::AttributeMode mode) = 0;
  virtual OperationDef_ptr create_operation(const char* id, const char* name, const char* version, ::CORBA::IDLType_ptr result, ::CORBA::OperationMode mode, const ::CORBA::ParDescriptionSeq& params, const ::CORBA::ExceptionDefSeq& exceptions, const ::CORBA::ContextIdSeq& contexts) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ValueDef;

struct ValueDescription {
  typedef _CORBA_ConstrType_Variable_Var<ValueDescription> _var_type;

  
  ::CORBA::String_member name;

  ::CORBA::String_member id;

  ::CORBA::Boolean is_abstract;

  ::CORBA::Boolean is_custom;

  ::CORBA::String_member defined_in;

  ::CORBA::String_member version;

  RepositoryIdSeq supported_interfaces;

  RepositoryIdSeq abstract_base_values;

  ::CORBA::Boolean is_truncatable;

  ::CORBA::String_member base_value;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef ValueDescription::_var_type ValueDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< ValueDescription,ValueDescription_var > ValueDescription_out;

_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ValueDescription;

#ifndef __CORBA_mValueBoxDef__
#define __CORBA_mValueBoxDef__
class ValueBoxDef;
class _objref_ValueBoxDef;
class _impl_ValueBoxDef;

typedef _objref_ValueBoxDef* ValueBoxDef_ptr;
typedef ValueBoxDef_ptr ValueBoxDefRef;

class ValueBoxDef_Helper {
public:
  typedef ValueBoxDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ValueBoxDef, ValueBoxDef_Helper> ValueBoxDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ValueBoxDef,ValueBoxDef_Helper > ValueBoxDef_out;

#endif

// interface ValueBoxDef
class ValueBoxDef {
public:
  // Declarations for this interface type.
  typedef ValueBoxDef_ptr _ptr_type;
  typedef ValueBoxDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_ValueBoxDef :
  public virtual _objref_TypedefDef
{
public:
  // IDL operations
  IDLType_ptr original_type_def();
  void original_type_def(::CORBA::IDLType_ptr _v);

  // Constructors
  inline _objref_ValueBoxDef()  { _PR_setobj(0); }  // nil
  _objref_ValueBoxDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_ValueBoxDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_ValueBoxDef(const _objref_ValueBoxDef&);
  _objref_ValueBoxDef& operator = (const _objref_ValueBoxDef&);
  // not implemented

  friend class ValueBoxDef;
};

class _pof_ValueBoxDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_ValueBoxDef() : _OMNI_NS(proxyObjectFactory)(ValueBoxDef::_PD_repoId) {}
  virtual ~_pof_ValueBoxDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_ValueBoxDef :
  public virtual _impl_TypedefDef
{
public:
  virtual ~_impl_ValueBoxDef();

  virtual IDLType_ptr original_type_def() = 0;
  virtual void original_type_def(::CORBA::IDLType_ptr _v) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ValueBoxDef;

#ifndef __CORBA_mAbstractInterfaceDef__
#define __CORBA_mAbstractInterfaceDef__
class AbstractInterfaceDef;
class _objref_AbstractInterfaceDef;
class _impl_AbstractInterfaceDef;

typedef _objref_AbstractInterfaceDef* AbstractInterfaceDef_ptr;
typedef AbstractInterfaceDef_ptr AbstractInterfaceDefRef;

class AbstractInterfaceDef_Helper {
public:
  typedef AbstractInterfaceDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper> AbstractInterfaceDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_AbstractInterfaceDef,AbstractInterfaceDef_Helper > AbstractInterfaceDef_out;

#endif

// interface AbstractInterfaceDef
class AbstractInterfaceDef {
public:
  // Declarations for this interface type.
  typedef AbstractInterfaceDef_ptr _ptr_type;
  typedef AbstractInterfaceDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_AbstractInterfaceDef :
  public virtual _objref_InterfaceDef
{
public:
  // IDL operations
  

  // Constructors
  inline _objref_AbstractInterfaceDef()  { _PR_setobj(0); }  // nil
  _objref_AbstractInterfaceDef(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_AbstractInterfaceDef();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_AbstractInterfaceDef(const _objref_AbstractInterfaceDef&);
  _objref_AbstractInterfaceDef& operator = (const _objref_AbstractInterfaceDef&);
  // not implemented

  friend class AbstractInterfaceDef;
};

class _pof_AbstractInterfaceDef : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_AbstractInterfaceDef() : _OMNI_NS(proxyObjectFactory)(AbstractInterfaceDef::_PD_repoId) {}
  virtual ~_pof_AbstractInterfaceDef();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_AbstractInterfaceDef :
  public virtual _impl_InterfaceDef
{
public:
  virtual ~_impl_AbstractInterfaceDef();

  
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AbstractInterfaceDef;

#endif

