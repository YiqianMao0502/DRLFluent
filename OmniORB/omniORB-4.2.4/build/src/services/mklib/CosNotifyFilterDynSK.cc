// This file is generated by omniidl (C++ backend) - omniORB_4_2. Do not edit.

#include "CosNotifyFilter.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_2_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mConstraintID = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNotifyFilter/ConstraintID:1.0", "ConstraintID", CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_ConstraintID = _0RL_tc_CosNotifyFilter_mConstraintID;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_ConstraintID = _0RL_tc_CosNotifyFilter_mConstraintID;
#endif

static CORBA::PR_structMember _0RL_structmember_CosNotification_mEventType[] = {
  {"domain_name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"type_name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_CosNotification_mEventType
#  undef _0RL_tc_CosNotification_mEventType
#endif
static CORBA::TypeCode_ptr _0RL_tc_CosNotification_mEventType = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CosNotification/EventType:1.0", "EventType", _0RL_structmember_CosNotification_mEventType, 2, &_0RL_tcTrack);

static CORBA::TypeCode_ptr _0RL_tc_CosNotification_mEventTypeSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNotification/EventTypeSeq:1.0", "EventTypeSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CosNotification_mEventType, &_0RL_tcTrack), &_0RL_tcTrack);


static CORBA::PR_structMember _0RL_structmember_CosNotifyFilter_mConstraintExp[] = {
  {"event_types", _0RL_tc_CosNotification_mEventTypeSeq},
  {"constraint_expr", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_CosNotifyFilter_mConstraintExp
#  undef _0RL_tc_CosNotifyFilter_mConstraintExp
#endif
static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mConstraintExp = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CosNotifyFilter/ConstraintExp:1.0", "ConstraintExp", _0RL_structmember_CosNotifyFilter_mConstraintExp, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_ConstraintExp = _0RL_tc_CosNotifyFilter_mConstraintExp;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_ConstraintExp = _0RL_tc_CosNotifyFilter_mConstraintExp;
#endif


static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mConstraintIDSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNotifyFilter/ConstraintIDSeq:1.0", "ConstraintIDSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CosNotifyFilter_mConstraintID, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_ConstraintIDSeq = _0RL_tc_CosNotifyFilter_mConstraintIDSeq;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_ConstraintIDSeq = _0RL_tc_CosNotifyFilter_mConstraintIDSeq;
#endif









static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mConstraintExpSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNotifyFilter/ConstraintExpSeq:1.0", "ConstraintExpSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CosNotifyFilter_mConstraintExp, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_ConstraintExpSeq = _0RL_tc_CosNotifyFilter_mConstraintExpSeq;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_ConstraintExpSeq = _0RL_tc_CosNotifyFilter_mConstraintExpSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_CosNotifyFilter_mConstraintInfo[] = {
  {"constraint_expression", _0RL_tc_CosNotifyFilter_mConstraintExp},
  {"constraint_id", _0RL_tc_CosNotifyFilter_mConstraintID}
};

#ifdef _0RL_tc_CosNotifyFilter_mConstraintInfo
#  undef _0RL_tc_CosNotifyFilter_mConstraintInfo
#endif
static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mConstraintInfo = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CosNotifyFilter/ConstraintInfo:1.0", "ConstraintInfo", _0RL_structmember_CosNotifyFilter_mConstraintInfo, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_ConstraintInfo = _0RL_tc_CosNotifyFilter_mConstraintInfo;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_ConstraintInfo = _0RL_tc_CosNotifyFilter_mConstraintInfo;
#endif














static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mConstraintInfoSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNotifyFilter/ConstraintInfoSeq:1.0", "ConstraintInfoSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CosNotifyFilter_mConstraintInfo, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_ConstraintInfoSeq = _0RL_tc_CosNotifyFilter_mConstraintInfoSeq;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_ConstraintInfoSeq = _0RL_tc_CosNotifyFilter_mConstraintInfoSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_CosNotifyFilter_mMappingConstraintPair[] = {
  {"constraint_expression", _0RL_tc_CosNotifyFilter_mConstraintExp},
  {"result_to_set", CORBA::TypeCode::PR_any_tc()}
};

#ifdef _0RL_tc_CosNotifyFilter_mMappingConstraintPair
#  undef _0RL_tc_CosNotifyFilter_mMappingConstraintPair
#endif
static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mMappingConstraintPair = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CosNotifyFilter/MappingConstraintPair:1.0", "MappingConstraintPair", _0RL_structmember_CosNotifyFilter_mMappingConstraintPair, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_MappingConstraintPair = _0RL_tc_CosNotifyFilter_mMappingConstraintPair;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_MappingConstraintPair = _0RL_tc_CosNotifyFilter_mMappingConstraintPair;
#endif














static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mMappingConstraintPairSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNotifyFilter/MappingConstraintPairSeq:1.0", "MappingConstraintPairSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CosNotifyFilter_mMappingConstraintPair, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_MappingConstraintPairSeq = _0RL_tc_CosNotifyFilter_mMappingConstraintPairSeq;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_MappingConstraintPairSeq = _0RL_tc_CosNotifyFilter_mMappingConstraintPairSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_CosNotifyFilter_mMappingConstraintInfo[] = {
  {"constraint_expression", _0RL_tc_CosNotifyFilter_mConstraintExp},
  {"constraint_id", _0RL_tc_CosNotifyFilter_mConstraintID},
  {"value", CORBA::TypeCode::PR_any_tc()}
};

#ifdef _0RL_tc_CosNotifyFilter_mMappingConstraintInfo
#  undef _0RL_tc_CosNotifyFilter_mMappingConstraintInfo
#endif
static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mMappingConstraintInfo = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CosNotifyFilter/MappingConstraintInfo:1.0", "MappingConstraintInfo", _0RL_structmember_CosNotifyFilter_mMappingConstraintInfo, 3, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_MappingConstraintInfo = _0RL_tc_CosNotifyFilter_mMappingConstraintInfo;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_MappingConstraintInfo = _0RL_tc_CosNotifyFilter_mMappingConstraintInfo;
#endif














static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mMappingConstraintInfoSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNotifyFilter/MappingConstraintInfoSeq:1.0", "MappingConstraintInfoSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CosNotifyFilter_mMappingConstraintInfo, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_MappingConstraintInfoSeq = _0RL_tc_CosNotifyFilter_mMappingConstraintInfoSeq;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_MappingConstraintInfoSeq = _0RL_tc_CosNotifyFilter_mMappingConstraintInfoSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mCallbackID = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNotifyFilter/CallbackID:1.0", "CallbackID", CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_CallbackID = _0RL_tc_CosNotifyFilter_mCallbackID;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_CallbackID = _0RL_tc_CosNotifyFilter_mCallbackID;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mCallbackIDSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNotifyFilter/CallbackIDSeq:1.0", "CallbackIDSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CosNotifyFilter_mCallbackID, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_CallbackIDSeq = _0RL_tc_CosNotifyFilter_mCallbackIDSeq;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_CallbackIDSeq = _0RL_tc_CosNotifyFilter_mCallbackIDSeq;
#endif


static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mUnsupportedFilterableData = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/CosNotifyFilter/UnsupportedFilterableData:1.0", "UnsupportedFilterableData", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_UnsupportedFilterableData = _0RL_tc_CosNotifyFilter_mUnsupportedFilterableData;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_UnsupportedFilterableData = _0RL_tc_CosNotifyFilter_mUnsupportedFilterableData;
#endif



static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mInvalidGrammar = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/CosNotifyFilter/InvalidGrammar:1.0", "InvalidGrammar", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_InvalidGrammar = _0RL_tc_CosNotifyFilter_mInvalidGrammar;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_InvalidGrammar = _0RL_tc_CosNotifyFilter_mInvalidGrammar;
#endif




static CORBA::PR_structMember _0RL_structmember_CosNotifyFilter_mInvalidConstraint[] = {
  {"constr", _0RL_tc_CosNotifyFilter_mConstraintExp}
};

static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mInvalidConstraint = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/CosNotifyFilter/InvalidConstraint:1.0", "InvalidConstraint", _0RL_structmember_CosNotifyFilter_mInvalidConstraint, 1, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_InvalidConstraint = _0RL_tc_CosNotifyFilter_mInvalidConstraint;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_InvalidConstraint = _0RL_tc_CosNotifyFilter_mInvalidConstraint;
#endif


static CORBA::PR_structMember _0RL_structmember_CosNotifyFilter_mDuplicateConstraintID[] = {
  {"id", _0RL_tc_CosNotifyFilter_mConstraintID}
};

static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mDuplicateConstraintID = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/CosNotifyFilter/DuplicateConstraintID:1.0", "DuplicateConstraintID", _0RL_structmember_CosNotifyFilter_mDuplicateConstraintID, 1, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_DuplicateConstraintID = _0RL_tc_CosNotifyFilter_mDuplicateConstraintID;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_DuplicateConstraintID = _0RL_tc_CosNotifyFilter_mDuplicateConstraintID;
#endif


static CORBA::PR_structMember _0RL_structmember_CosNotifyFilter_mConstraintNotFound[] = {
  {"id", _0RL_tc_CosNotifyFilter_mConstraintID}
};

static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mConstraintNotFound = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/CosNotifyFilter/ConstraintNotFound:1.0", "ConstraintNotFound", _0RL_structmember_CosNotifyFilter_mConstraintNotFound, 1, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_ConstraintNotFound = _0RL_tc_CosNotifyFilter_mConstraintNotFound;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_ConstraintNotFound = _0RL_tc_CosNotifyFilter_mConstraintNotFound;
#endif



static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mCallbackNotFound = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/CosNotifyFilter/CallbackNotFound:1.0", "CallbackNotFound", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_CallbackNotFound = _0RL_tc_CosNotifyFilter_mCallbackNotFound;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_CallbackNotFound = _0RL_tc_CosNotifyFilter_mCallbackNotFound;
#endif




static CORBA::PR_structMember _0RL_structmember_CosNotifyFilter_mInvalidValue[] = {
  {"constr", _0RL_tc_CosNotifyFilter_mConstraintExp},
  {"value", CORBA::TypeCode::PR_any_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mInvalidValue = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/CosNotifyFilter/InvalidValue:1.0", "InvalidValue", _0RL_structmember_CosNotifyFilter_mInvalidValue, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_InvalidValue = _0RL_tc_CosNotifyFilter_mInvalidValue;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_InvalidValue = _0RL_tc_CosNotifyFilter_mInvalidValue;
#endif


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_Filter = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNotifyFilter/Filter:1.0", "Filter", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_Filter = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNotifyFilter/Filter:1.0", "Filter", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_MappingFilter = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNotifyFilter/MappingFilter:1.0", "MappingFilter", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_MappingFilter = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNotifyFilter/MappingFilter:1.0", "MappingFilter", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_FilterFactory = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNotifyFilter/FilterFactory:1.0", "FilterFactory", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_FilterFactory = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNotifyFilter/FilterFactory:1.0", "FilterFactory", &_0RL_tcTrack);
#endif

static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mFilterID = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNotifyFilter/FilterID:1.0", "FilterID", CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_FilterID = _0RL_tc_CosNotifyFilter_mFilterID;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_FilterID = _0RL_tc_CosNotifyFilter_mFilterID;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mFilterIDSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNotifyFilter/FilterIDSeq:1.0", "FilterIDSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CosNotifyFilter_mFilterID, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_FilterIDSeq = _0RL_tc_CosNotifyFilter_mFilterIDSeq;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_FilterIDSeq = _0RL_tc_CosNotifyFilter_mFilterIDSeq;
#endif


static CORBA::TypeCode_ptr _0RL_tc_CosNotifyFilter_mFilterNotFound = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/CosNotifyFilter/FilterNotFound:1.0", "FilterNotFound", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_FilterNotFound = _0RL_tc_CosNotifyFilter_mFilterNotFound;
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_FilterNotFound = _0RL_tc_CosNotifyFilter_mFilterNotFound;
#endif


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CosNotifyFilter { 
  const ::CORBA::TypeCode_ptr _tc_FilterAdmin = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNotifyFilter/FilterAdmin:1.0", "FilterAdmin", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CosNotifyFilter::_tc_FilterAdmin = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNotifyFilter/FilterAdmin:1.0", "FilterAdmin", &_0RL_tcTrack);
#endif

static void _0RL_CosNotifyFilter_mConstraintExp_marshal_fn(cdrStream& _s, void* _v)
{
  CosNotifyFilter::ConstraintExp* _p = (CosNotifyFilter::ConstraintExp*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mConstraintExp_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::ConstraintExp* _p = new CosNotifyFilter::ConstraintExp;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mConstraintExp_destructor_fn(void* _v)
{
  CosNotifyFilter::ConstraintExp* _p = (CosNotifyFilter::ConstraintExp*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::ConstraintExp& _s)
{
  CosNotifyFilter::ConstraintExp* _p = new CosNotifyFilter::ConstraintExp(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mConstraintExp,
               _0RL_CosNotifyFilter_mConstraintExp_marshal_fn,
               _0RL_CosNotifyFilter_mConstraintExp_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::ConstraintExp* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mConstraintExp,
               _0RL_CosNotifyFilter_mConstraintExp_marshal_fn,
               _0RL_CosNotifyFilter_mConstraintExp_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::ConstraintExp*& _sp)
{
  return _a >>= (const CosNotifyFilter::ConstraintExp*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::ConstraintExp*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mConstraintExp,
                    _0RL_CosNotifyFilter_mConstraintExp_unmarshal_fn,
                    _0RL_CosNotifyFilter_mConstraintExp_marshal_fn,
                    _0RL_CosNotifyFilter_mConstraintExp_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::ConstraintExp*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CosNotifyFilter_mConstraintIDSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CosNotifyFilter::ConstraintIDSeq* _p = (CosNotifyFilter::ConstraintIDSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mConstraintIDSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::ConstraintIDSeq* _p = new CosNotifyFilter::ConstraintIDSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mConstraintIDSeq_destructor_fn(void* _v)
{
  CosNotifyFilter::ConstraintIDSeq* _p = (CosNotifyFilter::ConstraintIDSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::ConstraintIDSeq& _s)
{
  CosNotifyFilter::ConstraintIDSeq* _p = new CosNotifyFilter::ConstraintIDSeq(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mConstraintIDSeq,
               _0RL_CosNotifyFilter_mConstraintIDSeq_marshal_fn,
               _0RL_CosNotifyFilter_mConstraintIDSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::ConstraintIDSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mConstraintIDSeq,
               _0RL_CosNotifyFilter_mConstraintIDSeq_marshal_fn,
               _0RL_CosNotifyFilter_mConstraintIDSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::ConstraintIDSeq*& _sp)
{
  return _a >>= (const CosNotifyFilter::ConstraintIDSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::ConstraintIDSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mConstraintIDSeq,
                    _0RL_CosNotifyFilter_mConstraintIDSeq_unmarshal_fn,
                    _0RL_CosNotifyFilter_mConstraintIDSeq_marshal_fn,
                    _0RL_CosNotifyFilter_mConstraintIDSeq_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::ConstraintIDSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CosNotifyFilter_mConstraintExpSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CosNotifyFilter::ConstraintExpSeq* _p = (CosNotifyFilter::ConstraintExpSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mConstraintExpSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::ConstraintExpSeq* _p = new CosNotifyFilter::ConstraintExpSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mConstraintExpSeq_destructor_fn(void* _v)
{
  CosNotifyFilter::ConstraintExpSeq* _p = (CosNotifyFilter::ConstraintExpSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::ConstraintExpSeq& _s)
{
  CosNotifyFilter::ConstraintExpSeq* _p = new CosNotifyFilter::ConstraintExpSeq(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mConstraintExpSeq,
               _0RL_CosNotifyFilter_mConstraintExpSeq_marshal_fn,
               _0RL_CosNotifyFilter_mConstraintExpSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::ConstraintExpSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mConstraintExpSeq,
               _0RL_CosNotifyFilter_mConstraintExpSeq_marshal_fn,
               _0RL_CosNotifyFilter_mConstraintExpSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::ConstraintExpSeq*& _sp)
{
  return _a >>= (const CosNotifyFilter::ConstraintExpSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::ConstraintExpSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mConstraintExpSeq,
                    _0RL_CosNotifyFilter_mConstraintExpSeq_unmarshal_fn,
                    _0RL_CosNotifyFilter_mConstraintExpSeq_marshal_fn,
                    _0RL_CosNotifyFilter_mConstraintExpSeq_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::ConstraintExpSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CosNotifyFilter_mConstraintInfo_marshal_fn(cdrStream& _s, void* _v)
{
  CosNotifyFilter::ConstraintInfo* _p = (CosNotifyFilter::ConstraintInfo*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mConstraintInfo_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::ConstraintInfo* _p = new CosNotifyFilter::ConstraintInfo;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mConstraintInfo_destructor_fn(void* _v)
{
  CosNotifyFilter::ConstraintInfo* _p = (CosNotifyFilter::ConstraintInfo*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::ConstraintInfo& _s)
{
  CosNotifyFilter::ConstraintInfo* _p = new CosNotifyFilter::ConstraintInfo(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mConstraintInfo,
               _0RL_CosNotifyFilter_mConstraintInfo_marshal_fn,
               _0RL_CosNotifyFilter_mConstraintInfo_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::ConstraintInfo* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mConstraintInfo,
               _0RL_CosNotifyFilter_mConstraintInfo_marshal_fn,
               _0RL_CosNotifyFilter_mConstraintInfo_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::ConstraintInfo*& _sp)
{
  return _a >>= (const CosNotifyFilter::ConstraintInfo*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::ConstraintInfo*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mConstraintInfo,
                    _0RL_CosNotifyFilter_mConstraintInfo_unmarshal_fn,
                    _0RL_CosNotifyFilter_mConstraintInfo_marshal_fn,
                    _0RL_CosNotifyFilter_mConstraintInfo_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::ConstraintInfo*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CosNotifyFilter_mConstraintInfoSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CosNotifyFilter::ConstraintInfoSeq* _p = (CosNotifyFilter::ConstraintInfoSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mConstraintInfoSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::ConstraintInfoSeq* _p = new CosNotifyFilter::ConstraintInfoSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mConstraintInfoSeq_destructor_fn(void* _v)
{
  CosNotifyFilter::ConstraintInfoSeq* _p = (CosNotifyFilter::ConstraintInfoSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::ConstraintInfoSeq& _s)
{
  CosNotifyFilter::ConstraintInfoSeq* _p = new CosNotifyFilter::ConstraintInfoSeq(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mConstraintInfoSeq,
               _0RL_CosNotifyFilter_mConstraintInfoSeq_marshal_fn,
               _0RL_CosNotifyFilter_mConstraintInfoSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::ConstraintInfoSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mConstraintInfoSeq,
               _0RL_CosNotifyFilter_mConstraintInfoSeq_marshal_fn,
               _0RL_CosNotifyFilter_mConstraintInfoSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::ConstraintInfoSeq*& _sp)
{
  return _a >>= (const CosNotifyFilter::ConstraintInfoSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::ConstraintInfoSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mConstraintInfoSeq,
                    _0RL_CosNotifyFilter_mConstraintInfoSeq_unmarshal_fn,
                    _0RL_CosNotifyFilter_mConstraintInfoSeq_marshal_fn,
                    _0RL_CosNotifyFilter_mConstraintInfoSeq_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::ConstraintInfoSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CosNotifyFilter_mMappingConstraintPair_marshal_fn(cdrStream& _s, void* _v)
{
  CosNotifyFilter::MappingConstraintPair* _p = (CosNotifyFilter::MappingConstraintPair*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mMappingConstraintPair_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::MappingConstraintPair* _p = new CosNotifyFilter::MappingConstraintPair;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mMappingConstraintPair_destructor_fn(void* _v)
{
  CosNotifyFilter::MappingConstraintPair* _p = (CosNotifyFilter::MappingConstraintPair*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintPair& _s)
{
  CosNotifyFilter::MappingConstraintPair* _p = new CosNotifyFilter::MappingConstraintPair(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mMappingConstraintPair,
               _0RL_CosNotifyFilter_mMappingConstraintPair_marshal_fn,
               _0RL_CosNotifyFilter_mMappingConstraintPair_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::MappingConstraintPair* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mMappingConstraintPair,
               _0RL_CosNotifyFilter_mMappingConstraintPair_marshal_fn,
               _0RL_CosNotifyFilter_mMappingConstraintPair_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::MappingConstraintPair*& _sp)
{
  return _a >>= (const CosNotifyFilter::MappingConstraintPair*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintPair*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mMappingConstraintPair,
                    _0RL_CosNotifyFilter_mMappingConstraintPair_unmarshal_fn,
                    _0RL_CosNotifyFilter_mMappingConstraintPair_marshal_fn,
                    _0RL_CosNotifyFilter_mMappingConstraintPair_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::MappingConstraintPair*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CosNotifyFilter_mMappingConstraintPairSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CosNotifyFilter::MappingConstraintPairSeq* _p = (CosNotifyFilter::MappingConstraintPairSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mMappingConstraintPairSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::MappingConstraintPairSeq* _p = new CosNotifyFilter::MappingConstraintPairSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mMappingConstraintPairSeq_destructor_fn(void* _v)
{
  CosNotifyFilter::MappingConstraintPairSeq* _p = (CosNotifyFilter::MappingConstraintPairSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintPairSeq& _s)
{
  CosNotifyFilter::MappingConstraintPairSeq* _p = new CosNotifyFilter::MappingConstraintPairSeq(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mMappingConstraintPairSeq,
               _0RL_CosNotifyFilter_mMappingConstraintPairSeq_marshal_fn,
               _0RL_CosNotifyFilter_mMappingConstraintPairSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::MappingConstraintPairSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mMappingConstraintPairSeq,
               _0RL_CosNotifyFilter_mMappingConstraintPairSeq_marshal_fn,
               _0RL_CosNotifyFilter_mMappingConstraintPairSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::MappingConstraintPairSeq*& _sp)
{
  return _a >>= (const CosNotifyFilter::MappingConstraintPairSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintPairSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mMappingConstraintPairSeq,
                    _0RL_CosNotifyFilter_mMappingConstraintPairSeq_unmarshal_fn,
                    _0RL_CosNotifyFilter_mMappingConstraintPairSeq_marshal_fn,
                    _0RL_CosNotifyFilter_mMappingConstraintPairSeq_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::MappingConstraintPairSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CosNotifyFilter_mMappingConstraintInfo_marshal_fn(cdrStream& _s, void* _v)
{
  CosNotifyFilter::MappingConstraintInfo* _p = (CosNotifyFilter::MappingConstraintInfo*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mMappingConstraintInfo_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::MappingConstraintInfo* _p = new CosNotifyFilter::MappingConstraintInfo;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mMappingConstraintInfo_destructor_fn(void* _v)
{
  CosNotifyFilter::MappingConstraintInfo* _p = (CosNotifyFilter::MappingConstraintInfo*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintInfo& _s)
{
  CosNotifyFilter::MappingConstraintInfo* _p = new CosNotifyFilter::MappingConstraintInfo(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mMappingConstraintInfo,
               _0RL_CosNotifyFilter_mMappingConstraintInfo_marshal_fn,
               _0RL_CosNotifyFilter_mMappingConstraintInfo_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::MappingConstraintInfo* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mMappingConstraintInfo,
               _0RL_CosNotifyFilter_mMappingConstraintInfo_marshal_fn,
               _0RL_CosNotifyFilter_mMappingConstraintInfo_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::MappingConstraintInfo*& _sp)
{
  return _a >>= (const CosNotifyFilter::MappingConstraintInfo*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintInfo*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mMappingConstraintInfo,
                    _0RL_CosNotifyFilter_mMappingConstraintInfo_unmarshal_fn,
                    _0RL_CosNotifyFilter_mMappingConstraintInfo_marshal_fn,
                    _0RL_CosNotifyFilter_mMappingConstraintInfo_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::MappingConstraintInfo*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CosNotifyFilter_mMappingConstraintInfoSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CosNotifyFilter::MappingConstraintInfoSeq* _p = (CosNotifyFilter::MappingConstraintInfoSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mMappingConstraintInfoSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::MappingConstraintInfoSeq* _p = new CosNotifyFilter::MappingConstraintInfoSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mMappingConstraintInfoSeq_destructor_fn(void* _v)
{
  CosNotifyFilter::MappingConstraintInfoSeq* _p = (CosNotifyFilter::MappingConstraintInfoSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintInfoSeq& _s)
{
  CosNotifyFilter::MappingConstraintInfoSeq* _p = new CosNotifyFilter::MappingConstraintInfoSeq(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mMappingConstraintInfoSeq,
               _0RL_CosNotifyFilter_mMappingConstraintInfoSeq_marshal_fn,
               _0RL_CosNotifyFilter_mMappingConstraintInfoSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::MappingConstraintInfoSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mMappingConstraintInfoSeq,
               _0RL_CosNotifyFilter_mMappingConstraintInfoSeq_marshal_fn,
               _0RL_CosNotifyFilter_mMappingConstraintInfoSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::MappingConstraintInfoSeq*& _sp)
{
  return _a >>= (const CosNotifyFilter::MappingConstraintInfoSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::MappingConstraintInfoSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mMappingConstraintInfoSeq,
                    _0RL_CosNotifyFilter_mMappingConstraintInfoSeq_unmarshal_fn,
                    _0RL_CosNotifyFilter_mMappingConstraintInfoSeq_marshal_fn,
                    _0RL_CosNotifyFilter_mMappingConstraintInfoSeq_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::MappingConstraintInfoSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CosNotifyFilter_mCallbackIDSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CosNotifyFilter::CallbackIDSeq* _p = (CosNotifyFilter::CallbackIDSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mCallbackIDSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::CallbackIDSeq* _p = new CosNotifyFilter::CallbackIDSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mCallbackIDSeq_destructor_fn(void* _v)
{
  CosNotifyFilter::CallbackIDSeq* _p = (CosNotifyFilter::CallbackIDSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::CallbackIDSeq& _s)
{
  CosNotifyFilter::CallbackIDSeq* _p = new CosNotifyFilter::CallbackIDSeq(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mCallbackIDSeq,
               _0RL_CosNotifyFilter_mCallbackIDSeq_marshal_fn,
               _0RL_CosNotifyFilter_mCallbackIDSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::CallbackIDSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mCallbackIDSeq,
               _0RL_CosNotifyFilter_mCallbackIDSeq_marshal_fn,
               _0RL_CosNotifyFilter_mCallbackIDSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::CallbackIDSeq*& _sp)
{
  return _a >>= (const CosNotifyFilter::CallbackIDSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::CallbackIDSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mCallbackIDSeq,
                    _0RL_CosNotifyFilter_mCallbackIDSeq_unmarshal_fn,
                    _0RL_CosNotifyFilter_mCallbackIDSeq_marshal_fn,
                    _0RL_CosNotifyFilter_mCallbackIDSeq_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::CallbackIDSeq*)_v;
    return 1;
  }
  return 0;
}


static void _0RL_CosNotifyFilter_mUnsupportedFilterableData_marshal_fn(cdrStream& _s, void* _v)
{
  const CosNotifyFilter::UnsupportedFilterableData* _p = (const CosNotifyFilter::UnsupportedFilterableData*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mUnsupportedFilterableData_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::UnsupportedFilterableData* _p = new CosNotifyFilter::UnsupportedFilterableData;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mUnsupportedFilterableData_destructor_fn(void* _v)
{
  CosNotifyFilter::UnsupportedFilterableData* _p = (CosNotifyFilter::UnsupportedFilterableData*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::UnsupportedFilterableData& _s)
{
  CosNotifyFilter::UnsupportedFilterableData* _p = new CosNotifyFilter::UnsupportedFilterableData(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mUnsupportedFilterableData,
               _0RL_CosNotifyFilter_mUnsupportedFilterableData_marshal_fn,
               _0RL_CosNotifyFilter_mUnsupportedFilterableData_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::UnsupportedFilterableData* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mUnsupportedFilterableData,
               _0RL_CosNotifyFilter_mUnsupportedFilterableData_marshal_fn,
               _0RL_CosNotifyFilter_mUnsupportedFilterableData_destructor_fn,
               (CosNotifyFilter::UnsupportedFilterableData*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::UnsupportedFilterableData*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mUnsupportedFilterableData,
                    _0RL_CosNotifyFilter_mUnsupportedFilterableData_unmarshal_fn,
                    _0RL_CosNotifyFilter_mUnsupportedFilterableData_marshal_fn,
                    _0RL_CosNotifyFilter_mUnsupportedFilterableData_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::UnsupportedFilterableData*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCosNotifyFilter_mUnsupportedFilterableData(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CosNotifyFilter::UnsupportedFilterableData & _ex = (const CosNotifyFilter::UnsupportedFilterableData &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCosNotifyFilter_mUnsupportedFilterableData (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CosNotifyFilter::UnsupportedFilterableData* _ex = (const CosNotifyFilter::UnsupportedFilterableData*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCosNotifyFilter_mUnsupportedFilterableData {
public:
  _0RL_insertToAny_Singleton__cCosNotifyFilter_mUnsupportedFilterableData() {
    CosNotifyFilter::UnsupportedFilterableData::insertToAnyFn = _0RL_insertToAny__cCosNotifyFilter_mUnsupportedFilterableData;
    CosNotifyFilter::UnsupportedFilterableData::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCosNotifyFilter_mUnsupportedFilterableData;
  }
};
static _0RL_insertToAny_Singleton__cCosNotifyFilter_mUnsupportedFilterableData _0RL_insertToAny_Singleton__cCosNotifyFilter_mUnsupportedFilterableData_;


static void _0RL_CosNotifyFilter_mInvalidGrammar_marshal_fn(cdrStream& _s, void* _v)
{
  const CosNotifyFilter::InvalidGrammar* _p = (const CosNotifyFilter::InvalidGrammar*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mInvalidGrammar_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::InvalidGrammar* _p = new CosNotifyFilter::InvalidGrammar;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mInvalidGrammar_destructor_fn(void* _v)
{
  CosNotifyFilter::InvalidGrammar* _p = (CosNotifyFilter::InvalidGrammar*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::InvalidGrammar& _s)
{
  CosNotifyFilter::InvalidGrammar* _p = new CosNotifyFilter::InvalidGrammar(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mInvalidGrammar,
               _0RL_CosNotifyFilter_mInvalidGrammar_marshal_fn,
               _0RL_CosNotifyFilter_mInvalidGrammar_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::InvalidGrammar* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mInvalidGrammar,
               _0RL_CosNotifyFilter_mInvalidGrammar_marshal_fn,
               _0RL_CosNotifyFilter_mInvalidGrammar_destructor_fn,
               (CosNotifyFilter::InvalidGrammar*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::InvalidGrammar*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mInvalidGrammar,
                    _0RL_CosNotifyFilter_mInvalidGrammar_unmarshal_fn,
                    _0RL_CosNotifyFilter_mInvalidGrammar_marshal_fn,
                    _0RL_CosNotifyFilter_mInvalidGrammar_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::InvalidGrammar*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCosNotifyFilter_mInvalidGrammar(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CosNotifyFilter::InvalidGrammar & _ex = (const CosNotifyFilter::InvalidGrammar &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCosNotifyFilter_mInvalidGrammar (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CosNotifyFilter::InvalidGrammar* _ex = (const CosNotifyFilter::InvalidGrammar*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCosNotifyFilter_mInvalidGrammar {
public:
  _0RL_insertToAny_Singleton__cCosNotifyFilter_mInvalidGrammar() {
    CosNotifyFilter::InvalidGrammar::insertToAnyFn = _0RL_insertToAny__cCosNotifyFilter_mInvalidGrammar;
    CosNotifyFilter::InvalidGrammar::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCosNotifyFilter_mInvalidGrammar;
  }
};
static _0RL_insertToAny_Singleton__cCosNotifyFilter_mInvalidGrammar _0RL_insertToAny_Singleton__cCosNotifyFilter_mInvalidGrammar_;


static void _0RL_CosNotifyFilter_mInvalidConstraint_marshal_fn(cdrStream& _s, void* _v)
{
  const CosNotifyFilter::InvalidConstraint* _p = (const CosNotifyFilter::InvalidConstraint*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mInvalidConstraint_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::InvalidConstraint* _p = new CosNotifyFilter::InvalidConstraint;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mInvalidConstraint_destructor_fn(void* _v)
{
  CosNotifyFilter::InvalidConstraint* _p = (CosNotifyFilter::InvalidConstraint*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::InvalidConstraint& _s)
{
  CosNotifyFilter::InvalidConstraint* _p = new CosNotifyFilter::InvalidConstraint(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mInvalidConstraint,
               _0RL_CosNotifyFilter_mInvalidConstraint_marshal_fn,
               _0RL_CosNotifyFilter_mInvalidConstraint_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::InvalidConstraint* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mInvalidConstraint,
               _0RL_CosNotifyFilter_mInvalidConstraint_marshal_fn,
               _0RL_CosNotifyFilter_mInvalidConstraint_destructor_fn,
               (CosNotifyFilter::InvalidConstraint*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::InvalidConstraint*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mInvalidConstraint,
                    _0RL_CosNotifyFilter_mInvalidConstraint_unmarshal_fn,
                    _0RL_CosNotifyFilter_mInvalidConstraint_marshal_fn,
                    _0RL_CosNotifyFilter_mInvalidConstraint_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::InvalidConstraint*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCosNotifyFilter_mInvalidConstraint(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CosNotifyFilter::InvalidConstraint & _ex = (const CosNotifyFilter::InvalidConstraint &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCosNotifyFilter_mInvalidConstraint (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CosNotifyFilter::InvalidConstraint* _ex = (const CosNotifyFilter::InvalidConstraint*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCosNotifyFilter_mInvalidConstraint {
public:
  _0RL_insertToAny_Singleton__cCosNotifyFilter_mInvalidConstraint() {
    CosNotifyFilter::InvalidConstraint::insertToAnyFn = _0RL_insertToAny__cCosNotifyFilter_mInvalidConstraint;
    CosNotifyFilter::InvalidConstraint::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCosNotifyFilter_mInvalidConstraint;
  }
};
static _0RL_insertToAny_Singleton__cCosNotifyFilter_mInvalidConstraint _0RL_insertToAny_Singleton__cCosNotifyFilter_mInvalidConstraint_;


static void _0RL_CosNotifyFilter_mDuplicateConstraintID_marshal_fn(cdrStream& _s, void* _v)
{
  const CosNotifyFilter::DuplicateConstraintID* _p = (const CosNotifyFilter::DuplicateConstraintID*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mDuplicateConstraintID_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::DuplicateConstraintID* _p = new CosNotifyFilter::DuplicateConstraintID;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mDuplicateConstraintID_destructor_fn(void* _v)
{
  CosNotifyFilter::DuplicateConstraintID* _p = (CosNotifyFilter::DuplicateConstraintID*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::DuplicateConstraintID& _s)
{
  CosNotifyFilter::DuplicateConstraintID* _p = new CosNotifyFilter::DuplicateConstraintID(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mDuplicateConstraintID,
               _0RL_CosNotifyFilter_mDuplicateConstraintID_marshal_fn,
               _0RL_CosNotifyFilter_mDuplicateConstraintID_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::DuplicateConstraintID* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mDuplicateConstraintID,
               _0RL_CosNotifyFilter_mDuplicateConstraintID_marshal_fn,
               _0RL_CosNotifyFilter_mDuplicateConstraintID_destructor_fn,
               (CosNotifyFilter::DuplicateConstraintID*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::DuplicateConstraintID*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mDuplicateConstraintID,
                    _0RL_CosNotifyFilter_mDuplicateConstraintID_unmarshal_fn,
                    _0RL_CosNotifyFilter_mDuplicateConstraintID_marshal_fn,
                    _0RL_CosNotifyFilter_mDuplicateConstraintID_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::DuplicateConstraintID*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCosNotifyFilter_mDuplicateConstraintID(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CosNotifyFilter::DuplicateConstraintID & _ex = (const CosNotifyFilter::DuplicateConstraintID &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCosNotifyFilter_mDuplicateConstraintID (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CosNotifyFilter::DuplicateConstraintID* _ex = (const CosNotifyFilter::DuplicateConstraintID*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCosNotifyFilter_mDuplicateConstraintID {
public:
  _0RL_insertToAny_Singleton__cCosNotifyFilter_mDuplicateConstraintID() {
    CosNotifyFilter::DuplicateConstraintID::insertToAnyFn = _0RL_insertToAny__cCosNotifyFilter_mDuplicateConstraintID;
    CosNotifyFilter::DuplicateConstraintID::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCosNotifyFilter_mDuplicateConstraintID;
  }
};
static _0RL_insertToAny_Singleton__cCosNotifyFilter_mDuplicateConstraintID _0RL_insertToAny_Singleton__cCosNotifyFilter_mDuplicateConstraintID_;


static void _0RL_CosNotifyFilter_mConstraintNotFound_marshal_fn(cdrStream& _s, void* _v)
{
  const CosNotifyFilter::ConstraintNotFound* _p = (const CosNotifyFilter::ConstraintNotFound*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mConstraintNotFound_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::ConstraintNotFound* _p = new CosNotifyFilter::ConstraintNotFound;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mConstraintNotFound_destructor_fn(void* _v)
{
  CosNotifyFilter::ConstraintNotFound* _p = (CosNotifyFilter::ConstraintNotFound*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::ConstraintNotFound& _s)
{
  CosNotifyFilter::ConstraintNotFound* _p = new CosNotifyFilter::ConstraintNotFound(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mConstraintNotFound,
               _0RL_CosNotifyFilter_mConstraintNotFound_marshal_fn,
               _0RL_CosNotifyFilter_mConstraintNotFound_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::ConstraintNotFound* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mConstraintNotFound,
               _0RL_CosNotifyFilter_mConstraintNotFound_marshal_fn,
               _0RL_CosNotifyFilter_mConstraintNotFound_destructor_fn,
               (CosNotifyFilter::ConstraintNotFound*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::ConstraintNotFound*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mConstraintNotFound,
                    _0RL_CosNotifyFilter_mConstraintNotFound_unmarshal_fn,
                    _0RL_CosNotifyFilter_mConstraintNotFound_marshal_fn,
                    _0RL_CosNotifyFilter_mConstraintNotFound_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::ConstraintNotFound*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCosNotifyFilter_mConstraintNotFound(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CosNotifyFilter::ConstraintNotFound & _ex = (const CosNotifyFilter::ConstraintNotFound &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCosNotifyFilter_mConstraintNotFound (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CosNotifyFilter::ConstraintNotFound* _ex = (const CosNotifyFilter::ConstraintNotFound*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCosNotifyFilter_mConstraintNotFound {
public:
  _0RL_insertToAny_Singleton__cCosNotifyFilter_mConstraintNotFound() {
    CosNotifyFilter::ConstraintNotFound::insertToAnyFn = _0RL_insertToAny__cCosNotifyFilter_mConstraintNotFound;
    CosNotifyFilter::ConstraintNotFound::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCosNotifyFilter_mConstraintNotFound;
  }
};
static _0RL_insertToAny_Singleton__cCosNotifyFilter_mConstraintNotFound _0RL_insertToAny_Singleton__cCosNotifyFilter_mConstraintNotFound_;


static void _0RL_CosNotifyFilter_mCallbackNotFound_marshal_fn(cdrStream& _s, void* _v)
{
  const CosNotifyFilter::CallbackNotFound* _p = (const CosNotifyFilter::CallbackNotFound*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mCallbackNotFound_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::CallbackNotFound* _p = new CosNotifyFilter::CallbackNotFound;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mCallbackNotFound_destructor_fn(void* _v)
{
  CosNotifyFilter::CallbackNotFound* _p = (CosNotifyFilter::CallbackNotFound*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::CallbackNotFound& _s)
{
  CosNotifyFilter::CallbackNotFound* _p = new CosNotifyFilter::CallbackNotFound(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mCallbackNotFound,
               _0RL_CosNotifyFilter_mCallbackNotFound_marshal_fn,
               _0RL_CosNotifyFilter_mCallbackNotFound_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::CallbackNotFound* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mCallbackNotFound,
               _0RL_CosNotifyFilter_mCallbackNotFound_marshal_fn,
               _0RL_CosNotifyFilter_mCallbackNotFound_destructor_fn,
               (CosNotifyFilter::CallbackNotFound*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::CallbackNotFound*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mCallbackNotFound,
                    _0RL_CosNotifyFilter_mCallbackNotFound_unmarshal_fn,
                    _0RL_CosNotifyFilter_mCallbackNotFound_marshal_fn,
                    _0RL_CosNotifyFilter_mCallbackNotFound_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::CallbackNotFound*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCosNotifyFilter_mCallbackNotFound(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CosNotifyFilter::CallbackNotFound & _ex = (const CosNotifyFilter::CallbackNotFound &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCosNotifyFilter_mCallbackNotFound (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CosNotifyFilter::CallbackNotFound* _ex = (const CosNotifyFilter::CallbackNotFound*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCosNotifyFilter_mCallbackNotFound {
public:
  _0RL_insertToAny_Singleton__cCosNotifyFilter_mCallbackNotFound() {
    CosNotifyFilter::CallbackNotFound::insertToAnyFn = _0RL_insertToAny__cCosNotifyFilter_mCallbackNotFound;
    CosNotifyFilter::CallbackNotFound::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCosNotifyFilter_mCallbackNotFound;
  }
};
static _0RL_insertToAny_Singleton__cCosNotifyFilter_mCallbackNotFound _0RL_insertToAny_Singleton__cCosNotifyFilter_mCallbackNotFound_;


static void _0RL_CosNotifyFilter_mInvalidValue_marshal_fn(cdrStream& _s, void* _v)
{
  const CosNotifyFilter::InvalidValue* _p = (const CosNotifyFilter::InvalidValue*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mInvalidValue_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::InvalidValue* _p = new CosNotifyFilter::InvalidValue;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mInvalidValue_destructor_fn(void* _v)
{
  CosNotifyFilter::InvalidValue* _p = (CosNotifyFilter::InvalidValue*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::InvalidValue& _s)
{
  CosNotifyFilter::InvalidValue* _p = new CosNotifyFilter::InvalidValue(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mInvalidValue,
               _0RL_CosNotifyFilter_mInvalidValue_marshal_fn,
               _0RL_CosNotifyFilter_mInvalidValue_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::InvalidValue* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mInvalidValue,
               _0RL_CosNotifyFilter_mInvalidValue_marshal_fn,
               _0RL_CosNotifyFilter_mInvalidValue_destructor_fn,
               (CosNotifyFilter::InvalidValue*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::InvalidValue*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mInvalidValue,
                    _0RL_CosNotifyFilter_mInvalidValue_unmarshal_fn,
                    _0RL_CosNotifyFilter_mInvalidValue_marshal_fn,
                    _0RL_CosNotifyFilter_mInvalidValue_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::InvalidValue*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCosNotifyFilter_mInvalidValue(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CosNotifyFilter::InvalidValue & _ex = (const CosNotifyFilter::InvalidValue &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCosNotifyFilter_mInvalidValue (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CosNotifyFilter::InvalidValue* _ex = (const CosNotifyFilter::InvalidValue*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCosNotifyFilter_mInvalidValue {
public:
  _0RL_insertToAny_Singleton__cCosNotifyFilter_mInvalidValue() {
    CosNotifyFilter::InvalidValue::insertToAnyFn = _0RL_insertToAny__cCosNotifyFilter_mInvalidValue;
    CosNotifyFilter::InvalidValue::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCosNotifyFilter_mInvalidValue;
  }
};
static _0RL_insertToAny_Singleton__cCosNotifyFilter_mInvalidValue _0RL_insertToAny_Singleton__cCosNotifyFilter_mInvalidValue_;

static void _0RL_CosNotifyFilter_mFilter_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CosNotifyFilter_mFilter_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CosNotifyFilter::Filter::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CosNotifyFilter_mFilter_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CosNotifyFilter::Filter_ptr _o)
{
  CosNotifyFilter::Filter_ptr _no = CosNotifyFilter::Filter::_duplicate(_o);
  _a.PR_insert(CosNotifyFilter::_tc_Filter,
               _0RL_CosNotifyFilter_mFilter_marshal_fn,
               _0RL_CosNotifyFilter_mFilter_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::Filter_ptr* _op)
{
  _a.PR_insert(CosNotifyFilter::_tc_Filter,
               _0RL_CosNotifyFilter_mFilter_marshal_fn,
               _0RL_CosNotifyFilter_mFilter_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CosNotifyFilter::Filter::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::Filter_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CosNotifyFilter::_tc_Filter,
                    _0RL_CosNotifyFilter_mFilter_unmarshal_fn,
                    _0RL_CosNotifyFilter_mFilter_marshal_fn,
                    _0RL_CosNotifyFilter_mFilter_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CosNotifyFilter::Filter_ptr)_r->_ptrToObjRef(CosNotifyFilter::Filter::_PD_repoId);
    else
      _o = CosNotifyFilter::Filter::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CosNotifyFilter_mMappingFilter_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CosNotifyFilter_mMappingFilter_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CosNotifyFilter::MappingFilter::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CosNotifyFilter_mMappingFilter_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CosNotifyFilter::MappingFilter_ptr _o)
{
  CosNotifyFilter::MappingFilter_ptr _no = CosNotifyFilter::MappingFilter::_duplicate(_o);
  _a.PR_insert(CosNotifyFilter::_tc_MappingFilter,
               _0RL_CosNotifyFilter_mMappingFilter_marshal_fn,
               _0RL_CosNotifyFilter_mMappingFilter_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::MappingFilter_ptr* _op)
{
  _a.PR_insert(CosNotifyFilter::_tc_MappingFilter,
               _0RL_CosNotifyFilter_mMappingFilter_marshal_fn,
               _0RL_CosNotifyFilter_mMappingFilter_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CosNotifyFilter::MappingFilter::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::MappingFilter_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CosNotifyFilter::_tc_MappingFilter,
                    _0RL_CosNotifyFilter_mMappingFilter_unmarshal_fn,
                    _0RL_CosNotifyFilter_mMappingFilter_marshal_fn,
                    _0RL_CosNotifyFilter_mMappingFilter_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CosNotifyFilter::MappingFilter_ptr)_r->_ptrToObjRef(CosNotifyFilter::MappingFilter::_PD_repoId);
    else
      _o = CosNotifyFilter::MappingFilter::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CosNotifyFilter_mFilterFactory_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CosNotifyFilter_mFilterFactory_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CosNotifyFilter::FilterFactory::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CosNotifyFilter_mFilterFactory_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CosNotifyFilter::FilterFactory_ptr _o)
{
  CosNotifyFilter::FilterFactory_ptr _no = CosNotifyFilter::FilterFactory::_duplicate(_o);
  _a.PR_insert(CosNotifyFilter::_tc_FilterFactory,
               _0RL_CosNotifyFilter_mFilterFactory_marshal_fn,
               _0RL_CosNotifyFilter_mFilterFactory_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::FilterFactory_ptr* _op)
{
  _a.PR_insert(CosNotifyFilter::_tc_FilterFactory,
               _0RL_CosNotifyFilter_mFilterFactory_marshal_fn,
               _0RL_CosNotifyFilter_mFilterFactory_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CosNotifyFilter::FilterFactory::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::FilterFactory_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CosNotifyFilter::_tc_FilterFactory,
                    _0RL_CosNotifyFilter_mFilterFactory_unmarshal_fn,
                    _0RL_CosNotifyFilter_mFilterFactory_marshal_fn,
                    _0RL_CosNotifyFilter_mFilterFactory_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CosNotifyFilter::FilterFactory_ptr)_r->_ptrToObjRef(CosNotifyFilter::FilterFactory::_PD_repoId);
    else
      _o = CosNotifyFilter::FilterFactory::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CosNotifyFilter_mFilterIDSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CosNotifyFilter::FilterIDSeq* _p = (CosNotifyFilter::FilterIDSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mFilterIDSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::FilterIDSeq* _p = new CosNotifyFilter::FilterIDSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mFilterIDSeq_destructor_fn(void* _v)
{
  CosNotifyFilter::FilterIDSeq* _p = (CosNotifyFilter::FilterIDSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::FilterIDSeq& _s)
{
  CosNotifyFilter::FilterIDSeq* _p = new CosNotifyFilter::FilterIDSeq(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mFilterIDSeq,
               _0RL_CosNotifyFilter_mFilterIDSeq_marshal_fn,
               _0RL_CosNotifyFilter_mFilterIDSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::FilterIDSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mFilterIDSeq,
               _0RL_CosNotifyFilter_mFilterIDSeq_marshal_fn,
               _0RL_CosNotifyFilter_mFilterIDSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::FilterIDSeq*& _sp)
{
  return _a >>= (const CosNotifyFilter::FilterIDSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::FilterIDSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mFilterIDSeq,
                    _0RL_CosNotifyFilter_mFilterIDSeq_unmarshal_fn,
                    _0RL_CosNotifyFilter_mFilterIDSeq_marshal_fn,
                    _0RL_CosNotifyFilter_mFilterIDSeq_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::FilterIDSeq*)_v;
    return 1;
  }
  return 0;
}


static void _0RL_CosNotifyFilter_mFilterNotFound_marshal_fn(cdrStream& _s, void* _v)
{
  const CosNotifyFilter::FilterNotFound* _p = (const CosNotifyFilter::FilterNotFound*)_v;
  *_p >>= _s;
}
static void _0RL_CosNotifyFilter_mFilterNotFound_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CosNotifyFilter::FilterNotFound* _p = new CosNotifyFilter::FilterNotFound;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CosNotifyFilter_mFilterNotFound_destructor_fn(void* _v)
{
  CosNotifyFilter::FilterNotFound* _p = (CosNotifyFilter::FilterNotFound*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::FilterNotFound& _s)
{
  CosNotifyFilter::FilterNotFound* _p = new CosNotifyFilter::FilterNotFound(_s);
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mFilterNotFound,
               _0RL_CosNotifyFilter_mFilterNotFound_marshal_fn,
               _0RL_CosNotifyFilter_mFilterNotFound_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CosNotifyFilter::FilterNotFound* _sp)
{
  _a.PR_insert(_0RL_tc_CosNotifyFilter_mFilterNotFound,
               _0RL_CosNotifyFilter_mFilterNotFound_marshal_fn,
               _0RL_CosNotifyFilter_mFilterNotFound_destructor_fn,
               (CosNotifyFilter::FilterNotFound*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CosNotifyFilter::FilterNotFound*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CosNotifyFilter_mFilterNotFound,
                    _0RL_CosNotifyFilter_mFilterNotFound_unmarshal_fn,
                    _0RL_CosNotifyFilter_mFilterNotFound_marshal_fn,
                    _0RL_CosNotifyFilter_mFilterNotFound_destructor_fn,
                    _v)) {
    _sp = (const CosNotifyFilter::FilterNotFound*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCosNotifyFilter_mFilterNotFound(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CosNotifyFilter::FilterNotFound & _ex = (const CosNotifyFilter::FilterNotFound &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCosNotifyFilter_mFilterNotFound (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CosNotifyFilter::FilterNotFound* _ex = (const CosNotifyFilter::FilterNotFound*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCosNotifyFilter_mFilterNotFound {
public:
  _0RL_insertToAny_Singleton__cCosNotifyFilter_mFilterNotFound() {
    CosNotifyFilter::FilterNotFound::insertToAnyFn = _0RL_insertToAny__cCosNotifyFilter_mFilterNotFound;
    CosNotifyFilter::FilterNotFound::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCosNotifyFilter_mFilterNotFound;
  }
};
static _0RL_insertToAny_Singleton__cCosNotifyFilter_mFilterNotFound _0RL_insertToAny_Singleton__cCosNotifyFilter_mFilterNotFound_;

static void _0RL_CosNotifyFilter_mFilterAdmin_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CosNotifyFilter_mFilterAdmin_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CosNotifyFilter::FilterAdmin::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CosNotifyFilter_mFilterAdmin_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CosNotifyFilter::FilterAdmin_ptr _o)
{
  CosNotifyFilter::FilterAdmin_ptr _no = CosNotifyFilter::FilterAdmin::_duplicate(_o);
  _a.PR_insert(CosNotifyFilter::_tc_FilterAdmin,
               _0RL_CosNotifyFilter_mFilterAdmin_marshal_fn,
               _0RL_CosNotifyFilter_mFilterAdmin_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CosNotifyFilter::FilterAdmin_ptr* _op)
{
  _a.PR_insert(CosNotifyFilter::_tc_FilterAdmin,
               _0RL_CosNotifyFilter_mFilterAdmin_marshal_fn,
               _0RL_CosNotifyFilter_mFilterAdmin_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CosNotifyFilter::FilterAdmin::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CosNotifyFilter::FilterAdmin_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CosNotifyFilter::_tc_FilterAdmin,
                    _0RL_CosNotifyFilter_mFilterAdmin_unmarshal_fn,
                    _0RL_CosNotifyFilter_mFilterAdmin_marshal_fn,
                    _0RL_CosNotifyFilter_mFilterAdmin_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CosNotifyFilter::FilterAdmin_ptr)_r->_ptrToObjRef(CosNotifyFilter::FilterAdmin::_PD_repoId);
    else
      _o = CosNotifyFilter::FilterAdmin::_nil();
    return 1;
  }
  return 0;
}

