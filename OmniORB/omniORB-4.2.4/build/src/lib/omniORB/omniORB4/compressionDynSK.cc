// This file is generated by omniidl (C++ backend) - omniORB_4_2. Do not edit.

#include "compression.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_2_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::PR_structMember _0RL_structmember_Compression_mCompressionException[] = {
  {"reason", CORBA::TypeCode::PR_long_tc()},
  {"description", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_Compression_mCompressionException = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/Compression/CompressionException:1.0", "CompressionException", _0RL_structmember_Compression_mCompressionException, 2, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Compression { 
  const ::CORBA::TypeCode_ptr _tc_CompressionException = _0RL_tc_Compression_mCompressionException;
} 
#else
const ::CORBA::TypeCode_ptr Compression::_tc_CompressionException = _0RL_tc_Compression_mCompressionException;
#endif



static CORBA::TypeCode_ptr _0RL_tc_Compression_mFactoryAlreadyRegistered = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/Compression/FactoryAlreadyRegistered:1.0", "FactoryAlreadyRegistered", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Compression { 
  const ::CORBA::TypeCode_ptr _tc_FactoryAlreadyRegistered = _0RL_tc_Compression_mFactoryAlreadyRegistered;
} 
#else
const ::CORBA::TypeCode_ptr Compression::_tc_FactoryAlreadyRegistered = _0RL_tc_Compression_mFactoryAlreadyRegistered;
#endif



static CORBA::TypeCode_ptr _0RL_tc_Compression_mUnknownCompressorId = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/Compression/UnknownCompressorId:1.0", "UnknownCompressorId", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Compression { 
  const ::CORBA::TypeCode_ptr _tc_UnknownCompressorId = _0RL_tc_Compression_mUnknownCompressorId;
} 
#else
const ::CORBA::TypeCode_ptr Compression::_tc_UnknownCompressorId = _0RL_tc_Compression_mUnknownCompressorId;
#endif


static CORBA::TypeCode_ptr _0RL_tc_Compression_mCompressorId = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/Compression/CompressorId:1.0", "CompressorId", CORBA::TypeCode::PR_ushort_tc(), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Compression { 
  const ::CORBA::TypeCode_ptr _tc_CompressorId = _0RL_tc_Compression_mCompressorId;
} 
#else
const ::CORBA::TypeCode_ptr Compression::_tc_CompressorId = _0RL_tc_Compression_mCompressorId;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Compression_mCompressionLevel = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/Compression/CompressionLevel:1.0", "CompressionLevel", CORBA::TypeCode::PR_ushort_tc(), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Compression { 
  const ::CORBA::TypeCode_ptr _tc_CompressionLevel = _0RL_tc_Compression_mCompressionLevel;
} 
#else
const ::CORBA::TypeCode_ptr Compression::_tc_CompressionLevel = _0RL_tc_Compression_mCompressionLevel;
#endif

static CORBA::TypeCode_ptr _0RL_tc_Compression_mCompressionRatio = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/Compression/CompressionRatio:1.0", "CompressionRatio", CORBA::TypeCode::PR_float_tc(), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Compression { 
  const ::CORBA::TypeCode_ptr _tc_CompressionRatio = _0RL_tc_Compression_mCompressionRatio;
} 
#else
const ::CORBA::TypeCode_ptr Compression::_tc_CompressionRatio = _0RL_tc_Compression_mCompressionRatio;
#endif

static CORBA::PR_structMember _0RL_structmember_Compression_mCompressorIdLevel[] = {
  {"compressor_id", _0RL_tc_Compression_mCompressorId},
  {"compression_level", _0RL_tc_Compression_mCompressionLevel}
};

#ifdef _0RL_tc_Compression_mCompressorIdLevel
#  undef _0RL_tc_Compression_mCompressorIdLevel
#endif
static CORBA::TypeCode_ptr _0RL_tc_Compression_mCompressorIdLevel = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/Compression/CompressorIdLevel:1.0", "CompressorIdLevel", _0RL_structmember_Compression_mCompressorIdLevel, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Compression { 
  const ::CORBA::TypeCode_ptr _tc_CompressorIdLevel = _0RL_tc_Compression_mCompressorIdLevel;
} 
#else
const ::CORBA::TypeCode_ptr Compression::_tc_CompressorIdLevel = _0RL_tc_Compression_mCompressorIdLevel;
#endif






static CORBA::TypeCode_ptr _0RL_tc_Compression_mCompressorIdLevelList = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/Compression/CompressorIdLevelList:1.0", "CompressorIdLevelList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_Compression_mCompressorIdLevel, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Compression { 
  const ::CORBA::TypeCode_ptr _tc_CompressorIdLevelList = _0RL_tc_Compression_mCompressorIdLevelList;
} 
#else
const ::CORBA::TypeCode_ptr Compression::_tc_CompressorIdLevelList = _0RL_tc_Compression_mCompressorIdLevelList;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mOctetSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/OctetSeq:1.0", "OctetSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_octet_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


static CORBA::TypeCode_ptr _0RL_tc_Compression_mBuffer = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/Compression/Buffer:1.0", "Buffer", _0RL_tc_CORBA_mOctetSeq, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Compression { 
  const ::CORBA::TypeCode_ptr _tc_Buffer = _0RL_tc_Compression_mBuffer;
} 
#else
const ::CORBA::TypeCode_ptr Compression::_tc_Buffer = _0RL_tc_Compression_mBuffer;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Compression { 
  const ::CORBA::TypeCode_ptr _tc_Compressor = CORBA::TypeCode::PR_local_interface_tc("IDL:omg.org/Compression/Compressor:1.0", "Compressor", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr Compression::_tc_Compressor = CORBA::TypeCode::PR_local_interface_tc("IDL:omg.org/Compression/Compressor:1.0", "Compressor", &_0RL_tcTrack);
#endif

static CORBA::TypeCode_ptr _0RL_tc_Compression_mCompressorSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/Compression/CompressorSeq:1.0", "CompressorSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_local_interface_tc("IDL:omg.org/Compression/Compressor:1.0", "Compressor", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Compression { 
  const ::CORBA::TypeCode_ptr _tc_CompressorSeq = _0RL_tc_Compression_mCompressorSeq;
} 
#else
const ::CORBA::TypeCode_ptr Compression::_tc_CompressorSeq = _0RL_tc_Compression_mCompressorSeq;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Compression { 
  const ::CORBA::TypeCode_ptr _tc_CompressorFactory = CORBA::TypeCode::PR_local_interface_tc("IDL:omg.org/Compression/CompressorFactory:1.0", "CompressorFactory", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr Compression::_tc_CompressorFactory = CORBA::TypeCode::PR_local_interface_tc("IDL:omg.org/Compression/CompressorFactory:1.0", "CompressorFactory", &_0RL_tcTrack);
#endif

static CORBA::TypeCode_ptr _0RL_tc_Compression_mCompressorFactorySeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/Compression/CompressorFactorySeq:1.0", "CompressorFactorySeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_local_interface_tc("IDL:omg.org/Compression/CompressorFactory:1.0", "CompressorFactory", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Compression { 
  const ::CORBA::TypeCode_ptr _tc_CompressorFactorySeq = _0RL_tc_Compression_mCompressorFactorySeq;
} 
#else
const ::CORBA::TypeCode_ptr Compression::_tc_CompressorFactorySeq = _0RL_tc_Compression_mCompressorFactorySeq;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Compression { 
  const ::CORBA::TypeCode_ptr _tc_CompressionManager = CORBA::TypeCode::PR_local_interface_tc("IDL:omg.org/Compression/CompressionManager:1.0", "CompressionManager", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr Compression::_tc_CompressionManager = CORBA::TypeCode::PR_local_interface_tc("IDL:omg.org/Compression/CompressionManager:1.0", "CompressionManager", &_0RL_tcTrack);
#endif


static void _0RL_Compression_mCompressionException_marshal_fn(cdrStream& _s, void* _v)
{
  const Compression::CompressionException* _p = (const Compression::CompressionException*)_v;
  *_p >>= _s;
}
static void _0RL_Compression_mCompressionException_unmarshal_fn(cdrStream& _s, void*& _v)
{
  Compression::CompressionException* _p = new Compression::CompressionException;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_Compression_mCompressionException_destructor_fn(void* _v)
{
  Compression::CompressionException* _p = (Compression::CompressionException*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const Compression::CompressionException& _s)
{
  Compression::CompressionException* _p = new Compression::CompressionException(_s);
  _a.PR_insert(_0RL_tc_Compression_mCompressionException,
               _0RL_Compression_mCompressionException_marshal_fn,
               _0RL_Compression_mCompressionException_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const Compression::CompressionException* _sp)
{
  _a.PR_insert(_0RL_tc_Compression_mCompressionException,
               _0RL_Compression_mCompressionException_marshal_fn,
               _0RL_Compression_mCompressionException_destructor_fn,
               (Compression::CompressionException*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const Compression::CompressionException*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_Compression_mCompressionException,
                    _0RL_Compression_mCompressionException_unmarshal_fn,
                    _0RL_Compression_mCompressionException_marshal_fn,
                    _0RL_Compression_mCompressionException_destructor_fn,
                    _v)) {
    _sp = (const Compression::CompressionException*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCompression_mCompressionException(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const Compression::CompressionException & _ex = (const Compression::CompressionException &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCompression_mCompressionException (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const Compression::CompressionException* _ex = (const Compression::CompressionException*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCompression_mCompressionException {
public:
  _0RL_insertToAny_Singleton__cCompression_mCompressionException() {
    Compression::CompressionException::insertToAnyFn = _0RL_insertToAny__cCompression_mCompressionException;
    Compression::CompressionException::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCompression_mCompressionException;
  }
};
static _0RL_insertToAny_Singleton__cCompression_mCompressionException _0RL_insertToAny_Singleton__cCompression_mCompressionException_;


static void _0RL_Compression_mFactoryAlreadyRegistered_marshal_fn(cdrStream& _s, void* _v)
{
  const Compression::FactoryAlreadyRegistered* _p = (const Compression::FactoryAlreadyRegistered*)_v;
  *_p >>= _s;
}
static void _0RL_Compression_mFactoryAlreadyRegistered_unmarshal_fn(cdrStream& _s, void*& _v)
{
  Compression::FactoryAlreadyRegistered* _p = new Compression::FactoryAlreadyRegistered;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_Compression_mFactoryAlreadyRegistered_destructor_fn(void* _v)
{
  Compression::FactoryAlreadyRegistered* _p = (Compression::FactoryAlreadyRegistered*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const Compression::FactoryAlreadyRegistered& _s)
{
  Compression::FactoryAlreadyRegistered* _p = new Compression::FactoryAlreadyRegistered(_s);
  _a.PR_insert(_0RL_tc_Compression_mFactoryAlreadyRegistered,
               _0RL_Compression_mFactoryAlreadyRegistered_marshal_fn,
               _0RL_Compression_mFactoryAlreadyRegistered_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const Compression::FactoryAlreadyRegistered* _sp)
{
  _a.PR_insert(_0RL_tc_Compression_mFactoryAlreadyRegistered,
               _0RL_Compression_mFactoryAlreadyRegistered_marshal_fn,
               _0RL_Compression_mFactoryAlreadyRegistered_destructor_fn,
               (Compression::FactoryAlreadyRegistered*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const Compression::FactoryAlreadyRegistered*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_Compression_mFactoryAlreadyRegistered,
                    _0RL_Compression_mFactoryAlreadyRegistered_unmarshal_fn,
                    _0RL_Compression_mFactoryAlreadyRegistered_marshal_fn,
                    _0RL_Compression_mFactoryAlreadyRegistered_destructor_fn,
                    _v)) {
    _sp = (const Compression::FactoryAlreadyRegistered*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCompression_mFactoryAlreadyRegistered(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const Compression::FactoryAlreadyRegistered & _ex = (const Compression::FactoryAlreadyRegistered &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCompression_mFactoryAlreadyRegistered (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const Compression::FactoryAlreadyRegistered* _ex = (const Compression::FactoryAlreadyRegistered*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCompression_mFactoryAlreadyRegistered {
public:
  _0RL_insertToAny_Singleton__cCompression_mFactoryAlreadyRegistered() {
    Compression::FactoryAlreadyRegistered::insertToAnyFn = _0RL_insertToAny__cCompression_mFactoryAlreadyRegistered;
    Compression::FactoryAlreadyRegistered::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCompression_mFactoryAlreadyRegistered;
  }
};
static _0RL_insertToAny_Singleton__cCompression_mFactoryAlreadyRegistered _0RL_insertToAny_Singleton__cCompression_mFactoryAlreadyRegistered_;


static void _0RL_Compression_mUnknownCompressorId_marshal_fn(cdrStream& _s, void* _v)
{
  const Compression::UnknownCompressorId* _p = (const Compression::UnknownCompressorId*)_v;
  *_p >>= _s;
}
static void _0RL_Compression_mUnknownCompressorId_unmarshal_fn(cdrStream& _s, void*& _v)
{
  Compression::UnknownCompressorId* _p = new Compression::UnknownCompressorId;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_Compression_mUnknownCompressorId_destructor_fn(void* _v)
{
  Compression::UnknownCompressorId* _p = (Compression::UnknownCompressorId*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const Compression::UnknownCompressorId& _s)
{
  Compression::UnknownCompressorId* _p = new Compression::UnknownCompressorId(_s);
  _a.PR_insert(_0RL_tc_Compression_mUnknownCompressorId,
               _0RL_Compression_mUnknownCompressorId_marshal_fn,
               _0RL_Compression_mUnknownCompressorId_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const Compression::UnknownCompressorId* _sp)
{
  _a.PR_insert(_0RL_tc_Compression_mUnknownCompressorId,
               _0RL_Compression_mUnknownCompressorId_marshal_fn,
               _0RL_Compression_mUnknownCompressorId_destructor_fn,
               (Compression::UnknownCompressorId*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const Compression::UnknownCompressorId*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_Compression_mUnknownCompressorId,
                    _0RL_Compression_mUnknownCompressorId_unmarshal_fn,
                    _0RL_Compression_mUnknownCompressorId_marshal_fn,
                    _0RL_Compression_mUnknownCompressorId_destructor_fn,
                    _v)) {
    _sp = (const Compression::UnknownCompressorId*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCompression_mUnknownCompressorId(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const Compression::UnknownCompressorId & _ex = (const Compression::UnknownCompressorId &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCompression_mUnknownCompressorId (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const Compression::UnknownCompressorId* _ex = (const Compression::UnknownCompressorId*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCompression_mUnknownCompressorId {
public:
  _0RL_insertToAny_Singleton__cCompression_mUnknownCompressorId() {
    Compression::UnknownCompressorId::insertToAnyFn = _0RL_insertToAny__cCompression_mUnknownCompressorId;
    Compression::UnknownCompressorId::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCompression_mUnknownCompressorId;
  }
};
static _0RL_insertToAny_Singleton__cCompression_mUnknownCompressorId _0RL_insertToAny_Singleton__cCompression_mUnknownCompressorId_;

static void _0RL_Compression_mCompressorIdLevel_marshal_fn(cdrStream& _s, void* _v)
{
  Compression::CompressorIdLevel* _p = (Compression::CompressorIdLevel*)_v;
  *_p >>= _s;
}
static void _0RL_Compression_mCompressorIdLevel_unmarshal_fn(cdrStream& _s, void*& _v)
{
  Compression::CompressorIdLevel* _p = new Compression::CompressorIdLevel;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_Compression_mCompressorIdLevel_destructor_fn(void* _v)
{
  Compression::CompressorIdLevel* _p = (Compression::CompressorIdLevel*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const Compression::CompressorIdLevel& _s)
{
  Compression::CompressorIdLevel* _p = new Compression::CompressorIdLevel(_s);
  _a.PR_insert(_0RL_tc_Compression_mCompressorIdLevel,
               _0RL_Compression_mCompressorIdLevel_marshal_fn,
               _0RL_Compression_mCompressorIdLevel_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, Compression::CompressorIdLevel* _sp)
{
  _a.PR_insert(_0RL_tc_Compression_mCompressorIdLevel,
               _0RL_Compression_mCompressorIdLevel_marshal_fn,
               _0RL_Compression_mCompressorIdLevel_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, Compression::CompressorIdLevel*& _sp)
{
  return _a >>= (const Compression::CompressorIdLevel*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const Compression::CompressorIdLevel*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_Compression_mCompressorIdLevel,
                    _0RL_Compression_mCompressorIdLevel_unmarshal_fn,
                    _0RL_Compression_mCompressorIdLevel_marshal_fn,
                    _0RL_Compression_mCompressorIdLevel_destructor_fn,
                    _v)) {
    _sp = (const Compression::CompressorIdLevel*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_Compression_mCompressorIdLevelList_marshal_fn(cdrStream& _s, void* _v)
{
  Compression::CompressorIdLevelList* _p = (Compression::CompressorIdLevelList*)_v;
  *_p >>= _s;
}
static void _0RL_Compression_mCompressorIdLevelList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  Compression::CompressorIdLevelList* _p = new Compression::CompressorIdLevelList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_Compression_mCompressorIdLevelList_destructor_fn(void* _v)
{
  Compression::CompressorIdLevelList* _p = (Compression::CompressorIdLevelList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const Compression::CompressorIdLevelList& _s)
{
  Compression::CompressorIdLevelList* _p = new Compression::CompressorIdLevelList(_s);
  _a.PR_insert(_0RL_tc_Compression_mCompressorIdLevelList,
               _0RL_Compression_mCompressorIdLevelList_marshal_fn,
               _0RL_Compression_mCompressorIdLevelList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, Compression::CompressorIdLevelList* _sp)
{
  _a.PR_insert(_0RL_tc_Compression_mCompressorIdLevelList,
               _0RL_Compression_mCompressorIdLevelList_marshal_fn,
               _0RL_Compression_mCompressorIdLevelList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, Compression::CompressorIdLevelList*& _sp)
{
  return _a >>= (const Compression::CompressorIdLevelList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const Compression::CompressorIdLevelList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_Compression_mCompressorIdLevelList,
                    _0RL_Compression_mCompressorIdLevelList_unmarshal_fn,
                    _0RL_Compression_mCompressorIdLevelList_marshal_fn,
                    _0RL_Compression_mCompressorIdLevelList_destructor_fn,
                    _v)) {
    _sp = (const Compression::CompressorIdLevelList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_Compression_mCompressor_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_Compression_mCompressor_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(Compression::Compressor::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_Compression_mCompressor_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, Compression::Compressor_ptr _o)
{
  Compression::Compressor_ptr _no = Compression::Compressor::_duplicate(_o);
  _a.PR_insert(Compression::_tc_Compressor,
               _0RL_Compression_mCompressor_marshal_fn,
               _0RL_Compression_mCompressor_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, Compression::Compressor_ptr* _op)
{
  _a.PR_insert(Compression::_tc_Compressor,
               _0RL_Compression_mCompressor_marshal_fn,
               _0RL_Compression_mCompressor_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = Compression::Compressor::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, Compression::Compressor_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(Compression::_tc_Compressor,
                    _0RL_Compression_mCompressor_unmarshal_fn,
                    _0RL_Compression_mCompressor_marshal_fn,
                    _0RL_Compression_mCompressor_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (Compression::Compressor_ptr)_r->_ptrToObjRef(Compression::Compressor::_PD_repoId);
    else
      _o = Compression::Compressor::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_Compression_mCompressorSeq_marshal_fn(cdrStream& _s, void* _v)
{
  Compression::CompressorSeq* _p = (Compression::CompressorSeq*)_v;
  *_p >>= _s;
}
static void _0RL_Compression_mCompressorSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  Compression::CompressorSeq* _p = new Compression::CompressorSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_Compression_mCompressorSeq_destructor_fn(void* _v)
{
  Compression::CompressorSeq* _p = (Compression::CompressorSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const Compression::CompressorSeq& _s)
{
  Compression::CompressorSeq* _p = new Compression::CompressorSeq(_s);
  _a.PR_insert(_0RL_tc_Compression_mCompressorSeq,
               _0RL_Compression_mCompressorSeq_marshal_fn,
               _0RL_Compression_mCompressorSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, Compression::CompressorSeq* _sp)
{
  _a.PR_insert(_0RL_tc_Compression_mCompressorSeq,
               _0RL_Compression_mCompressorSeq_marshal_fn,
               _0RL_Compression_mCompressorSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, Compression::CompressorSeq*& _sp)
{
  return _a >>= (const Compression::CompressorSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const Compression::CompressorSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_Compression_mCompressorSeq,
                    _0RL_Compression_mCompressorSeq_unmarshal_fn,
                    _0RL_Compression_mCompressorSeq_marshal_fn,
                    _0RL_Compression_mCompressorSeq_destructor_fn,
                    _v)) {
    _sp = (const Compression::CompressorSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_Compression_mCompressorFactory_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_Compression_mCompressorFactory_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(Compression::CompressorFactory::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_Compression_mCompressorFactory_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, Compression::CompressorFactory_ptr _o)
{
  Compression::CompressorFactory_ptr _no = Compression::CompressorFactory::_duplicate(_o);
  _a.PR_insert(Compression::_tc_CompressorFactory,
               _0RL_Compression_mCompressorFactory_marshal_fn,
               _0RL_Compression_mCompressorFactory_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, Compression::CompressorFactory_ptr* _op)
{
  _a.PR_insert(Compression::_tc_CompressorFactory,
               _0RL_Compression_mCompressorFactory_marshal_fn,
               _0RL_Compression_mCompressorFactory_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = Compression::CompressorFactory::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, Compression::CompressorFactory_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(Compression::_tc_CompressorFactory,
                    _0RL_Compression_mCompressorFactory_unmarshal_fn,
                    _0RL_Compression_mCompressorFactory_marshal_fn,
                    _0RL_Compression_mCompressorFactory_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (Compression::CompressorFactory_ptr)_r->_ptrToObjRef(Compression::CompressorFactory::_PD_repoId);
    else
      _o = Compression::CompressorFactory::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_Compression_mCompressorFactorySeq_marshal_fn(cdrStream& _s, void* _v)
{
  Compression::CompressorFactorySeq* _p = (Compression::CompressorFactorySeq*)_v;
  *_p >>= _s;
}
static void _0RL_Compression_mCompressorFactorySeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  Compression::CompressorFactorySeq* _p = new Compression::CompressorFactorySeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_Compression_mCompressorFactorySeq_destructor_fn(void* _v)
{
  Compression::CompressorFactorySeq* _p = (Compression::CompressorFactorySeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const Compression::CompressorFactorySeq& _s)
{
  Compression::CompressorFactorySeq* _p = new Compression::CompressorFactorySeq(_s);
  _a.PR_insert(_0RL_tc_Compression_mCompressorFactorySeq,
               _0RL_Compression_mCompressorFactorySeq_marshal_fn,
               _0RL_Compression_mCompressorFactorySeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, Compression::CompressorFactorySeq* _sp)
{
  _a.PR_insert(_0RL_tc_Compression_mCompressorFactorySeq,
               _0RL_Compression_mCompressorFactorySeq_marshal_fn,
               _0RL_Compression_mCompressorFactorySeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, Compression::CompressorFactorySeq*& _sp)
{
  return _a >>= (const Compression::CompressorFactorySeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const Compression::CompressorFactorySeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_Compression_mCompressorFactorySeq,
                    _0RL_Compression_mCompressorFactorySeq_unmarshal_fn,
                    _0RL_Compression_mCompressorFactorySeq_marshal_fn,
                    _0RL_Compression_mCompressorFactorySeq_destructor_fn,
                    _v)) {
    _sp = (const Compression::CompressorFactorySeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_Compression_mCompressionManager_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_Compression_mCompressionManager_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(Compression::CompressionManager::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_Compression_mCompressionManager_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, Compression::CompressionManager_ptr _o)
{
  Compression::CompressionManager_ptr _no = Compression::CompressionManager::_duplicate(_o);
  _a.PR_insert(Compression::_tc_CompressionManager,
               _0RL_Compression_mCompressionManager_marshal_fn,
               _0RL_Compression_mCompressionManager_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, Compression::CompressionManager_ptr* _op)
{
  _a.PR_insert(Compression::_tc_CompressionManager,
               _0RL_Compression_mCompressionManager_marshal_fn,
               _0RL_Compression_mCompressionManager_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = Compression::CompressionManager::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, Compression::CompressionManager_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(Compression::_tc_CompressionManager,
                    _0RL_Compression_mCompressionManager_unmarshal_fn,
                    _0RL_Compression_mCompressionManager_marshal_fn,
                    _0RL_Compression_mCompressionManager_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (Compression::CompressionManager_ptr)_r->_ptrToObjRef(Compression::CompressionManager::_PD_repoId);
    else
      _o = Compression::CompressionManager::_nil();
    return 1;
  }
  return 0;
}

