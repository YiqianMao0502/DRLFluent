// This file is generated by omniidl (C++ backend) - omniORB_4_2. Do not edit.

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mIdentifier = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/Identifier:1.0", "Identifier", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_Identifier = _0RL_tc_CORBA_mIdentifier;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_Identifier = _0RL_tc_CORBA_mIdentifier;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mRepositoryId = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/RepositoryId:1.0", "RepositoryId", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_RepositoryId = _0RL_tc_CORBA_mRepositoryId;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_RepositoryId = _0RL_tc_CORBA_mRepositoryId;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mVersionSpec = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/VersionSpec:1.0", "VersionSpec", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_VersionSpec = _0RL_tc_CORBA_mVersionSpec;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_VersionSpec = _0RL_tc_CORBA_mVersionSpec;
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mStructMember[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"type_def", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType", &_0RL_tcTrack)}
};

#ifdef _0RL_tc_CORBA_mStructMember
#  undef _0RL_tc_CORBA_mStructMember
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mStructMember = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/StructMember:1.0", "StructMember", _0RL_structmember_CORBA_mStructMember, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_StructMember = _0RL_tc_CORBA_mStructMember;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_StructMember = _0RL_tc_CORBA_mStructMember;
#endif






static CORBA::TypeCode_ptr _0RL_tc_CORBA_mStructMemberSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/StructMemberSeq:1.0", "StructMemberSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mStructMember, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_StructMemberSeq = _0RL_tc_CORBA_mStructMemberSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_StructMemberSeq = _0RL_tc_CORBA_mStructMemberSeq;
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mUnionMember[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"label", CORBA::TypeCode::PR_any_tc()},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"type_def", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType", &_0RL_tcTrack)}
};

#ifdef _0RL_tc_CORBA_mUnionMember
#  undef _0RL_tc_CORBA_mUnionMember
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mUnionMember = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/UnionMember:1.0", "UnionMember", _0RL_structmember_CORBA_mUnionMember, 4, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_UnionMember = _0RL_tc_CORBA_mUnionMember;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_UnionMember = _0RL_tc_CORBA_mUnionMember;
#endif






static CORBA::TypeCode_ptr _0RL_tc_CORBA_mUnionMemberSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/UnionMemberSeq:1.0", "UnionMemberSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mUnionMember, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_UnionMemberSeq = _0RL_tc_CORBA_mUnionMemberSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_UnionMemberSeq = _0RL_tc_CORBA_mUnionMemberSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mEnumMemberSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/EnumMemberSeq:1.0", "EnumMemberSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mIdentifier, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_EnumMemberSeq = _0RL_tc_CORBA_mEnumMemberSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_EnumMemberSeq = _0RL_tc_CORBA_mEnumMemberSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mVisibility = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/Visibility:1.0", "Visibility", CORBA::TypeCode::PR_short_tc(), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_Visibility = _0RL_tc_CORBA_mVisibility;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_Visibility = _0RL_tc_CORBA_mVisibility;
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mValueMember[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"type_def", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType", &_0RL_tcTrack)},
  {"access", _0RL_tc_CORBA_mVisibility}
};

#ifdef _0RL_tc_CORBA_mValueMember
#  undef _0RL_tc_CORBA_mValueMember
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mValueMember = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ValueMember:1.0", "ValueMember", _0RL_structmember_CORBA_mValueMember, 7, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ValueMember = _0RL_tc_CORBA_mValueMember;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ValueMember = _0RL_tc_CORBA_mValueMember;
#endif






static CORBA::TypeCode_ptr _0RL_tc_CORBA_mValueMemberSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ValueMemberSeq:1.0", "ValueMemberSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mValueMember, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ValueMemberSeq = _0RL_tc_CORBA_mValueMemberSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ValueMemberSeq = _0RL_tc_CORBA_mValueMemberSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mAnySeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/AnySeq:1.0", "AnySeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_any_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_AnySeq = _0RL_tc_CORBA_mAnySeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_AnySeq = _0RL_tc_CORBA_mAnySeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mBooleanSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/BooleanSeq:1.0", "BooleanSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_boolean_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_BooleanSeq = _0RL_tc_CORBA_mBooleanSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_BooleanSeq = _0RL_tc_CORBA_mBooleanSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mCharSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/CharSeq:1.0", "CharSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_CharSeq = _0RL_tc_CORBA_mCharSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_CharSeq = _0RL_tc_CORBA_mCharSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mWCharSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/WCharSeq:1.0", "WCharSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_wchar_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_WCharSeq = _0RL_tc_CORBA_mWCharSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_WCharSeq = _0RL_tc_CORBA_mWCharSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mOctetSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/OctetSeq:1.0", "OctetSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_octet_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_OctetSeq = _0RL_tc_CORBA_mOctetSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_OctetSeq = _0RL_tc_CORBA_mOctetSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mShortSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ShortSeq:1.0", "ShortSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_short_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ShortSeq = _0RL_tc_CORBA_mShortSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ShortSeq = _0RL_tc_CORBA_mShortSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mUShortSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/UShortSeq:1.0", "UShortSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_ushort_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_UShortSeq = _0RL_tc_CORBA_mUShortSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_UShortSeq = _0RL_tc_CORBA_mUShortSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mLongSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/LongSeq:1.0", "LongSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_LongSeq = _0RL_tc_CORBA_mLongSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_LongSeq = _0RL_tc_CORBA_mLongSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mULongSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ULongSeq:1.0", "ULongSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_ulong_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ULongSeq = _0RL_tc_CORBA_mULongSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ULongSeq = _0RL_tc_CORBA_mULongSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mLongLongSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/LongLongSeq:1.0", "LongLongSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_longlong_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_LongLongSeq = _0RL_tc_CORBA_mLongLongSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_LongLongSeq = _0RL_tc_CORBA_mLongLongSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mULongLongSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ULongLongSeq:1.0", "ULongLongSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_ulonglong_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ULongLongSeq = _0RL_tc_CORBA_mULongLongSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ULongLongSeq = _0RL_tc_CORBA_mULongLongSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mFloatSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/FloatSeq:1.0", "FloatSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_float_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_FloatSeq = _0RL_tc_CORBA_mFloatSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_FloatSeq = _0RL_tc_CORBA_mFloatSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mDoubleSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/DoubleSeq:1.0", "DoubleSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_DoubleSeq = _0RL_tc_CORBA_mDoubleSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_DoubleSeq = _0RL_tc_CORBA_mDoubleSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mLongDoubleSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/LongDoubleSeq:1.0", "LongDoubleSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_longdouble_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_LongDoubleSeq = _0RL_tc_CORBA_mLongDoubleSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_LongDoubleSeq = _0RL_tc_CORBA_mLongDoubleSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mStringSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/StringSeq:1.0", "StringSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_StringSeq = _0RL_tc_CORBA_mStringSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_StringSeq = _0RL_tc_CORBA_mStringSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mWStringSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/WStringSeq:1.0", "WStringSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_wstring_tc(0, &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_WStringSeq = _0RL_tc_CORBA_mWStringSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_WStringSeq = _0RL_tc_CORBA_mWStringSeq;
#endif

static void _0RL_CORBA_mStructMember_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::StructMember* _p = (CORBA::StructMember*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mStructMember_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::StructMember* _p = new CORBA::StructMember;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mStructMember_destructor_fn(void* _v)
{
  CORBA::StructMember* _p = (CORBA::StructMember*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::StructMember& _s)
{
  CORBA::StructMember* _p = new CORBA::StructMember(_s);
  _a.PR_insert(_0RL_tc_CORBA_mStructMember,
               _0RL_CORBA_mStructMember_marshal_fn,
               _0RL_CORBA_mStructMember_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::StructMember* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mStructMember,
               _0RL_CORBA_mStructMember_marshal_fn,
               _0RL_CORBA_mStructMember_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::StructMember*& _sp)
{
  return _a >>= (const CORBA::StructMember*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::StructMember*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mStructMember,
                    _0RL_CORBA_mStructMember_unmarshal_fn,
                    _0RL_CORBA_mStructMember_marshal_fn,
                    _0RL_CORBA_mStructMember_destructor_fn,
                    _v)) {
    _sp = (const CORBA::StructMember*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mStructMemberSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::StructMemberSeq* _p = (CORBA::StructMemberSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mStructMemberSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::StructMemberSeq* _p = new CORBA::StructMemberSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mStructMemberSeq_destructor_fn(void* _v)
{
  CORBA::StructMemberSeq* _p = (CORBA::StructMemberSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::StructMemberSeq& _s)
{
  CORBA::StructMemberSeq* _p = new CORBA::StructMemberSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mStructMemberSeq,
               _0RL_CORBA_mStructMemberSeq_marshal_fn,
               _0RL_CORBA_mStructMemberSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::StructMemberSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mStructMemberSeq,
               _0RL_CORBA_mStructMemberSeq_marshal_fn,
               _0RL_CORBA_mStructMemberSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::StructMemberSeq*& _sp)
{
  return _a >>= (const CORBA::StructMemberSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::StructMemberSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mStructMemberSeq,
                    _0RL_CORBA_mStructMemberSeq_unmarshal_fn,
                    _0RL_CORBA_mStructMemberSeq_marshal_fn,
                    _0RL_CORBA_mStructMemberSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::StructMemberSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mUnionMember_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::UnionMember* _p = (CORBA::UnionMember*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mUnionMember_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::UnionMember* _p = new CORBA::UnionMember;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mUnionMember_destructor_fn(void* _v)
{
  CORBA::UnionMember* _p = (CORBA::UnionMember*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::UnionMember& _s)
{
  CORBA::UnionMember* _p = new CORBA::UnionMember(_s);
  _a.PR_insert(_0RL_tc_CORBA_mUnionMember,
               _0RL_CORBA_mUnionMember_marshal_fn,
               _0RL_CORBA_mUnionMember_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::UnionMember* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mUnionMember,
               _0RL_CORBA_mUnionMember_marshal_fn,
               _0RL_CORBA_mUnionMember_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::UnionMember*& _sp)
{
  return _a >>= (const CORBA::UnionMember*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::UnionMember*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mUnionMember,
                    _0RL_CORBA_mUnionMember_unmarshal_fn,
                    _0RL_CORBA_mUnionMember_marshal_fn,
                    _0RL_CORBA_mUnionMember_destructor_fn,
                    _v)) {
    _sp = (const CORBA::UnionMember*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mUnionMemberSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::UnionMemberSeq* _p = (CORBA::UnionMemberSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mUnionMemberSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::UnionMemberSeq* _p = new CORBA::UnionMemberSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mUnionMemberSeq_destructor_fn(void* _v)
{
  CORBA::UnionMemberSeq* _p = (CORBA::UnionMemberSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::UnionMemberSeq& _s)
{
  CORBA::UnionMemberSeq* _p = new CORBA::UnionMemberSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mUnionMemberSeq,
               _0RL_CORBA_mUnionMemberSeq_marshal_fn,
               _0RL_CORBA_mUnionMemberSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::UnionMemberSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mUnionMemberSeq,
               _0RL_CORBA_mUnionMemberSeq_marshal_fn,
               _0RL_CORBA_mUnionMemberSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::UnionMemberSeq*& _sp)
{
  return _a >>= (const CORBA::UnionMemberSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::UnionMemberSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mUnionMemberSeq,
                    _0RL_CORBA_mUnionMemberSeq_unmarshal_fn,
                    _0RL_CORBA_mUnionMemberSeq_marshal_fn,
                    _0RL_CORBA_mUnionMemberSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::UnionMemberSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mEnumMemberSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::EnumMemberSeq* _p = (CORBA::EnumMemberSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mEnumMemberSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::EnumMemberSeq* _p = new CORBA::EnumMemberSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mEnumMemberSeq_destructor_fn(void* _v)
{
  CORBA::EnumMemberSeq* _p = (CORBA::EnumMemberSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::EnumMemberSeq& _s)
{
  CORBA::EnumMemberSeq* _p = new CORBA::EnumMemberSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mEnumMemberSeq,
               _0RL_CORBA_mEnumMemberSeq_marshal_fn,
               _0RL_CORBA_mEnumMemberSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::EnumMemberSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mEnumMemberSeq,
               _0RL_CORBA_mEnumMemberSeq_marshal_fn,
               _0RL_CORBA_mEnumMemberSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::EnumMemberSeq*& _sp)
{
  return _a >>= (const CORBA::EnumMemberSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::EnumMemberSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mEnumMemberSeq,
                    _0RL_CORBA_mEnumMemberSeq_unmarshal_fn,
                    _0RL_CORBA_mEnumMemberSeq_marshal_fn,
                    _0RL_CORBA_mEnumMemberSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::EnumMemberSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mValueMember_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ValueMember* _p = (CORBA::ValueMember*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mValueMember_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ValueMember* _p = new CORBA::ValueMember;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mValueMember_destructor_fn(void* _v)
{
  CORBA::ValueMember* _p = (CORBA::ValueMember*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ValueMember& _s)
{
  CORBA::ValueMember* _p = new CORBA::ValueMember(_s);
  _a.PR_insert(_0RL_tc_CORBA_mValueMember,
               _0RL_CORBA_mValueMember_marshal_fn,
               _0RL_CORBA_mValueMember_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ValueMember* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mValueMember,
               _0RL_CORBA_mValueMember_marshal_fn,
               _0RL_CORBA_mValueMember_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ValueMember*& _sp)
{
  return _a >>= (const CORBA::ValueMember*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ValueMember*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mValueMember,
                    _0RL_CORBA_mValueMember_unmarshal_fn,
                    _0RL_CORBA_mValueMember_marshal_fn,
                    _0RL_CORBA_mValueMember_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ValueMember*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mValueMemberSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ValueMemberSeq* _p = (CORBA::ValueMemberSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mValueMemberSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ValueMemberSeq* _p = new CORBA::ValueMemberSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mValueMemberSeq_destructor_fn(void* _v)
{
  CORBA::ValueMemberSeq* _p = (CORBA::ValueMemberSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ValueMemberSeq& _s)
{
  CORBA::ValueMemberSeq* _p = new CORBA::ValueMemberSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mValueMemberSeq,
               _0RL_CORBA_mValueMemberSeq_marshal_fn,
               _0RL_CORBA_mValueMemberSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ValueMemberSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mValueMemberSeq,
               _0RL_CORBA_mValueMemberSeq_marshal_fn,
               _0RL_CORBA_mValueMemberSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ValueMemberSeq*& _sp)
{
  return _a >>= (const CORBA::ValueMemberSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ValueMemberSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mValueMemberSeq,
                    _0RL_CORBA_mValueMemberSeq_unmarshal_fn,
                    _0RL_CORBA_mValueMemberSeq_marshal_fn,
                    _0RL_CORBA_mValueMemberSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ValueMemberSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mAnySeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::AnySeq* _p = (CORBA::AnySeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mAnySeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::AnySeq* _p = new CORBA::AnySeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mAnySeq_destructor_fn(void* _v)
{
  CORBA::AnySeq* _p = (CORBA::AnySeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::AnySeq& _s)
{
  CORBA::AnySeq* _p = new CORBA::AnySeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mAnySeq,
               _0RL_CORBA_mAnySeq_marshal_fn,
               _0RL_CORBA_mAnySeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::AnySeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mAnySeq,
               _0RL_CORBA_mAnySeq_marshal_fn,
               _0RL_CORBA_mAnySeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::AnySeq*& _sp)
{
  return _a >>= (const CORBA::AnySeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::AnySeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mAnySeq,
                    _0RL_CORBA_mAnySeq_unmarshal_fn,
                    _0RL_CORBA_mAnySeq_marshal_fn,
                    _0RL_CORBA_mAnySeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::AnySeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mBooleanSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::BooleanSeq* _p = (CORBA::BooleanSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mBooleanSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::BooleanSeq* _p = new CORBA::BooleanSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mBooleanSeq_destructor_fn(void* _v)
{
  CORBA::BooleanSeq* _p = (CORBA::BooleanSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::BooleanSeq& _s)
{
  CORBA::BooleanSeq* _p = new CORBA::BooleanSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mBooleanSeq,
               _0RL_CORBA_mBooleanSeq_marshal_fn,
               _0RL_CORBA_mBooleanSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::BooleanSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mBooleanSeq,
               _0RL_CORBA_mBooleanSeq_marshal_fn,
               _0RL_CORBA_mBooleanSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::BooleanSeq*& _sp)
{
  return _a >>= (const CORBA::BooleanSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::BooleanSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mBooleanSeq,
                    _0RL_CORBA_mBooleanSeq_unmarshal_fn,
                    _0RL_CORBA_mBooleanSeq_marshal_fn,
                    _0RL_CORBA_mBooleanSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::BooleanSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mCharSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::CharSeq* _p = (CORBA::CharSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mCharSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::CharSeq* _p = new CORBA::CharSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mCharSeq_destructor_fn(void* _v)
{
  CORBA::CharSeq* _p = (CORBA::CharSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::CharSeq& _s)
{
  CORBA::CharSeq* _p = new CORBA::CharSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mCharSeq,
               _0RL_CORBA_mCharSeq_marshal_fn,
               _0RL_CORBA_mCharSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::CharSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mCharSeq,
               _0RL_CORBA_mCharSeq_marshal_fn,
               _0RL_CORBA_mCharSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::CharSeq*& _sp)
{
  return _a >>= (const CORBA::CharSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::CharSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mCharSeq,
                    _0RL_CORBA_mCharSeq_unmarshal_fn,
                    _0RL_CORBA_mCharSeq_marshal_fn,
                    _0RL_CORBA_mCharSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::CharSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mWCharSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::WCharSeq* _p = (CORBA::WCharSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mWCharSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::WCharSeq* _p = new CORBA::WCharSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mWCharSeq_destructor_fn(void* _v)
{
  CORBA::WCharSeq* _p = (CORBA::WCharSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::WCharSeq& _s)
{
  CORBA::WCharSeq* _p = new CORBA::WCharSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mWCharSeq,
               _0RL_CORBA_mWCharSeq_marshal_fn,
               _0RL_CORBA_mWCharSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::WCharSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mWCharSeq,
               _0RL_CORBA_mWCharSeq_marshal_fn,
               _0RL_CORBA_mWCharSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::WCharSeq*& _sp)
{
  return _a >>= (const CORBA::WCharSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::WCharSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mWCharSeq,
                    _0RL_CORBA_mWCharSeq_unmarshal_fn,
                    _0RL_CORBA_mWCharSeq_marshal_fn,
                    _0RL_CORBA_mWCharSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::WCharSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mOctetSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::OctetSeq* _p = (CORBA::OctetSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mOctetSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::OctetSeq* _p = new CORBA::OctetSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mOctetSeq_destructor_fn(void* _v)
{
  CORBA::OctetSeq* _p = (CORBA::OctetSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::OctetSeq& _s)
{
  CORBA::OctetSeq* _p = new CORBA::OctetSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mOctetSeq,
               _0RL_CORBA_mOctetSeq_marshal_fn,
               _0RL_CORBA_mOctetSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::OctetSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mOctetSeq,
               _0RL_CORBA_mOctetSeq_marshal_fn,
               _0RL_CORBA_mOctetSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::OctetSeq*& _sp)
{
  return _a >>= (const CORBA::OctetSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::OctetSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mOctetSeq,
                    _0RL_CORBA_mOctetSeq_unmarshal_fn,
                    _0RL_CORBA_mOctetSeq_marshal_fn,
                    _0RL_CORBA_mOctetSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::OctetSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mShortSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ShortSeq* _p = (CORBA::ShortSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mShortSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ShortSeq* _p = new CORBA::ShortSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mShortSeq_destructor_fn(void* _v)
{
  CORBA::ShortSeq* _p = (CORBA::ShortSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ShortSeq& _s)
{
  CORBA::ShortSeq* _p = new CORBA::ShortSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mShortSeq,
               _0RL_CORBA_mShortSeq_marshal_fn,
               _0RL_CORBA_mShortSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ShortSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mShortSeq,
               _0RL_CORBA_mShortSeq_marshal_fn,
               _0RL_CORBA_mShortSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ShortSeq*& _sp)
{
  return _a >>= (const CORBA::ShortSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ShortSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mShortSeq,
                    _0RL_CORBA_mShortSeq_unmarshal_fn,
                    _0RL_CORBA_mShortSeq_marshal_fn,
                    _0RL_CORBA_mShortSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ShortSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mUShortSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::UShortSeq* _p = (CORBA::UShortSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mUShortSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::UShortSeq* _p = new CORBA::UShortSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mUShortSeq_destructor_fn(void* _v)
{
  CORBA::UShortSeq* _p = (CORBA::UShortSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::UShortSeq& _s)
{
  CORBA::UShortSeq* _p = new CORBA::UShortSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mUShortSeq,
               _0RL_CORBA_mUShortSeq_marshal_fn,
               _0RL_CORBA_mUShortSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::UShortSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mUShortSeq,
               _0RL_CORBA_mUShortSeq_marshal_fn,
               _0RL_CORBA_mUShortSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::UShortSeq*& _sp)
{
  return _a >>= (const CORBA::UShortSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::UShortSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mUShortSeq,
                    _0RL_CORBA_mUShortSeq_unmarshal_fn,
                    _0RL_CORBA_mUShortSeq_marshal_fn,
                    _0RL_CORBA_mUShortSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::UShortSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mLongSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::LongSeq* _p = (CORBA::LongSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mLongSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::LongSeq* _p = new CORBA::LongSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mLongSeq_destructor_fn(void* _v)
{
  CORBA::LongSeq* _p = (CORBA::LongSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::LongSeq& _s)
{
  CORBA::LongSeq* _p = new CORBA::LongSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mLongSeq,
               _0RL_CORBA_mLongSeq_marshal_fn,
               _0RL_CORBA_mLongSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::LongSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mLongSeq,
               _0RL_CORBA_mLongSeq_marshal_fn,
               _0RL_CORBA_mLongSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::LongSeq*& _sp)
{
  return _a >>= (const CORBA::LongSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::LongSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mLongSeq,
                    _0RL_CORBA_mLongSeq_unmarshal_fn,
                    _0RL_CORBA_mLongSeq_marshal_fn,
                    _0RL_CORBA_mLongSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::LongSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mULongSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ULongSeq* _p = (CORBA::ULongSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mULongSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ULongSeq* _p = new CORBA::ULongSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mULongSeq_destructor_fn(void* _v)
{
  CORBA::ULongSeq* _p = (CORBA::ULongSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ULongSeq& _s)
{
  CORBA::ULongSeq* _p = new CORBA::ULongSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mULongSeq,
               _0RL_CORBA_mULongSeq_marshal_fn,
               _0RL_CORBA_mULongSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ULongSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mULongSeq,
               _0RL_CORBA_mULongSeq_marshal_fn,
               _0RL_CORBA_mULongSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ULongSeq*& _sp)
{
  return _a >>= (const CORBA::ULongSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ULongSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mULongSeq,
                    _0RL_CORBA_mULongSeq_unmarshal_fn,
                    _0RL_CORBA_mULongSeq_marshal_fn,
                    _0RL_CORBA_mULongSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ULongSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mLongLongSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::LongLongSeq* _p = (CORBA::LongLongSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mLongLongSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::LongLongSeq* _p = new CORBA::LongLongSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mLongLongSeq_destructor_fn(void* _v)
{
  CORBA::LongLongSeq* _p = (CORBA::LongLongSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::LongLongSeq& _s)
{
  CORBA::LongLongSeq* _p = new CORBA::LongLongSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mLongLongSeq,
               _0RL_CORBA_mLongLongSeq_marshal_fn,
               _0RL_CORBA_mLongLongSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::LongLongSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mLongLongSeq,
               _0RL_CORBA_mLongLongSeq_marshal_fn,
               _0RL_CORBA_mLongLongSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::LongLongSeq*& _sp)
{
  return _a >>= (const CORBA::LongLongSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::LongLongSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mLongLongSeq,
                    _0RL_CORBA_mLongLongSeq_unmarshal_fn,
                    _0RL_CORBA_mLongLongSeq_marshal_fn,
                    _0RL_CORBA_mLongLongSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::LongLongSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mULongLongSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ULongLongSeq* _p = (CORBA::ULongLongSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mULongLongSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ULongLongSeq* _p = new CORBA::ULongLongSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mULongLongSeq_destructor_fn(void* _v)
{
  CORBA::ULongLongSeq* _p = (CORBA::ULongLongSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ULongLongSeq& _s)
{
  CORBA::ULongLongSeq* _p = new CORBA::ULongLongSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mULongLongSeq,
               _0RL_CORBA_mULongLongSeq_marshal_fn,
               _0RL_CORBA_mULongLongSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ULongLongSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mULongLongSeq,
               _0RL_CORBA_mULongLongSeq_marshal_fn,
               _0RL_CORBA_mULongLongSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ULongLongSeq*& _sp)
{
  return _a >>= (const CORBA::ULongLongSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ULongLongSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mULongLongSeq,
                    _0RL_CORBA_mULongLongSeq_unmarshal_fn,
                    _0RL_CORBA_mULongLongSeq_marshal_fn,
                    _0RL_CORBA_mULongLongSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ULongLongSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mFloatSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::FloatSeq* _p = (CORBA::FloatSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mFloatSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::FloatSeq* _p = new CORBA::FloatSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mFloatSeq_destructor_fn(void* _v)
{
  CORBA::FloatSeq* _p = (CORBA::FloatSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::FloatSeq& _s)
{
  CORBA::FloatSeq* _p = new CORBA::FloatSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mFloatSeq,
               _0RL_CORBA_mFloatSeq_marshal_fn,
               _0RL_CORBA_mFloatSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::FloatSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mFloatSeq,
               _0RL_CORBA_mFloatSeq_marshal_fn,
               _0RL_CORBA_mFloatSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::FloatSeq*& _sp)
{
  return _a >>= (const CORBA::FloatSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::FloatSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mFloatSeq,
                    _0RL_CORBA_mFloatSeq_unmarshal_fn,
                    _0RL_CORBA_mFloatSeq_marshal_fn,
                    _0RL_CORBA_mFloatSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::FloatSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mDoubleSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::DoubleSeq* _p = (CORBA::DoubleSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mDoubleSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::DoubleSeq* _p = new CORBA::DoubleSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mDoubleSeq_destructor_fn(void* _v)
{
  CORBA::DoubleSeq* _p = (CORBA::DoubleSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::DoubleSeq& _s)
{
  CORBA::DoubleSeq* _p = new CORBA::DoubleSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mDoubleSeq,
               _0RL_CORBA_mDoubleSeq_marshal_fn,
               _0RL_CORBA_mDoubleSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::DoubleSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mDoubleSeq,
               _0RL_CORBA_mDoubleSeq_marshal_fn,
               _0RL_CORBA_mDoubleSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::DoubleSeq*& _sp)
{
  return _a >>= (const CORBA::DoubleSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::DoubleSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mDoubleSeq,
                    _0RL_CORBA_mDoubleSeq_unmarshal_fn,
                    _0RL_CORBA_mDoubleSeq_marshal_fn,
                    _0RL_CORBA_mDoubleSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::DoubleSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mLongDoubleSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::LongDoubleSeq* _p = (CORBA::LongDoubleSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mLongDoubleSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::LongDoubleSeq* _p = new CORBA::LongDoubleSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mLongDoubleSeq_destructor_fn(void* _v)
{
  CORBA::LongDoubleSeq* _p = (CORBA::LongDoubleSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::LongDoubleSeq& _s)
{
  CORBA::LongDoubleSeq* _p = new CORBA::LongDoubleSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mLongDoubleSeq,
               _0RL_CORBA_mLongDoubleSeq_marshal_fn,
               _0RL_CORBA_mLongDoubleSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::LongDoubleSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mLongDoubleSeq,
               _0RL_CORBA_mLongDoubleSeq_marshal_fn,
               _0RL_CORBA_mLongDoubleSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::LongDoubleSeq*& _sp)
{
  return _a >>= (const CORBA::LongDoubleSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::LongDoubleSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mLongDoubleSeq,
                    _0RL_CORBA_mLongDoubleSeq_unmarshal_fn,
                    _0RL_CORBA_mLongDoubleSeq_marshal_fn,
                    _0RL_CORBA_mLongDoubleSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::LongDoubleSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mStringSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::StringSeq* _p = (CORBA::StringSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mStringSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::StringSeq* _p = new CORBA::StringSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mStringSeq_destructor_fn(void* _v)
{
  CORBA::StringSeq* _p = (CORBA::StringSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::StringSeq& _s)
{
  CORBA::StringSeq* _p = new CORBA::StringSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mStringSeq,
               _0RL_CORBA_mStringSeq_marshal_fn,
               _0RL_CORBA_mStringSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::StringSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mStringSeq,
               _0RL_CORBA_mStringSeq_marshal_fn,
               _0RL_CORBA_mStringSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::StringSeq*& _sp)
{
  return _a >>= (const CORBA::StringSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::StringSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mStringSeq,
                    _0RL_CORBA_mStringSeq_unmarshal_fn,
                    _0RL_CORBA_mStringSeq_marshal_fn,
                    _0RL_CORBA_mStringSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::StringSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mWStringSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::WStringSeq* _p = (CORBA::WStringSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mWStringSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::WStringSeq* _p = new CORBA::WStringSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mWStringSeq_destructor_fn(void* _v)
{
  CORBA::WStringSeq* _p = (CORBA::WStringSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::WStringSeq& _s)
{
  CORBA::WStringSeq* _p = new CORBA::WStringSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mWStringSeq,
               _0RL_CORBA_mWStringSeq_marshal_fn,
               _0RL_CORBA_mWStringSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::WStringSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mWStringSeq,
               _0RL_CORBA_mWStringSeq_marshal_fn,
               _0RL_CORBA_mWStringSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::WStringSeq*& _sp)
{
  return _a >>= (const CORBA::WStringSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::WStringSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mWStringSeq,
                    _0RL_CORBA_mWStringSeq_unmarshal_fn,
                    _0RL_CORBA_mWStringSeq_marshal_fn,
                    _0RL_CORBA_mWStringSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::WStringSeq*)_v;
    return 1;
  }
  return 0;
}

