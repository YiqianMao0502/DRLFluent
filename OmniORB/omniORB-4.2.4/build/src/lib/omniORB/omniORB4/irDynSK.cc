// This file is generated by omniidl (C++ backend) - omniORB_4_2. Do not edit.

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mScopedName = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ScopedName:1.0", "ScopedName", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ScopedName = _0RL_tc_CORBA_mScopedName;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ScopedName = _0RL_tc_CORBA_mScopedName;
#endif

static const char* _0RL_enumMember_CORBA_mDefinitionKind[] = { "dk_none", "dk_all", "dk_Attribute", "dk_Constant", "dk_Exception", "dk_Interface", "dk_Module", "dk_Operation", "dk_Typedef", "dk_Alias", "dk_Struct", "dk_Union", "dk_Enum", "dk_Primitive", "dk_String", "dk_Sequence", "dk_Array", "dk_Repository", "dk_Wstring", "dk_Fixed", "dk_Value", "dk_ValueBox", "dk_ValueMember", "dk_Native", "dk_AbstractInterface" };
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mDefinitionKind = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/CORBA/DefinitionKind:1.0", "DefinitionKind", _0RL_enumMember_CORBA_mDefinitionKind, 25, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_DefinitionKind = _0RL_tc_CORBA_mDefinitionKind;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_DefinitionKind = _0RL_tc_CORBA_mDefinitionKind;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_IRObject = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IRObject:1.0", "IRObject", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_IRObject = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IRObject:1.0", "IRObject", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mContained_mDescription[] = {
  {"kind", _0RL_tc_CORBA_mDefinitionKind},
  {"value", CORBA::TypeCode::PR_any_tc()}
};

#ifdef _0RL_tc_CORBA_mContained_mDescription
#  undef _0RL_tc_CORBA_mContained_mDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mContained_mDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/Contained/Description:1.0", "Description", _0RL_structmember_CORBA_mContained_mDescription, 2, &_0RL_tcTrack);

const CORBA::TypeCode_ptr CORBA::Contained::_tc_Description = _0RL_tc_CORBA_mContained_mDescription;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_Contained = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Contained:1.0", "Contained", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_Contained = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Contained:1.0", "Contained", &_0RL_tcTrack);
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mInterfaceDefSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/InterfaceDefSeq:1.0", "InterfaceDefSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/InterfaceDef:1.0", "InterfaceDef", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_InterfaceDefSeq = _0RL_tc_CORBA_mInterfaceDefSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_InterfaceDefSeq = _0RL_tc_CORBA_mInterfaceDefSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mValueDefSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ValueDefSeq:1.0", "ValueDefSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ValueDef:1.0", "ValueDef", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ValueDefSeq = _0RL_tc_CORBA_mValueDefSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ValueDefSeq = _0RL_tc_CORBA_mValueDefSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mAbstractInterfaceDefSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/AbstractInterfaceDefSeq:1.0", "AbstractInterfaceDefSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/AbstractInterfaceDef:1.0", "AbstractInterfaceDef", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_AbstractInterfaceDefSeq = _0RL_tc_CORBA_mAbstractInterfaceDefSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_AbstractInterfaceDefSeq = _0RL_tc_CORBA_mAbstractInterfaceDefSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mContainedSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ContainedSeq:1.0", "ContainedSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Contained:1.0", "Contained", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ContainedSeq = _0RL_tc_CORBA_mContainedSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ContainedSeq = _0RL_tc_CORBA_mContainedSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mIdentifier = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/Identifier:1.0", "Identifier", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


static CORBA::PR_structMember _0RL_structmember_CORBA_mStructMember[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"type_def", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType", &_0RL_tcTrack)}
};

#ifdef _0RL_tc_CORBA_mStructMember
#  undef _0RL_tc_CORBA_mStructMember
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mStructMember = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/StructMember:1.0", "StructMember", _0RL_structmember_CORBA_mStructMember, 3, &_0RL_tcTrack);

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mStructMemberSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/StructMemberSeq:1.0", "StructMemberSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mStructMember, &_0RL_tcTrack), &_0RL_tcTrack);


static CORBA::PR_structMember _0RL_structmember_CORBA_mInitializer[] = {
  {"members", _0RL_tc_CORBA_mStructMemberSeq},
  {"name", _0RL_tc_CORBA_mIdentifier}
};

#ifdef _0RL_tc_CORBA_mInitializer
#  undef _0RL_tc_CORBA_mInitializer
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mInitializer = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/Initializer:1.0", "Initializer", _0RL_structmember_CORBA_mInitializer, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_Initializer = _0RL_tc_CORBA_mInitializer;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_Initializer = _0RL_tc_CORBA_mInitializer;
#endif










static CORBA::TypeCode_ptr _0RL_tc_CORBA_mInitializerSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/InitializerSeq:1.0", "InitializerSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mInitializer, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_InitializerSeq = _0RL_tc_CORBA_mInitializerSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_InitializerSeq = _0RL_tc_CORBA_mInitializerSeq;
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mContainer_mDescription[] = {
  {"contained_object", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Contained:1.0", "Contained", &_0RL_tcTrack)},
  {"kind", _0RL_tc_CORBA_mDefinitionKind},
  {"value", CORBA::TypeCode::PR_any_tc()}
};

#ifdef _0RL_tc_CORBA_mContainer_mDescription
#  undef _0RL_tc_CORBA_mContainer_mDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mContainer_mDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/Container/Description:1.0", "Description", _0RL_structmember_CORBA_mContainer_mDescription, 3, &_0RL_tcTrack);

const CORBA::TypeCode_ptr CORBA::Container::_tc_Description = _0RL_tc_CORBA_mContainer_mDescription;






static CORBA::TypeCode_ptr _0RL_tc_CORBA_mContainer_mDescriptionSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/Container/DescriptionSeq:1.0", "DescriptionSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mContainer_mDescription, &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr CORBA::Container::_tc_DescriptionSeq = _0RL_tc_CORBA_mContainer_mDescriptionSeq;

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_Container = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Container:1.0", "Container", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_Container = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Container:1.0", "Container", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_IDLType = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_IDLType = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType", &_0RL_tcTrack);
#endif

static const char* _0RL_enumMember_CORBA_mPrimitiveKind[] = { "pk_null", "pk_void", "pk_short", "pk_long", "pk_ushort", "pk_ulong", "pk_float", "pk_double", "pk_boolean", "pk_char", "pk_octet", "pk_any", "pk_TypeCode", "pk_Principal", "pk_string", "pk_objref", "pk_longlong", "pk_ulonglong", "pk_longdouble", "pk_wchar", "pk_wstring", "pk_value_base" };
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mPrimitiveKind = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/CORBA/PrimitiveKind:1.0", "PrimitiveKind", _0RL_enumMember_CORBA_mPrimitiveKind, 22, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_PrimitiveKind = _0RL_tc_CORBA_mPrimitiveKind;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_PrimitiveKind = _0RL_tc_CORBA_mPrimitiveKind;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_Repository = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Repository:1.0", "Repository", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_Repository = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Repository:1.0", "Repository", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ModuleDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ModuleDef:1.0", "ModuleDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ModuleDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ModuleDef:1.0", "ModuleDef", &_0RL_tcTrack);
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mRepositoryId = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/RepositoryId:1.0", "RepositoryId", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


static CORBA::TypeCode_ptr _0RL_tc_CORBA_mVersionSpec = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/VersionSpec:1.0", "VersionSpec", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


static CORBA::PR_structMember _0RL_structmember_CORBA_mModuleDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec}
};

#ifdef _0RL_tc_CORBA_mModuleDescription
#  undef _0RL_tc_CORBA_mModuleDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mModuleDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ModuleDescription:1.0", "ModuleDescription", _0RL_structmember_CORBA_mModuleDescription, 4, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ModuleDescription = _0RL_tc_CORBA_mModuleDescription;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ModuleDescription = _0RL_tc_CORBA_mModuleDescription;
#endif


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ConstantDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ConstantDef:1.0", "ConstantDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ConstantDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ConstantDef:1.0", "ConstantDef", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mConstantDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"value", CORBA::TypeCode::PR_any_tc()}
};

#ifdef _0RL_tc_CORBA_mConstantDescription
#  undef _0RL_tc_CORBA_mConstantDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mConstantDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ConstantDescription:1.0", "ConstantDescription", _0RL_structmember_CORBA_mConstantDescription, 6, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ConstantDescription = _0RL_tc_CORBA_mConstantDescription;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ConstantDescription = _0RL_tc_CORBA_mConstantDescription;
#endif


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_TypedefDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/TypedefDef:1.0", "TypedefDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_TypedefDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/TypedefDef:1.0", "TypedefDef", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mTypeDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()}
};

#ifdef _0RL_tc_CORBA_mTypeDescription
#  undef _0RL_tc_CORBA_mTypeDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mTypeDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/TypeDescription:1.0", "TypeDescription", _0RL_structmember_CORBA_mTypeDescription, 5, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_TypeDescription = _0RL_tc_CORBA_mTypeDescription;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_TypeDescription = _0RL_tc_CORBA_mTypeDescription;
#endif


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_StructDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/StructDef:1.0", "StructDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_StructDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/StructDef:1.0", "StructDef", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_UnionDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/UnionDef:1.0", "UnionDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_UnionDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/UnionDef:1.0", "UnionDef", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_EnumDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/EnumDef:1.0", "EnumDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_EnumDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/EnumDef:1.0", "EnumDef", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_AliasDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/AliasDef:1.0", "AliasDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_AliasDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/AliasDef:1.0", "AliasDef", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_NativeDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/NativeDef:1.0", "NativeDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_NativeDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/NativeDef:1.0", "NativeDef", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_PrimitiveDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/PrimitiveDef:1.0", "PrimitiveDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_PrimitiveDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/PrimitiveDef:1.0", "PrimitiveDef", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_StringDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/StringDef:1.0", "StringDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_StringDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/StringDef:1.0", "StringDef", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_WstringDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/WstringDef:1.0", "WstringDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_WstringDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/WstringDef:1.0", "WstringDef", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_FixedDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/FixedDef:1.0", "FixedDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_FixedDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/FixedDef:1.0", "FixedDef", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_SequenceDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/SequenceDef:1.0", "SequenceDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_SequenceDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/SequenceDef:1.0", "SequenceDef", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ArrayDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ArrayDef:1.0", "ArrayDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ArrayDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ArrayDef:1.0", "ArrayDef", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ExceptionDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ExceptionDef:1.0", "ExceptionDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ExceptionDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ExceptionDef:1.0", "ExceptionDef", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mExceptionDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()}
};

#ifdef _0RL_tc_CORBA_mExceptionDescription
#  undef _0RL_tc_CORBA_mExceptionDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mExceptionDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ExceptionDescription:1.0", "ExceptionDescription", _0RL_structmember_CORBA_mExceptionDescription, 5, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ExceptionDescription = _0RL_tc_CORBA_mExceptionDescription;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ExceptionDescription = _0RL_tc_CORBA_mExceptionDescription;
#endif


static const char* _0RL_enumMember_CORBA_mAttributeMode[] = { "ATTR_NORMAL", "ATTR_READONLY" };
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mAttributeMode = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/CORBA/AttributeMode:1.0", "AttributeMode", _0RL_enumMember_CORBA_mAttributeMode, 2, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_AttributeMode = _0RL_tc_CORBA_mAttributeMode;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_AttributeMode = _0RL_tc_CORBA_mAttributeMode;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_AttributeDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/AttributeDef:1.0", "AttributeDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_AttributeDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/AttributeDef:1.0", "AttributeDef", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mAttributeDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"mode", _0RL_tc_CORBA_mAttributeMode}
};

#ifdef _0RL_tc_CORBA_mAttributeDescription
#  undef _0RL_tc_CORBA_mAttributeDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mAttributeDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/AttributeDescription:1.0", "AttributeDescription", _0RL_structmember_CORBA_mAttributeDescription, 6, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_AttributeDescription = _0RL_tc_CORBA_mAttributeDescription;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_AttributeDescription = _0RL_tc_CORBA_mAttributeDescription;
#endif


static const char* _0RL_enumMember_CORBA_mOperationMode[] = { "OP_NORMAL", "OP_ONEWAY" };
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mOperationMode = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/CORBA/OperationMode:1.0", "OperationMode", _0RL_enumMember_CORBA_mOperationMode, 2, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_OperationMode = _0RL_tc_CORBA_mOperationMode;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_OperationMode = _0RL_tc_CORBA_mOperationMode;
#endif

static const char* _0RL_enumMember_CORBA_mParameterMode[] = { "PARAM_IN", "PARAM_OUT", "PARAM_INOUT" };
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mParameterMode = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/CORBA/ParameterMode:1.0", "ParameterMode", _0RL_enumMember_CORBA_mParameterMode, 3, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ParameterMode = _0RL_tc_CORBA_mParameterMode;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ParameterMode = _0RL_tc_CORBA_mParameterMode;
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mParameterDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"type_def", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType", &_0RL_tcTrack)},
  {"mode", _0RL_tc_CORBA_mParameterMode}
};

#ifdef _0RL_tc_CORBA_mParameterDescription
#  undef _0RL_tc_CORBA_mParameterDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mParameterDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ParameterDescription:1.0", "ParameterDescription", _0RL_structmember_CORBA_mParameterDescription, 4, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ParameterDescription = _0RL_tc_CORBA_mParameterDescription;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ParameterDescription = _0RL_tc_CORBA_mParameterDescription;
#endif






static CORBA::TypeCode_ptr _0RL_tc_CORBA_mParDescriptionSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ParDescriptionSeq:1.0", "ParDescriptionSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mParameterDescription, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ParDescriptionSeq = _0RL_tc_CORBA_mParDescriptionSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ParDescriptionSeq = _0RL_tc_CORBA_mParDescriptionSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mContextIdentifier = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ContextIdentifier:1.0", "ContextIdentifier", _0RL_tc_CORBA_mIdentifier, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ContextIdentifier = _0RL_tc_CORBA_mContextIdentifier;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ContextIdentifier = _0RL_tc_CORBA_mContextIdentifier;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mContextIdSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ContextIdSeq:1.0", "ContextIdSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mContextIdentifier, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ContextIdSeq = _0RL_tc_CORBA_mContextIdSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ContextIdSeq = _0RL_tc_CORBA_mContextIdSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mExceptionDefSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ExceptionDefSeq:1.0", "ExceptionDefSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ExceptionDef:1.0", "ExceptionDef", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ExceptionDefSeq = _0RL_tc_CORBA_mExceptionDefSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ExceptionDefSeq = _0RL_tc_CORBA_mExceptionDefSeq;
#endif





static CORBA::TypeCode_ptr _0RL_tc_CORBA_mExcDescriptionSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ExcDescriptionSeq:1.0", "ExcDescriptionSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mExceptionDescription, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ExcDescriptionSeq = _0RL_tc_CORBA_mExcDescriptionSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ExcDescriptionSeq = _0RL_tc_CORBA_mExcDescriptionSeq;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_OperationDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/OperationDef:1.0", "OperationDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_OperationDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/OperationDef:1.0", "OperationDef", &_0RL_tcTrack);
#endif



static CORBA::PR_structMember _0RL_structmember_CORBA_mOperationDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"result", CORBA::TypeCode::PR_TypeCode_tc()},
  {"mode", _0RL_tc_CORBA_mOperationMode},
  {"contexts", _0RL_tc_CORBA_mContextIdSeq},
  {"parameters", _0RL_tc_CORBA_mParDescriptionSeq},
  {"exceptions", _0RL_tc_CORBA_mExcDescriptionSeq}
};

#ifdef _0RL_tc_CORBA_mOperationDescription
#  undef _0RL_tc_CORBA_mOperationDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mOperationDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/OperationDescription:1.0", "OperationDescription", _0RL_structmember_CORBA_mOperationDescription, 9, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_OperationDescription = _0RL_tc_CORBA_mOperationDescription;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_OperationDescription = _0RL_tc_CORBA_mOperationDescription;
#endif


static CORBA::TypeCode_ptr _0RL_tc_CORBA_mRepositoryIdSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/RepositoryIdSeq:1.0", "RepositoryIdSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mRepositoryId, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_RepositoryIdSeq = _0RL_tc_CORBA_mRepositoryIdSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_RepositoryIdSeq = _0RL_tc_CORBA_mRepositoryIdSeq;
#endif













static CORBA::TypeCode_ptr _0RL_tc_CORBA_mOpDescriptionSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/OpDescriptionSeq:1.0", "OpDescriptionSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mOperationDescription, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_OpDescriptionSeq = _0RL_tc_CORBA_mOpDescriptionSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_OpDescriptionSeq = _0RL_tc_CORBA_mOpDescriptionSeq;
#endif





static CORBA::TypeCode_ptr _0RL_tc_CORBA_mAttrDescriptionSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/AttrDescriptionSeq:1.0", "AttrDescriptionSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mAttributeDescription, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_AttrDescriptionSeq = _0RL_tc_CORBA_mAttrDescriptionSeq;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_AttrDescriptionSeq = _0RL_tc_CORBA_mAttrDescriptionSeq;
#endif





static CORBA::PR_structMember _0RL_structmember_CORBA_mInterfaceDef_mFullInterfaceDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"operations", _0RL_tc_CORBA_mOpDescriptionSeq},
  {"attributes", _0RL_tc_CORBA_mAttrDescriptionSeq},
  {"base_interfaces", _0RL_tc_CORBA_mRepositoryIdSeq},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()}
};

#ifdef _0RL_tc_CORBA_mInterfaceDef_mFullInterfaceDescription
#  undef _0RL_tc_CORBA_mInterfaceDef_mFullInterfaceDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mInterfaceDef_mFullInterfaceDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/InterfaceDef/FullInterfaceDescription:1.0", "FullInterfaceDescription", _0RL_structmember_CORBA_mInterfaceDef_mFullInterfaceDescription, 8, &_0RL_tcTrack);





const CORBA::TypeCode_ptr CORBA::InterfaceDef::_tc_FullInterfaceDescription = _0RL_tc_CORBA_mInterfaceDef_mFullInterfaceDescription;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_InterfaceDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/InterfaceDef:1.0", "InterfaceDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_InterfaceDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/InterfaceDef:1.0", "InterfaceDef", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mInterfaceDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"base_interfaces", _0RL_tc_CORBA_mRepositoryIdSeq}
};

#ifdef _0RL_tc_CORBA_mInterfaceDescription
#  undef _0RL_tc_CORBA_mInterfaceDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mInterfaceDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/InterfaceDescription:1.0", "InterfaceDescription", _0RL_structmember_CORBA_mInterfaceDescription, 5, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_InterfaceDescription = _0RL_tc_CORBA_mInterfaceDescription;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_InterfaceDescription = _0RL_tc_CORBA_mInterfaceDescription;
#endif


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ValueMemberDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ValueMemberDef:1.0", "ValueMemberDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ValueMemberDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ValueMemberDef:1.0", "ValueMemberDef", &_0RL_tcTrack);
#endif





static CORBA::TypeCode_ptr _0RL_tc_CORBA_mVisibility = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/Visibility:1.0", "Visibility", CORBA::TypeCode::PR_short_tc(), &_0RL_tcTrack);


static CORBA::PR_structMember _0RL_structmember_CORBA_mValueMember[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"type_def", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType", &_0RL_tcTrack)},
  {"access", _0RL_tc_CORBA_mVisibility}
};

#ifdef _0RL_tc_CORBA_mValueMember
#  undef _0RL_tc_CORBA_mValueMember
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mValueMember = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ValueMember:1.0", "ValueMember", _0RL_structmember_CORBA_mValueMember, 7, &_0RL_tcTrack);

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mValueMemberSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ValueMemberSeq:1.0", "ValueMemberSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mValueMember, &_0RL_tcTrack), &_0RL_tcTrack);




static CORBA::PR_structMember _0RL_structmember_CORBA_mValueDef_mFullValueDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"is_abstract", CORBA::TypeCode::PR_boolean_tc()},
  {"is_custom", CORBA::TypeCode::PR_boolean_tc()},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"operations", _0RL_tc_CORBA_mOpDescriptionSeq},
  {"attributes", _0RL_tc_CORBA_mAttrDescriptionSeq},
  {"members", _0RL_tc_CORBA_mValueMemberSeq},
  {"initializers", _0RL_tc_CORBA_mInitializerSeq},
  {"supported_interfaces", _0RL_tc_CORBA_mRepositoryIdSeq},
  {"abstract_base_values", _0RL_tc_CORBA_mRepositoryIdSeq},
  {"is_truncatable", CORBA::TypeCode::PR_boolean_tc()},
  {"base_value", _0RL_tc_CORBA_mRepositoryId},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()}
};

#ifdef _0RL_tc_CORBA_mValueDef_mFullValueDescription
#  undef _0RL_tc_CORBA_mValueDef_mFullValueDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mValueDef_mFullValueDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ValueDef/FullValueDescription:1.0", "FullValueDescription", _0RL_structmember_CORBA_mValueDef_mFullValueDescription, 15, &_0RL_tcTrack);








const CORBA::TypeCode_ptr CORBA::ValueDef::_tc_FullValueDescription = _0RL_tc_CORBA_mValueDef_mFullValueDescription;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ValueDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ValueDef:1.0", "ValueDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ValueDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ValueDef:1.0", "ValueDef", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mValueDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"is_abstract", CORBA::TypeCode::PR_boolean_tc()},
  {"is_custom", CORBA::TypeCode::PR_boolean_tc()},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"supported_interfaces", _0RL_tc_CORBA_mRepositoryIdSeq},
  {"abstract_base_values", _0RL_tc_CORBA_mRepositoryIdSeq},
  {"is_truncatable", CORBA::TypeCode::PR_boolean_tc()},
  {"base_value", _0RL_tc_CORBA_mRepositoryId}
};

#ifdef _0RL_tc_CORBA_mValueDescription
#  undef _0RL_tc_CORBA_mValueDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mValueDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ValueDescription:1.0", "ValueDescription", _0RL_structmember_CORBA_mValueDescription, 10, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ValueDescription = _0RL_tc_CORBA_mValueDescription;
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ValueDescription = _0RL_tc_CORBA_mValueDescription;
#endif


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_ValueBoxDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ValueBoxDef:1.0", "ValueBoxDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_ValueBoxDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ValueBoxDef:1.0", "ValueBoxDef", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CORBA { 
  const ::CORBA::TypeCode_ptr _tc_AbstractInterfaceDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/AbstractInterfaceDef:1.0", "AbstractInterfaceDef", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CORBA::_tc_AbstractInterfaceDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/AbstractInterfaceDef:1.0", "AbstractInterfaceDef", &_0RL_tcTrack);
#endif

static void _0RL_CORBA_mDefinitionKind_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::DefinitionKind* _p = (CORBA::DefinitionKind*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mDefinitionKind_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::DefinitionKind* _p = (CORBA::DefinitionKind*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, CORBA::DefinitionKind _s)
{
  _a.PR_insert(_0RL_tc_CORBA_mDefinitionKind,
               _0RL_CORBA_mDefinitionKind_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::DefinitionKind& _s)
{
  return _a.PR_extract(_0RL_tc_CORBA_mDefinitionKind,
                       _0RL_CORBA_mDefinitionKind_unmarshal_fn,
                       &_s);
}

static void _0RL_CORBA_mIRObject_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mIRObject_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::IRObject::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mIRObject_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::IRObject_ptr _o)
{
  CORBA::IRObject_ptr _no = CORBA::IRObject::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_IRObject,
               _0RL_CORBA_mIRObject_marshal_fn,
               _0RL_CORBA_mIRObject_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::IRObject_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_IRObject,
               _0RL_CORBA_mIRObject_marshal_fn,
               _0RL_CORBA_mIRObject_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::IRObject::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::IRObject_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_IRObject,
                    _0RL_CORBA_mIRObject_unmarshal_fn,
                    _0RL_CORBA_mIRObject_marshal_fn,
                    _0RL_CORBA_mIRObject_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::IRObject_ptr)_r->_ptrToObjRef(CORBA::IRObject::_PD_repoId);
    else
      _o = CORBA::IRObject::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mContained_mDescription_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::Contained::Description* _p = (CORBA::Contained::Description*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mContained_mDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::Contained::Description* _p = new CORBA::Contained::Description;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mContained_mDescription_destructor_fn(void* _v)
{
  CORBA::Contained::Description* _p = (CORBA::Contained::Description*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::Contained::Description& _s)
{
  CORBA::Contained::Description* _p = new CORBA::Contained::Description(_s);
  _a.PR_insert(_0RL_tc_CORBA_mContained_mDescription,
               _0RL_CORBA_mContained_mDescription_marshal_fn,
               _0RL_CORBA_mContained_mDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::Contained::Description* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mContained_mDescription,
               _0RL_CORBA_mContained_mDescription_marshal_fn,
               _0RL_CORBA_mContained_mDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::Contained::Description*& _sp)
{
  return _a >>= (const CORBA::Contained::Description*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::Contained::Description*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mContained_mDescription,
                    _0RL_CORBA_mContained_mDescription_unmarshal_fn,
                    _0RL_CORBA_mContained_mDescription_marshal_fn,
                    _0RL_CORBA_mContained_mDescription_destructor_fn,
                    _v)) {
    _sp = (const CORBA::Contained::Description*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mContained_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mContained_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::Contained::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mContained_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::Contained_ptr _o)
{
  CORBA::Contained_ptr _no = CORBA::Contained::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_Contained,
               _0RL_CORBA_mContained_marshal_fn,
               _0RL_CORBA_mContained_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::Contained_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_Contained,
               _0RL_CORBA_mContained_marshal_fn,
               _0RL_CORBA_mContained_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::Contained::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::Contained_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_Contained,
                    _0RL_CORBA_mContained_unmarshal_fn,
                    _0RL_CORBA_mContained_marshal_fn,
                    _0RL_CORBA_mContained_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::Contained_ptr)_r->_ptrToObjRef(CORBA::Contained::_PD_repoId);
    else
      _o = CORBA::Contained::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mInterfaceDefSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::InterfaceDefSeq* _p = (CORBA::InterfaceDefSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mInterfaceDefSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::InterfaceDefSeq* _p = new CORBA::InterfaceDefSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mInterfaceDefSeq_destructor_fn(void* _v)
{
  CORBA::InterfaceDefSeq* _p = (CORBA::InterfaceDefSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::InterfaceDefSeq& _s)
{
  CORBA::InterfaceDefSeq* _p = new CORBA::InterfaceDefSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mInterfaceDefSeq,
               _0RL_CORBA_mInterfaceDefSeq_marshal_fn,
               _0RL_CORBA_mInterfaceDefSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::InterfaceDefSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mInterfaceDefSeq,
               _0RL_CORBA_mInterfaceDefSeq_marshal_fn,
               _0RL_CORBA_mInterfaceDefSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::InterfaceDefSeq*& _sp)
{
  return _a >>= (const CORBA::InterfaceDefSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::InterfaceDefSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mInterfaceDefSeq,
                    _0RL_CORBA_mInterfaceDefSeq_unmarshal_fn,
                    _0RL_CORBA_mInterfaceDefSeq_marshal_fn,
                    _0RL_CORBA_mInterfaceDefSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::InterfaceDefSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mValueDefSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ValueDefSeq* _p = (CORBA::ValueDefSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mValueDefSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ValueDefSeq* _p = new CORBA::ValueDefSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mValueDefSeq_destructor_fn(void* _v)
{
  CORBA::ValueDefSeq* _p = (CORBA::ValueDefSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ValueDefSeq& _s)
{
  CORBA::ValueDefSeq* _p = new CORBA::ValueDefSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mValueDefSeq,
               _0RL_CORBA_mValueDefSeq_marshal_fn,
               _0RL_CORBA_mValueDefSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ValueDefSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mValueDefSeq,
               _0RL_CORBA_mValueDefSeq_marshal_fn,
               _0RL_CORBA_mValueDefSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ValueDefSeq*& _sp)
{
  return _a >>= (const CORBA::ValueDefSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ValueDefSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mValueDefSeq,
                    _0RL_CORBA_mValueDefSeq_unmarshal_fn,
                    _0RL_CORBA_mValueDefSeq_marshal_fn,
                    _0RL_CORBA_mValueDefSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ValueDefSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mAbstractInterfaceDefSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::AbstractInterfaceDefSeq* _p = (CORBA::AbstractInterfaceDefSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mAbstractInterfaceDefSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::AbstractInterfaceDefSeq* _p = new CORBA::AbstractInterfaceDefSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mAbstractInterfaceDefSeq_destructor_fn(void* _v)
{
  CORBA::AbstractInterfaceDefSeq* _p = (CORBA::AbstractInterfaceDefSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::AbstractInterfaceDefSeq& _s)
{
  CORBA::AbstractInterfaceDefSeq* _p = new CORBA::AbstractInterfaceDefSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mAbstractInterfaceDefSeq,
               _0RL_CORBA_mAbstractInterfaceDefSeq_marshal_fn,
               _0RL_CORBA_mAbstractInterfaceDefSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::AbstractInterfaceDefSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mAbstractInterfaceDefSeq,
               _0RL_CORBA_mAbstractInterfaceDefSeq_marshal_fn,
               _0RL_CORBA_mAbstractInterfaceDefSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::AbstractInterfaceDefSeq*& _sp)
{
  return _a >>= (const CORBA::AbstractInterfaceDefSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::AbstractInterfaceDefSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mAbstractInterfaceDefSeq,
                    _0RL_CORBA_mAbstractInterfaceDefSeq_unmarshal_fn,
                    _0RL_CORBA_mAbstractInterfaceDefSeq_marshal_fn,
                    _0RL_CORBA_mAbstractInterfaceDefSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::AbstractInterfaceDefSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mContainedSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ContainedSeq* _p = (CORBA::ContainedSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mContainedSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ContainedSeq* _p = new CORBA::ContainedSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mContainedSeq_destructor_fn(void* _v)
{
  CORBA::ContainedSeq* _p = (CORBA::ContainedSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ContainedSeq& _s)
{
  CORBA::ContainedSeq* _p = new CORBA::ContainedSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mContainedSeq,
               _0RL_CORBA_mContainedSeq_marshal_fn,
               _0RL_CORBA_mContainedSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ContainedSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mContainedSeq,
               _0RL_CORBA_mContainedSeq_marshal_fn,
               _0RL_CORBA_mContainedSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ContainedSeq*& _sp)
{
  return _a >>= (const CORBA::ContainedSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ContainedSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mContainedSeq,
                    _0RL_CORBA_mContainedSeq_unmarshal_fn,
                    _0RL_CORBA_mContainedSeq_marshal_fn,
                    _0RL_CORBA_mContainedSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ContainedSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mInitializer_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::Initializer* _p = (CORBA::Initializer*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mInitializer_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::Initializer* _p = new CORBA::Initializer;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mInitializer_destructor_fn(void* _v)
{
  CORBA::Initializer* _p = (CORBA::Initializer*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::Initializer& _s)
{
  CORBA::Initializer* _p = new CORBA::Initializer(_s);
  _a.PR_insert(_0RL_tc_CORBA_mInitializer,
               _0RL_CORBA_mInitializer_marshal_fn,
               _0RL_CORBA_mInitializer_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::Initializer* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mInitializer,
               _0RL_CORBA_mInitializer_marshal_fn,
               _0RL_CORBA_mInitializer_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::Initializer*& _sp)
{
  return _a >>= (const CORBA::Initializer*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::Initializer*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mInitializer,
                    _0RL_CORBA_mInitializer_unmarshal_fn,
                    _0RL_CORBA_mInitializer_marshal_fn,
                    _0RL_CORBA_mInitializer_destructor_fn,
                    _v)) {
    _sp = (const CORBA::Initializer*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mInitializerSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::InitializerSeq* _p = (CORBA::InitializerSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mInitializerSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::InitializerSeq* _p = new CORBA::InitializerSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mInitializerSeq_destructor_fn(void* _v)
{
  CORBA::InitializerSeq* _p = (CORBA::InitializerSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::InitializerSeq& _s)
{
  CORBA::InitializerSeq* _p = new CORBA::InitializerSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mInitializerSeq,
               _0RL_CORBA_mInitializerSeq_marshal_fn,
               _0RL_CORBA_mInitializerSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::InitializerSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mInitializerSeq,
               _0RL_CORBA_mInitializerSeq_marshal_fn,
               _0RL_CORBA_mInitializerSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::InitializerSeq*& _sp)
{
  return _a >>= (const CORBA::InitializerSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::InitializerSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mInitializerSeq,
                    _0RL_CORBA_mInitializerSeq_unmarshal_fn,
                    _0RL_CORBA_mInitializerSeq_marshal_fn,
                    _0RL_CORBA_mInitializerSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::InitializerSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mContainer_mDescription_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::Container::Description* _p = (CORBA::Container::Description*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mContainer_mDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::Container::Description* _p = new CORBA::Container::Description;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mContainer_mDescription_destructor_fn(void* _v)
{
  CORBA::Container::Description* _p = (CORBA::Container::Description*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::Container::Description& _s)
{
  CORBA::Container::Description* _p = new CORBA::Container::Description(_s);
  _a.PR_insert(_0RL_tc_CORBA_mContainer_mDescription,
               _0RL_CORBA_mContainer_mDescription_marshal_fn,
               _0RL_CORBA_mContainer_mDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::Container::Description* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mContainer_mDescription,
               _0RL_CORBA_mContainer_mDescription_marshal_fn,
               _0RL_CORBA_mContainer_mDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::Container::Description*& _sp)
{
  return _a >>= (const CORBA::Container::Description*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::Container::Description*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mContainer_mDescription,
                    _0RL_CORBA_mContainer_mDescription_unmarshal_fn,
                    _0RL_CORBA_mContainer_mDescription_marshal_fn,
                    _0RL_CORBA_mContainer_mDescription_destructor_fn,
                    _v)) {
    _sp = (const CORBA::Container::Description*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mContainer_mDescriptionSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::Container::DescriptionSeq* _p = (CORBA::Container::DescriptionSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mContainer_mDescriptionSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::Container::DescriptionSeq* _p = new CORBA::Container::DescriptionSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mContainer_mDescriptionSeq_destructor_fn(void* _v)
{
  CORBA::Container::DescriptionSeq* _p = (CORBA::Container::DescriptionSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::Container::DescriptionSeq& _s)
{
  CORBA::Container::DescriptionSeq* _p = new CORBA::Container::DescriptionSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mContainer_mDescriptionSeq,
               _0RL_CORBA_mContainer_mDescriptionSeq_marshal_fn,
               _0RL_CORBA_mContainer_mDescriptionSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::Container::DescriptionSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mContainer_mDescriptionSeq,
               _0RL_CORBA_mContainer_mDescriptionSeq_marshal_fn,
               _0RL_CORBA_mContainer_mDescriptionSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::Container::DescriptionSeq*& _sp)
{
  return _a >>= (const CORBA::Container::DescriptionSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::Container::DescriptionSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mContainer_mDescriptionSeq,
                    _0RL_CORBA_mContainer_mDescriptionSeq_unmarshal_fn,
                    _0RL_CORBA_mContainer_mDescriptionSeq_marshal_fn,
                    _0RL_CORBA_mContainer_mDescriptionSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::Container::DescriptionSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mContainer_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mContainer_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::Container::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mContainer_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::Container_ptr _o)
{
  CORBA::Container_ptr _no = CORBA::Container::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_Container,
               _0RL_CORBA_mContainer_marshal_fn,
               _0RL_CORBA_mContainer_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::Container_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_Container,
               _0RL_CORBA_mContainer_marshal_fn,
               _0RL_CORBA_mContainer_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::Container::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::Container_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_Container,
                    _0RL_CORBA_mContainer_unmarshal_fn,
                    _0RL_CORBA_mContainer_marshal_fn,
                    _0RL_CORBA_mContainer_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::Container_ptr)_r->_ptrToObjRef(CORBA::Container::_PD_repoId);
    else
      _o = CORBA::Container::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mIDLType_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mIDLType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::IDLType::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mIDLType_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::IDLType_ptr _o)
{
  CORBA::IDLType_ptr _no = CORBA::IDLType::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_IDLType,
               _0RL_CORBA_mIDLType_marshal_fn,
               _0RL_CORBA_mIDLType_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::IDLType_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_IDLType,
               _0RL_CORBA_mIDLType_marshal_fn,
               _0RL_CORBA_mIDLType_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::IDLType::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::IDLType_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_IDLType,
                    _0RL_CORBA_mIDLType_unmarshal_fn,
                    _0RL_CORBA_mIDLType_marshal_fn,
                    _0RL_CORBA_mIDLType_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::IDLType_ptr)_r->_ptrToObjRef(CORBA::IDLType::_PD_repoId);
    else
      _o = CORBA::IDLType::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mPrimitiveKind_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::PrimitiveKind* _p = (CORBA::PrimitiveKind*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mPrimitiveKind_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::PrimitiveKind* _p = (CORBA::PrimitiveKind*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, CORBA::PrimitiveKind _s)
{
  _a.PR_insert(_0RL_tc_CORBA_mPrimitiveKind,
               _0RL_CORBA_mPrimitiveKind_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::PrimitiveKind& _s)
{
  return _a.PR_extract(_0RL_tc_CORBA_mPrimitiveKind,
                       _0RL_CORBA_mPrimitiveKind_unmarshal_fn,
                       &_s);
}

static void _0RL_CORBA_mRepository_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mRepository_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::Repository::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mRepository_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::Repository_ptr _o)
{
  CORBA::Repository_ptr _no = CORBA::Repository::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_Repository,
               _0RL_CORBA_mRepository_marshal_fn,
               _0RL_CORBA_mRepository_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::Repository_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_Repository,
               _0RL_CORBA_mRepository_marshal_fn,
               _0RL_CORBA_mRepository_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::Repository::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::Repository_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_Repository,
                    _0RL_CORBA_mRepository_unmarshal_fn,
                    _0RL_CORBA_mRepository_marshal_fn,
                    _0RL_CORBA_mRepository_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::Repository_ptr)_r->_ptrToObjRef(CORBA::Repository::_PD_repoId);
    else
      _o = CORBA::Repository::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mModuleDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mModuleDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::ModuleDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mModuleDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::ModuleDef_ptr _o)
{
  CORBA::ModuleDef_ptr _no = CORBA::ModuleDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_ModuleDef,
               _0RL_CORBA_mModuleDef_marshal_fn,
               _0RL_CORBA_mModuleDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::ModuleDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_ModuleDef,
               _0RL_CORBA_mModuleDef_marshal_fn,
               _0RL_CORBA_mModuleDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::ModuleDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ModuleDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_ModuleDef,
                    _0RL_CORBA_mModuleDef_unmarshal_fn,
                    _0RL_CORBA_mModuleDef_marshal_fn,
                    _0RL_CORBA_mModuleDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::ModuleDef_ptr)_r->_ptrToObjRef(CORBA::ModuleDef::_PD_repoId);
    else
      _o = CORBA::ModuleDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mModuleDescription_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ModuleDescription* _p = (CORBA::ModuleDescription*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mModuleDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ModuleDescription* _p = new CORBA::ModuleDescription;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mModuleDescription_destructor_fn(void* _v)
{
  CORBA::ModuleDescription* _p = (CORBA::ModuleDescription*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ModuleDescription& _s)
{
  CORBA::ModuleDescription* _p = new CORBA::ModuleDescription(_s);
  _a.PR_insert(_0RL_tc_CORBA_mModuleDescription,
               _0RL_CORBA_mModuleDescription_marshal_fn,
               _0RL_CORBA_mModuleDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ModuleDescription* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mModuleDescription,
               _0RL_CORBA_mModuleDescription_marshal_fn,
               _0RL_CORBA_mModuleDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ModuleDescription*& _sp)
{
  return _a >>= (const CORBA::ModuleDescription*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ModuleDescription*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mModuleDescription,
                    _0RL_CORBA_mModuleDescription_unmarshal_fn,
                    _0RL_CORBA_mModuleDescription_marshal_fn,
                    _0RL_CORBA_mModuleDescription_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ModuleDescription*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mConstantDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mConstantDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::ConstantDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mConstantDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::ConstantDef_ptr _o)
{
  CORBA::ConstantDef_ptr _no = CORBA::ConstantDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_ConstantDef,
               _0RL_CORBA_mConstantDef_marshal_fn,
               _0RL_CORBA_mConstantDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::ConstantDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_ConstantDef,
               _0RL_CORBA_mConstantDef_marshal_fn,
               _0RL_CORBA_mConstantDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::ConstantDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ConstantDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_ConstantDef,
                    _0RL_CORBA_mConstantDef_unmarshal_fn,
                    _0RL_CORBA_mConstantDef_marshal_fn,
                    _0RL_CORBA_mConstantDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::ConstantDef_ptr)_r->_ptrToObjRef(CORBA::ConstantDef::_PD_repoId);
    else
      _o = CORBA::ConstantDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mConstantDescription_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ConstantDescription* _p = (CORBA::ConstantDescription*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mConstantDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ConstantDescription* _p = new CORBA::ConstantDescription;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mConstantDescription_destructor_fn(void* _v)
{
  CORBA::ConstantDescription* _p = (CORBA::ConstantDescription*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ConstantDescription& _s)
{
  CORBA::ConstantDescription* _p = new CORBA::ConstantDescription(_s);
  _a.PR_insert(_0RL_tc_CORBA_mConstantDescription,
               _0RL_CORBA_mConstantDescription_marshal_fn,
               _0RL_CORBA_mConstantDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ConstantDescription* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mConstantDescription,
               _0RL_CORBA_mConstantDescription_marshal_fn,
               _0RL_CORBA_mConstantDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ConstantDescription*& _sp)
{
  return _a >>= (const CORBA::ConstantDescription*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ConstantDescription*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mConstantDescription,
                    _0RL_CORBA_mConstantDescription_unmarshal_fn,
                    _0RL_CORBA_mConstantDescription_marshal_fn,
                    _0RL_CORBA_mConstantDescription_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ConstantDescription*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mTypedefDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mTypedefDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::TypedefDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mTypedefDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::TypedefDef_ptr _o)
{
  CORBA::TypedefDef_ptr _no = CORBA::TypedefDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_TypedefDef,
               _0RL_CORBA_mTypedefDef_marshal_fn,
               _0RL_CORBA_mTypedefDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::TypedefDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_TypedefDef,
               _0RL_CORBA_mTypedefDef_marshal_fn,
               _0RL_CORBA_mTypedefDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::TypedefDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::TypedefDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_TypedefDef,
                    _0RL_CORBA_mTypedefDef_unmarshal_fn,
                    _0RL_CORBA_mTypedefDef_marshal_fn,
                    _0RL_CORBA_mTypedefDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::TypedefDef_ptr)_r->_ptrToObjRef(CORBA::TypedefDef::_PD_repoId);
    else
      _o = CORBA::TypedefDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mTypeDescription_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::TypeDescription* _p = (CORBA::TypeDescription*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mTypeDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::TypeDescription* _p = new CORBA::TypeDescription;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mTypeDescription_destructor_fn(void* _v)
{
  CORBA::TypeDescription* _p = (CORBA::TypeDescription*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::TypeDescription& _s)
{
  CORBA::TypeDescription* _p = new CORBA::TypeDescription(_s);
  _a.PR_insert(_0RL_tc_CORBA_mTypeDescription,
               _0RL_CORBA_mTypeDescription_marshal_fn,
               _0RL_CORBA_mTypeDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::TypeDescription* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mTypeDescription,
               _0RL_CORBA_mTypeDescription_marshal_fn,
               _0RL_CORBA_mTypeDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::TypeDescription*& _sp)
{
  return _a >>= (const CORBA::TypeDescription*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::TypeDescription*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mTypeDescription,
                    _0RL_CORBA_mTypeDescription_unmarshal_fn,
                    _0RL_CORBA_mTypeDescription_marshal_fn,
                    _0RL_CORBA_mTypeDescription_destructor_fn,
                    _v)) {
    _sp = (const CORBA::TypeDescription*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mStructDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mStructDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::StructDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mStructDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::StructDef_ptr _o)
{
  CORBA::StructDef_ptr _no = CORBA::StructDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_StructDef,
               _0RL_CORBA_mStructDef_marshal_fn,
               _0RL_CORBA_mStructDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::StructDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_StructDef,
               _0RL_CORBA_mStructDef_marshal_fn,
               _0RL_CORBA_mStructDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::StructDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::StructDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_StructDef,
                    _0RL_CORBA_mStructDef_unmarshal_fn,
                    _0RL_CORBA_mStructDef_marshal_fn,
                    _0RL_CORBA_mStructDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::StructDef_ptr)_r->_ptrToObjRef(CORBA::StructDef::_PD_repoId);
    else
      _o = CORBA::StructDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mUnionDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mUnionDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::UnionDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mUnionDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::UnionDef_ptr _o)
{
  CORBA::UnionDef_ptr _no = CORBA::UnionDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_UnionDef,
               _0RL_CORBA_mUnionDef_marshal_fn,
               _0RL_CORBA_mUnionDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::UnionDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_UnionDef,
               _0RL_CORBA_mUnionDef_marshal_fn,
               _0RL_CORBA_mUnionDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::UnionDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::UnionDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_UnionDef,
                    _0RL_CORBA_mUnionDef_unmarshal_fn,
                    _0RL_CORBA_mUnionDef_marshal_fn,
                    _0RL_CORBA_mUnionDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::UnionDef_ptr)_r->_ptrToObjRef(CORBA::UnionDef::_PD_repoId);
    else
      _o = CORBA::UnionDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mEnumDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mEnumDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::EnumDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mEnumDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::EnumDef_ptr _o)
{
  CORBA::EnumDef_ptr _no = CORBA::EnumDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_EnumDef,
               _0RL_CORBA_mEnumDef_marshal_fn,
               _0RL_CORBA_mEnumDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::EnumDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_EnumDef,
               _0RL_CORBA_mEnumDef_marshal_fn,
               _0RL_CORBA_mEnumDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::EnumDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::EnumDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_EnumDef,
                    _0RL_CORBA_mEnumDef_unmarshal_fn,
                    _0RL_CORBA_mEnumDef_marshal_fn,
                    _0RL_CORBA_mEnumDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::EnumDef_ptr)_r->_ptrToObjRef(CORBA::EnumDef::_PD_repoId);
    else
      _o = CORBA::EnumDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mAliasDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mAliasDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::AliasDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mAliasDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::AliasDef_ptr _o)
{
  CORBA::AliasDef_ptr _no = CORBA::AliasDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_AliasDef,
               _0RL_CORBA_mAliasDef_marshal_fn,
               _0RL_CORBA_mAliasDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::AliasDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_AliasDef,
               _0RL_CORBA_mAliasDef_marshal_fn,
               _0RL_CORBA_mAliasDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::AliasDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::AliasDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_AliasDef,
                    _0RL_CORBA_mAliasDef_unmarshal_fn,
                    _0RL_CORBA_mAliasDef_marshal_fn,
                    _0RL_CORBA_mAliasDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::AliasDef_ptr)_r->_ptrToObjRef(CORBA::AliasDef::_PD_repoId);
    else
      _o = CORBA::AliasDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mNativeDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mNativeDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::NativeDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mNativeDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::NativeDef_ptr _o)
{
  CORBA::NativeDef_ptr _no = CORBA::NativeDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_NativeDef,
               _0RL_CORBA_mNativeDef_marshal_fn,
               _0RL_CORBA_mNativeDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::NativeDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_NativeDef,
               _0RL_CORBA_mNativeDef_marshal_fn,
               _0RL_CORBA_mNativeDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::NativeDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::NativeDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_NativeDef,
                    _0RL_CORBA_mNativeDef_unmarshal_fn,
                    _0RL_CORBA_mNativeDef_marshal_fn,
                    _0RL_CORBA_mNativeDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::NativeDef_ptr)_r->_ptrToObjRef(CORBA::NativeDef::_PD_repoId);
    else
      _o = CORBA::NativeDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mPrimitiveDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mPrimitiveDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::PrimitiveDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mPrimitiveDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::PrimitiveDef_ptr _o)
{
  CORBA::PrimitiveDef_ptr _no = CORBA::PrimitiveDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_PrimitiveDef,
               _0RL_CORBA_mPrimitiveDef_marshal_fn,
               _0RL_CORBA_mPrimitiveDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::PrimitiveDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_PrimitiveDef,
               _0RL_CORBA_mPrimitiveDef_marshal_fn,
               _0RL_CORBA_mPrimitiveDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::PrimitiveDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::PrimitiveDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_PrimitiveDef,
                    _0RL_CORBA_mPrimitiveDef_unmarshal_fn,
                    _0RL_CORBA_mPrimitiveDef_marshal_fn,
                    _0RL_CORBA_mPrimitiveDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::PrimitiveDef_ptr)_r->_ptrToObjRef(CORBA::PrimitiveDef::_PD_repoId);
    else
      _o = CORBA::PrimitiveDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mStringDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mStringDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::StringDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mStringDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::StringDef_ptr _o)
{
  CORBA::StringDef_ptr _no = CORBA::StringDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_StringDef,
               _0RL_CORBA_mStringDef_marshal_fn,
               _0RL_CORBA_mStringDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::StringDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_StringDef,
               _0RL_CORBA_mStringDef_marshal_fn,
               _0RL_CORBA_mStringDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::StringDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::StringDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_StringDef,
                    _0RL_CORBA_mStringDef_unmarshal_fn,
                    _0RL_CORBA_mStringDef_marshal_fn,
                    _0RL_CORBA_mStringDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::StringDef_ptr)_r->_ptrToObjRef(CORBA::StringDef::_PD_repoId);
    else
      _o = CORBA::StringDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mWstringDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mWstringDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::WstringDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mWstringDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::WstringDef_ptr _o)
{
  CORBA::WstringDef_ptr _no = CORBA::WstringDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_WstringDef,
               _0RL_CORBA_mWstringDef_marshal_fn,
               _0RL_CORBA_mWstringDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::WstringDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_WstringDef,
               _0RL_CORBA_mWstringDef_marshal_fn,
               _0RL_CORBA_mWstringDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::WstringDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::WstringDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_WstringDef,
                    _0RL_CORBA_mWstringDef_unmarshal_fn,
                    _0RL_CORBA_mWstringDef_marshal_fn,
                    _0RL_CORBA_mWstringDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::WstringDef_ptr)_r->_ptrToObjRef(CORBA::WstringDef::_PD_repoId);
    else
      _o = CORBA::WstringDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mFixedDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mFixedDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::FixedDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mFixedDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::FixedDef_ptr _o)
{
  CORBA::FixedDef_ptr _no = CORBA::FixedDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_FixedDef,
               _0RL_CORBA_mFixedDef_marshal_fn,
               _0RL_CORBA_mFixedDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::FixedDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_FixedDef,
               _0RL_CORBA_mFixedDef_marshal_fn,
               _0RL_CORBA_mFixedDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::FixedDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::FixedDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_FixedDef,
                    _0RL_CORBA_mFixedDef_unmarshal_fn,
                    _0RL_CORBA_mFixedDef_marshal_fn,
                    _0RL_CORBA_mFixedDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::FixedDef_ptr)_r->_ptrToObjRef(CORBA::FixedDef::_PD_repoId);
    else
      _o = CORBA::FixedDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mSequenceDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mSequenceDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::SequenceDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mSequenceDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::SequenceDef_ptr _o)
{
  CORBA::SequenceDef_ptr _no = CORBA::SequenceDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_SequenceDef,
               _0RL_CORBA_mSequenceDef_marshal_fn,
               _0RL_CORBA_mSequenceDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::SequenceDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_SequenceDef,
               _0RL_CORBA_mSequenceDef_marshal_fn,
               _0RL_CORBA_mSequenceDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::SequenceDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::SequenceDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_SequenceDef,
                    _0RL_CORBA_mSequenceDef_unmarshal_fn,
                    _0RL_CORBA_mSequenceDef_marshal_fn,
                    _0RL_CORBA_mSequenceDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::SequenceDef_ptr)_r->_ptrToObjRef(CORBA::SequenceDef::_PD_repoId);
    else
      _o = CORBA::SequenceDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mArrayDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mArrayDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::ArrayDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mArrayDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::ArrayDef_ptr _o)
{
  CORBA::ArrayDef_ptr _no = CORBA::ArrayDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_ArrayDef,
               _0RL_CORBA_mArrayDef_marshal_fn,
               _0RL_CORBA_mArrayDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::ArrayDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_ArrayDef,
               _0RL_CORBA_mArrayDef_marshal_fn,
               _0RL_CORBA_mArrayDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::ArrayDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ArrayDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_ArrayDef,
                    _0RL_CORBA_mArrayDef_unmarshal_fn,
                    _0RL_CORBA_mArrayDef_marshal_fn,
                    _0RL_CORBA_mArrayDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::ArrayDef_ptr)_r->_ptrToObjRef(CORBA::ArrayDef::_PD_repoId);
    else
      _o = CORBA::ArrayDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mExceptionDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mExceptionDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::ExceptionDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mExceptionDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::ExceptionDef_ptr _o)
{
  CORBA::ExceptionDef_ptr _no = CORBA::ExceptionDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_ExceptionDef,
               _0RL_CORBA_mExceptionDef_marshal_fn,
               _0RL_CORBA_mExceptionDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::ExceptionDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_ExceptionDef,
               _0RL_CORBA_mExceptionDef_marshal_fn,
               _0RL_CORBA_mExceptionDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::ExceptionDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ExceptionDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_ExceptionDef,
                    _0RL_CORBA_mExceptionDef_unmarshal_fn,
                    _0RL_CORBA_mExceptionDef_marshal_fn,
                    _0RL_CORBA_mExceptionDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::ExceptionDef_ptr)_r->_ptrToObjRef(CORBA::ExceptionDef::_PD_repoId);
    else
      _o = CORBA::ExceptionDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mExceptionDescription_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ExceptionDescription* _p = (CORBA::ExceptionDescription*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mExceptionDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ExceptionDescription* _p = new CORBA::ExceptionDescription;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mExceptionDescription_destructor_fn(void* _v)
{
  CORBA::ExceptionDescription* _p = (CORBA::ExceptionDescription*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ExceptionDescription& _s)
{
  CORBA::ExceptionDescription* _p = new CORBA::ExceptionDescription(_s);
  _a.PR_insert(_0RL_tc_CORBA_mExceptionDescription,
               _0RL_CORBA_mExceptionDescription_marshal_fn,
               _0RL_CORBA_mExceptionDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ExceptionDescription* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mExceptionDescription,
               _0RL_CORBA_mExceptionDescription_marshal_fn,
               _0RL_CORBA_mExceptionDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ExceptionDescription*& _sp)
{
  return _a >>= (const CORBA::ExceptionDescription*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ExceptionDescription*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mExceptionDescription,
                    _0RL_CORBA_mExceptionDescription_unmarshal_fn,
                    _0RL_CORBA_mExceptionDescription_marshal_fn,
                    _0RL_CORBA_mExceptionDescription_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ExceptionDescription*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mAttributeMode_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::AttributeMode* _p = (CORBA::AttributeMode*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mAttributeMode_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::AttributeMode* _p = (CORBA::AttributeMode*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, CORBA::AttributeMode _s)
{
  _a.PR_insert(_0RL_tc_CORBA_mAttributeMode,
               _0RL_CORBA_mAttributeMode_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::AttributeMode& _s)
{
  return _a.PR_extract(_0RL_tc_CORBA_mAttributeMode,
                       _0RL_CORBA_mAttributeMode_unmarshal_fn,
                       &_s);
}

static void _0RL_CORBA_mAttributeDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mAttributeDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::AttributeDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mAttributeDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::AttributeDef_ptr _o)
{
  CORBA::AttributeDef_ptr _no = CORBA::AttributeDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_AttributeDef,
               _0RL_CORBA_mAttributeDef_marshal_fn,
               _0RL_CORBA_mAttributeDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::AttributeDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_AttributeDef,
               _0RL_CORBA_mAttributeDef_marshal_fn,
               _0RL_CORBA_mAttributeDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::AttributeDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::AttributeDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_AttributeDef,
                    _0RL_CORBA_mAttributeDef_unmarshal_fn,
                    _0RL_CORBA_mAttributeDef_marshal_fn,
                    _0RL_CORBA_mAttributeDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::AttributeDef_ptr)_r->_ptrToObjRef(CORBA::AttributeDef::_PD_repoId);
    else
      _o = CORBA::AttributeDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mAttributeDescription_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::AttributeDescription* _p = (CORBA::AttributeDescription*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mAttributeDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::AttributeDescription* _p = new CORBA::AttributeDescription;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mAttributeDescription_destructor_fn(void* _v)
{
  CORBA::AttributeDescription* _p = (CORBA::AttributeDescription*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::AttributeDescription& _s)
{
  CORBA::AttributeDescription* _p = new CORBA::AttributeDescription(_s);
  _a.PR_insert(_0RL_tc_CORBA_mAttributeDescription,
               _0RL_CORBA_mAttributeDescription_marshal_fn,
               _0RL_CORBA_mAttributeDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::AttributeDescription* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mAttributeDescription,
               _0RL_CORBA_mAttributeDescription_marshal_fn,
               _0RL_CORBA_mAttributeDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::AttributeDescription*& _sp)
{
  return _a >>= (const CORBA::AttributeDescription*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::AttributeDescription*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mAttributeDescription,
                    _0RL_CORBA_mAttributeDescription_unmarshal_fn,
                    _0RL_CORBA_mAttributeDescription_marshal_fn,
                    _0RL_CORBA_mAttributeDescription_destructor_fn,
                    _v)) {
    _sp = (const CORBA::AttributeDescription*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mOperationMode_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::OperationMode* _p = (CORBA::OperationMode*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mOperationMode_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::OperationMode* _p = (CORBA::OperationMode*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, CORBA::OperationMode _s)
{
  _a.PR_insert(_0RL_tc_CORBA_mOperationMode,
               _0RL_CORBA_mOperationMode_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::OperationMode& _s)
{
  return _a.PR_extract(_0RL_tc_CORBA_mOperationMode,
                       _0RL_CORBA_mOperationMode_unmarshal_fn,
                       &_s);
}

static void _0RL_CORBA_mParameterMode_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ParameterMode* _p = (CORBA::ParameterMode*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mParameterMode_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ParameterMode* _p = (CORBA::ParameterMode*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, CORBA::ParameterMode _s)
{
  _a.PR_insert(_0RL_tc_CORBA_mParameterMode,
               _0RL_CORBA_mParameterMode_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ParameterMode& _s)
{
  return _a.PR_extract(_0RL_tc_CORBA_mParameterMode,
                       _0RL_CORBA_mParameterMode_unmarshal_fn,
                       &_s);
}

static void _0RL_CORBA_mParameterDescription_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ParameterDescription* _p = (CORBA::ParameterDescription*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mParameterDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ParameterDescription* _p = new CORBA::ParameterDescription;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mParameterDescription_destructor_fn(void* _v)
{
  CORBA::ParameterDescription* _p = (CORBA::ParameterDescription*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ParameterDescription& _s)
{
  CORBA::ParameterDescription* _p = new CORBA::ParameterDescription(_s);
  _a.PR_insert(_0RL_tc_CORBA_mParameterDescription,
               _0RL_CORBA_mParameterDescription_marshal_fn,
               _0RL_CORBA_mParameterDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ParameterDescription* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mParameterDescription,
               _0RL_CORBA_mParameterDescription_marshal_fn,
               _0RL_CORBA_mParameterDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ParameterDescription*& _sp)
{
  return _a >>= (const CORBA::ParameterDescription*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ParameterDescription*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mParameterDescription,
                    _0RL_CORBA_mParameterDescription_unmarshal_fn,
                    _0RL_CORBA_mParameterDescription_marshal_fn,
                    _0RL_CORBA_mParameterDescription_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ParameterDescription*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mParDescriptionSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ParDescriptionSeq* _p = (CORBA::ParDescriptionSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mParDescriptionSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ParDescriptionSeq* _p = new CORBA::ParDescriptionSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mParDescriptionSeq_destructor_fn(void* _v)
{
  CORBA::ParDescriptionSeq* _p = (CORBA::ParDescriptionSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ParDescriptionSeq& _s)
{
  CORBA::ParDescriptionSeq* _p = new CORBA::ParDescriptionSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mParDescriptionSeq,
               _0RL_CORBA_mParDescriptionSeq_marshal_fn,
               _0RL_CORBA_mParDescriptionSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ParDescriptionSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mParDescriptionSeq,
               _0RL_CORBA_mParDescriptionSeq_marshal_fn,
               _0RL_CORBA_mParDescriptionSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ParDescriptionSeq*& _sp)
{
  return _a >>= (const CORBA::ParDescriptionSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ParDescriptionSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mParDescriptionSeq,
                    _0RL_CORBA_mParDescriptionSeq_unmarshal_fn,
                    _0RL_CORBA_mParDescriptionSeq_marshal_fn,
                    _0RL_CORBA_mParDescriptionSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ParDescriptionSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mContextIdSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ContextIdSeq* _p = (CORBA::ContextIdSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mContextIdSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ContextIdSeq* _p = new CORBA::ContextIdSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mContextIdSeq_destructor_fn(void* _v)
{
  CORBA::ContextIdSeq* _p = (CORBA::ContextIdSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ContextIdSeq& _s)
{
  CORBA::ContextIdSeq* _p = new CORBA::ContextIdSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mContextIdSeq,
               _0RL_CORBA_mContextIdSeq_marshal_fn,
               _0RL_CORBA_mContextIdSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ContextIdSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mContextIdSeq,
               _0RL_CORBA_mContextIdSeq_marshal_fn,
               _0RL_CORBA_mContextIdSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ContextIdSeq*& _sp)
{
  return _a >>= (const CORBA::ContextIdSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ContextIdSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mContextIdSeq,
                    _0RL_CORBA_mContextIdSeq_unmarshal_fn,
                    _0RL_CORBA_mContextIdSeq_marshal_fn,
                    _0RL_CORBA_mContextIdSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ContextIdSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mExceptionDefSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ExceptionDefSeq* _p = (CORBA::ExceptionDefSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mExceptionDefSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ExceptionDefSeq* _p = new CORBA::ExceptionDefSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mExceptionDefSeq_destructor_fn(void* _v)
{
  CORBA::ExceptionDefSeq* _p = (CORBA::ExceptionDefSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ExceptionDefSeq& _s)
{
  CORBA::ExceptionDefSeq* _p = new CORBA::ExceptionDefSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mExceptionDefSeq,
               _0RL_CORBA_mExceptionDefSeq_marshal_fn,
               _0RL_CORBA_mExceptionDefSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ExceptionDefSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mExceptionDefSeq,
               _0RL_CORBA_mExceptionDefSeq_marshal_fn,
               _0RL_CORBA_mExceptionDefSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ExceptionDefSeq*& _sp)
{
  return _a >>= (const CORBA::ExceptionDefSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ExceptionDefSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mExceptionDefSeq,
                    _0RL_CORBA_mExceptionDefSeq_unmarshal_fn,
                    _0RL_CORBA_mExceptionDefSeq_marshal_fn,
                    _0RL_CORBA_mExceptionDefSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ExceptionDefSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mExcDescriptionSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ExcDescriptionSeq* _p = (CORBA::ExcDescriptionSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mExcDescriptionSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ExcDescriptionSeq* _p = new CORBA::ExcDescriptionSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mExcDescriptionSeq_destructor_fn(void* _v)
{
  CORBA::ExcDescriptionSeq* _p = (CORBA::ExcDescriptionSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ExcDescriptionSeq& _s)
{
  CORBA::ExcDescriptionSeq* _p = new CORBA::ExcDescriptionSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mExcDescriptionSeq,
               _0RL_CORBA_mExcDescriptionSeq_marshal_fn,
               _0RL_CORBA_mExcDescriptionSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ExcDescriptionSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mExcDescriptionSeq,
               _0RL_CORBA_mExcDescriptionSeq_marshal_fn,
               _0RL_CORBA_mExcDescriptionSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ExcDescriptionSeq*& _sp)
{
  return _a >>= (const CORBA::ExcDescriptionSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ExcDescriptionSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mExcDescriptionSeq,
                    _0RL_CORBA_mExcDescriptionSeq_unmarshal_fn,
                    _0RL_CORBA_mExcDescriptionSeq_marshal_fn,
                    _0RL_CORBA_mExcDescriptionSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ExcDescriptionSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mOperationDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mOperationDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::OperationDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mOperationDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::OperationDef_ptr _o)
{
  CORBA::OperationDef_ptr _no = CORBA::OperationDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_OperationDef,
               _0RL_CORBA_mOperationDef_marshal_fn,
               _0RL_CORBA_mOperationDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::OperationDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_OperationDef,
               _0RL_CORBA_mOperationDef_marshal_fn,
               _0RL_CORBA_mOperationDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::OperationDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::OperationDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_OperationDef,
                    _0RL_CORBA_mOperationDef_unmarshal_fn,
                    _0RL_CORBA_mOperationDef_marshal_fn,
                    _0RL_CORBA_mOperationDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::OperationDef_ptr)_r->_ptrToObjRef(CORBA::OperationDef::_PD_repoId);
    else
      _o = CORBA::OperationDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mOperationDescription_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::OperationDescription* _p = (CORBA::OperationDescription*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mOperationDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::OperationDescription* _p = new CORBA::OperationDescription;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mOperationDescription_destructor_fn(void* _v)
{
  CORBA::OperationDescription* _p = (CORBA::OperationDescription*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::OperationDescription& _s)
{
  CORBA::OperationDescription* _p = new CORBA::OperationDescription(_s);
  _a.PR_insert(_0RL_tc_CORBA_mOperationDescription,
               _0RL_CORBA_mOperationDescription_marshal_fn,
               _0RL_CORBA_mOperationDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::OperationDescription* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mOperationDescription,
               _0RL_CORBA_mOperationDescription_marshal_fn,
               _0RL_CORBA_mOperationDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::OperationDescription*& _sp)
{
  return _a >>= (const CORBA::OperationDescription*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::OperationDescription*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mOperationDescription,
                    _0RL_CORBA_mOperationDescription_unmarshal_fn,
                    _0RL_CORBA_mOperationDescription_marshal_fn,
                    _0RL_CORBA_mOperationDescription_destructor_fn,
                    _v)) {
    _sp = (const CORBA::OperationDescription*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mRepositoryIdSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::RepositoryIdSeq* _p = (CORBA::RepositoryIdSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mRepositoryIdSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::RepositoryIdSeq* _p = new CORBA::RepositoryIdSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mRepositoryIdSeq_destructor_fn(void* _v)
{
  CORBA::RepositoryIdSeq* _p = (CORBA::RepositoryIdSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::RepositoryIdSeq& _s)
{
  CORBA::RepositoryIdSeq* _p = new CORBA::RepositoryIdSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mRepositoryIdSeq,
               _0RL_CORBA_mRepositoryIdSeq_marshal_fn,
               _0RL_CORBA_mRepositoryIdSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::RepositoryIdSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mRepositoryIdSeq,
               _0RL_CORBA_mRepositoryIdSeq_marshal_fn,
               _0RL_CORBA_mRepositoryIdSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::RepositoryIdSeq*& _sp)
{
  return _a >>= (const CORBA::RepositoryIdSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::RepositoryIdSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mRepositoryIdSeq,
                    _0RL_CORBA_mRepositoryIdSeq_unmarshal_fn,
                    _0RL_CORBA_mRepositoryIdSeq_marshal_fn,
                    _0RL_CORBA_mRepositoryIdSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::RepositoryIdSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mOpDescriptionSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::OpDescriptionSeq* _p = (CORBA::OpDescriptionSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mOpDescriptionSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::OpDescriptionSeq* _p = new CORBA::OpDescriptionSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mOpDescriptionSeq_destructor_fn(void* _v)
{
  CORBA::OpDescriptionSeq* _p = (CORBA::OpDescriptionSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::OpDescriptionSeq& _s)
{
  CORBA::OpDescriptionSeq* _p = new CORBA::OpDescriptionSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mOpDescriptionSeq,
               _0RL_CORBA_mOpDescriptionSeq_marshal_fn,
               _0RL_CORBA_mOpDescriptionSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::OpDescriptionSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mOpDescriptionSeq,
               _0RL_CORBA_mOpDescriptionSeq_marshal_fn,
               _0RL_CORBA_mOpDescriptionSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::OpDescriptionSeq*& _sp)
{
  return _a >>= (const CORBA::OpDescriptionSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::OpDescriptionSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mOpDescriptionSeq,
                    _0RL_CORBA_mOpDescriptionSeq_unmarshal_fn,
                    _0RL_CORBA_mOpDescriptionSeq_marshal_fn,
                    _0RL_CORBA_mOpDescriptionSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::OpDescriptionSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mAttrDescriptionSeq_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::AttrDescriptionSeq* _p = (CORBA::AttrDescriptionSeq*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mAttrDescriptionSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::AttrDescriptionSeq* _p = new CORBA::AttrDescriptionSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mAttrDescriptionSeq_destructor_fn(void* _v)
{
  CORBA::AttrDescriptionSeq* _p = (CORBA::AttrDescriptionSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::AttrDescriptionSeq& _s)
{
  CORBA::AttrDescriptionSeq* _p = new CORBA::AttrDescriptionSeq(_s);
  _a.PR_insert(_0RL_tc_CORBA_mAttrDescriptionSeq,
               _0RL_CORBA_mAttrDescriptionSeq_marshal_fn,
               _0RL_CORBA_mAttrDescriptionSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::AttrDescriptionSeq* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mAttrDescriptionSeq,
               _0RL_CORBA_mAttrDescriptionSeq_marshal_fn,
               _0RL_CORBA_mAttrDescriptionSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::AttrDescriptionSeq*& _sp)
{
  return _a >>= (const CORBA::AttrDescriptionSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::AttrDescriptionSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mAttrDescriptionSeq,
                    _0RL_CORBA_mAttrDescriptionSeq_unmarshal_fn,
                    _0RL_CORBA_mAttrDescriptionSeq_marshal_fn,
                    _0RL_CORBA_mAttrDescriptionSeq_destructor_fn,
                    _v)) {
    _sp = (const CORBA::AttrDescriptionSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mInterfaceDef_mFullInterfaceDescription_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::InterfaceDef::FullInterfaceDescription* _p = (CORBA::InterfaceDef::FullInterfaceDescription*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mInterfaceDef_mFullInterfaceDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::InterfaceDef::FullInterfaceDescription* _p = new CORBA::InterfaceDef::FullInterfaceDescription;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mInterfaceDef_mFullInterfaceDescription_destructor_fn(void* _v)
{
  CORBA::InterfaceDef::FullInterfaceDescription* _p = (CORBA::InterfaceDef::FullInterfaceDescription*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::InterfaceDef::FullInterfaceDescription& _s)
{
  CORBA::InterfaceDef::FullInterfaceDescription* _p = new CORBA::InterfaceDef::FullInterfaceDescription(_s);
  _a.PR_insert(_0RL_tc_CORBA_mInterfaceDef_mFullInterfaceDescription,
               _0RL_CORBA_mInterfaceDef_mFullInterfaceDescription_marshal_fn,
               _0RL_CORBA_mInterfaceDef_mFullInterfaceDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::InterfaceDef::FullInterfaceDescription* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mInterfaceDef_mFullInterfaceDescription,
               _0RL_CORBA_mInterfaceDef_mFullInterfaceDescription_marshal_fn,
               _0RL_CORBA_mInterfaceDef_mFullInterfaceDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::InterfaceDef::FullInterfaceDescription*& _sp)
{
  return _a >>= (const CORBA::InterfaceDef::FullInterfaceDescription*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::InterfaceDef::FullInterfaceDescription*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mInterfaceDef_mFullInterfaceDescription,
                    _0RL_CORBA_mInterfaceDef_mFullInterfaceDescription_unmarshal_fn,
                    _0RL_CORBA_mInterfaceDef_mFullInterfaceDescription_marshal_fn,
                    _0RL_CORBA_mInterfaceDef_mFullInterfaceDescription_destructor_fn,
                    _v)) {
    _sp = (const CORBA::InterfaceDef::FullInterfaceDescription*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mInterfaceDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mInterfaceDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::InterfaceDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mInterfaceDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::InterfaceDef_ptr _o)
{
  CORBA::InterfaceDef_ptr _no = CORBA::InterfaceDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_InterfaceDef,
               _0RL_CORBA_mInterfaceDef_marshal_fn,
               _0RL_CORBA_mInterfaceDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::InterfaceDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_InterfaceDef,
               _0RL_CORBA_mInterfaceDef_marshal_fn,
               _0RL_CORBA_mInterfaceDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::InterfaceDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::InterfaceDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_InterfaceDef,
                    _0RL_CORBA_mInterfaceDef_unmarshal_fn,
                    _0RL_CORBA_mInterfaceDef_marshal_fn,
                    _0RL_CORBA_mInterfaceDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::InterfaceDef_ptr)_r->_ptrToObjRef(CORBA::InterfaceDef::_PD_repoId);
    else
      _o = CORBA::InterfaceDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mInterfaceDescription_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::InterfaceDescription* _p = (CORBA::InterfaceDescription*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mInterfaceDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::InterfaceDescription* _p = new CORBA::InterfaceDescription;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mInterfaceDescription_destructor_fn(void* _v)
{
  CORBA::InterfaceDescription* _p = (CORBA::InterfaceDescription*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::InterfaceDescription& _s)
{
  CORBA::InterfaceDescription* _p = new CORBA::InterfaceDescription(_s);
  _a.PR_insert(_0RL_tc_CORBA_mInterfaceDescription,
               _0RL_CORBA_mInterfaceDescription_marshal_fn,
               _0RL_CORBA_mInterfaceDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::InterfaceDescription* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mInterfaceDescription,
               _0RL_CORBA_mInterfaceDescription_marshal_fn,
               _0RL_CORBA_mInterfaceDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::InterfaceDescription*& _sp)
{
  return _a >>= (const CORBA::InterfaceDescription*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::InterfaceDescription*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mInterfaceDescription,
                    _0RL_CORBA_mInterfaceDescription_unmarshal_fn,
                    _0RL_CORBA_mInterfaceDescription_marshal_fn,
                    _0RL_CORBA_mInterfaceDescription_destructor_fn,
                    _v)) {
    _sp = (const CORBA::InterfaceDescription*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mValueMemberDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mValueMemberDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::ValueMemberDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mValueMemberDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::ValueMemberDef_ptr _o)
{
  CORBA::ValueMemberDef_ptr _no = CORBA::ValueMemberDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_ValueMemberDef,
               _0RL_CORBA_mValueMemberDef_marshal_fn,
               _0RL_CORBA_mValueMemberDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::ValueMemberDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_ValueMemberDef,
               _0RL_CORBA_mValueMemberDef_marshal_fn,
               _0RL_CORBA_mValueMemberDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::ValueMemberDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ValueMemberDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_ValueMemberDef,
                    _0RL_CORBA_mValueMemberDef_unmarshal_fn,
                    _0RL_CORBA_mValueMemberDef_marshal_fn,
                    _0RL_CORBA_mValueMemberDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::ValueMemberDef_ptr)_r->_ptrToObjRef(CORBA::ValueMemberDef::_PD_repoId);
    else
      _o = CORBA::ValueMemberDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mValueDef_mFullValueDescription_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ValueDef::FullValueDescription* _p = (CORBA::ValueDef::FullValueDescription*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mValueDef_mFullValueDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ValueDef::FullValueDescription* _p = new CORBA::ValueDef::FullValueDescription;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mValueDef_mFullValueDescription_destructor_fn(void* _v)
{
  CORBA::ValueDef::FullValueDescription* _p = (CORBA::ValueDef::FullValueDescription*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ValueDef::FullValueDescription& _s)
{
  CORBA::ValueDef::FullValueDescription* _p = new CORBA::ValueDef::FullValueDescription(_s);
  _a.PR_insert(_0RL_tc_CORBA_mValueDef_mFullValueDescription,
               _0RL_CORBA_mValueDef_mFullValueDescription_marshal_fn,
               _0RL_CORBA_mValueDef_mFullValueDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ValueDef::FullValueDescription* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mValueDef_mFullValueDescription,
               _0RL_CORBA_mValueDef_mFullValueDescription_marshal_fn,
               _0RL_CORBA_mValueDef_mFullValueDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ValueDef::FullValueDescription*& _sp)
{
  return _a >>= (const CORBA::ValueDef::FullValueDescription*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ValueDef::FullValueDescription*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mValueDef_mFullValueDescription,
                    _0RL_CORBA_mValueDef_mFullValueDescription_unmarshal_fn,
                    _0RL_CORBA_mValueDef_mFullValueDescription_marshal_fn,
                    _0RL_CORBA_mValueDef_mFullValueDescription_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ValueDef::FullValueDescription*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mValueDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mValueDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::ValueDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mValueDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::ValueDef_ptr _o)
{
  CORBA::ValueDef_ptr _no = CORBA::ValueDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_ValueDef,
               _0RL_CORBA_mValueDef_marshal_fn,
               _0RL_CORBA_mValueDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::ValueDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_ValueDef,
               _0RL_CORBA_mValueDef_marshal_fn,
               _0RL_CORBA_mValueDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::ValueDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ValueDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_ValueDef,
                    _0RL_CORBA_mValueDef_unmarshal_fn,
                    _0RL_CORBA_mValueDef_marshal_fn,
                    _0RL_CORBA_mValueDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::ValueDef_ptr)_r->_ptrToObjRef(CORBA::ValueDef::_PD_repoId);
    else
      _o = CORBA::ValueDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mValueDescription_marshal_fn(cdrStream& _s, void* _v)
{
  CORBA::ValueDescription* _p = (CORBA::ValueDescription*)_v;
  *_p >>= _s;
}
static void _0RL_CORBA_mValueDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CORBA::ValueDescription* _p = new CORBA::ValueDescription;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CORBA_mValueDescription_destructor_fn(void* _v)
{
  CORBA::ValueDescription* _p = (CORBA::ValueDescription*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CORBA::ValueDescription& _s)
{
  CORBA::ValueDescription* _p = new CORBA::ValueDescription(_s);
  _a.PR_insert(_0RL_tc_CORBA_mValueDescription,
               _0RL_CORBA_mValueDescription_marshal_fn,
               _0RL_CORBA_mValueDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CORBA::ValueDescription* _sp)
{
  _a.PR_insert(_0RL_tc_CORBA_mValueDescription,
               _0RL_CORBA_mValueDescription_marshal_fn,
               _0RL_CORBA_mValueDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ValueDescription*& _sp)
{
  return _a >>= (const CORBA::ValueDescription*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CORBA::ValueDescription*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CORBA_mValueDescription,
                    _0RL_CORBA_mValueDescription_unmarshal_fn,
                    _0RL_CORBA_mValueDescription_marshal_fn,
                    _0RL_CORBA_mValueDescription_destructor_fn,
                    _v)) {
    _sp = (const CORBA::ValueDescription*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mValueBoxDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mValueBoxDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::ValueBoxDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mValueBoxDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::ValueBoxDef_ptr _o)
{
  CORBA::ValueBoxDef_ptr _no = CORBA::ValueBoxDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_ValueBoxDef,
               _0RL_CORBA_mValueBoxDef_marshal_fn,
               _0RL_CORBA_mValueBoxDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::ValueBoxDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_ValueBoxDef,
               _0RL_CORBA_mValueBoxDef_marshal_fn,
               _0RL_CORBA_mValueBoxDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::ValueBoxDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::ValueBoxDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_ValueBoxDef,
                    _0RL_CORBA_mValueBoxDef_unmarshal_fn,
                    _0RL_CORBA_mValueBoxDef_marshal_fn,
                    _0RL_CORBA_mValueBoxDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::ValueBoxDef_ptr)_r->_ptrToObjRef(CORBA::ValueBoxDef::_PD_repoId);
    else
      _o = CORBA::ValueBoxDef::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CORBA_mAbstractInterfaceDef_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CORBA_mAbstractInterfaceDef_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CORBA::AbstractInterfaceDef::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CORBA_mAbstractInterfaceDef_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CORBA::AbstractInterfaceDef_ptr _o)
{
  CORBA::AbstractInterfaceDef_ptr _no = CORBA::AbstractInterfaceDef::_duplicate(_o);
  _a.PR_insert(CORBA::_tc_AbstractInterfaceDef,
               _0RL_CORBA_mAbstractInterfaceDef_marshal_fn,
               _0RL_CORBA_mAbstractInterfaceDef_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CORBA::AbstractInterfaceDef_ptr* _op)
{
  _a.PR_insert(CORBA::_tc_AbstractInterfaceDef,
               _0RL_CORBA_mAbstractInterfaceDef_marshal_fn,
               _0RL_CORBA_mAbstractInterfaceDef_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CORBA::AbstractInterfaceDef::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CORBA::AbstractInterfaceDef_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CORBA::_tc_AbstractInterfaceDef,
                    _0RL_CORBA_mAbstractInterfaceDef_unmarshal_fn,
                    _0RL_CORBA_mAbstractInterfaceDef_marshal_fn,
                    _0RL_CORBA_mAbstractInterfaceDef_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CORBA::AbstractInterfaceDef_ptr)_r->_ptrToObjRef(CORBA::AbstractInterfaceDef::_PD_repoId);
    else
      _o = CORBA::AbstractInterfaceDef::_nil();
    return 1;
  }
  return 0;
}

