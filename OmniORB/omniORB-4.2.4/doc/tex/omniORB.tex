\documentclass[11pt,oneside,a4paper]{book}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[scaled=0.9]{DejaVuSansMono}
\usepackage[scaled=0.9]{DejaVuSans}
\usepackage[scaled=0.9]{DejaVuSerif}
\linespread{1.05}

\usepackage{tocloft}

% To make the PDF version:
%
%  $ pdflatex omniORB
%  $ bibtex omniORB
%  $ pdflatex omniORB
%  $ pdflatex omniORB
%
% To make the HTML version, you need HeVeA
%
%  $ hevea omniORB
%  $ hacha omniORB.html
%
% HeVeA and HaChA come from http://pauillac.inria.fr/~maranget/hevea/


\bibliographystyle{alpha}

% Semantic mark-up:
\newcommand{\type}[1]{\texttt{#1}}
\newcommand{\intf}[1]{\texttt{#1}}
\newcommand{\module}[1]{\texttt{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\op}[1]{\texttt{#1()}}
\newcommand{\cmdline}[1]{\texttt{#1}}
\newcommand{\term}[1]{\textit{#1}}

\hyphenation{omni-ORB}

% Environment to make important statements stand out:
\newenvironment{statement}%
 {\noindent\begin{minipage}{\textwidth}%
  \vspace{.5\baselineskip}%
  \noindent\rule{\textwidth}{2pt}%
  \vspace{.25\baselineskip}%
  \begin{list}{}{\setlength{\listparindent}{0em}%
                 \setlength{\itemindent}{0em}%
                 \setlength{\leftmargin}{1.5em}%
                 \setlength{\rightmargin}{\leftmargin}%
                 \setlength{\topsep}{0pt}%
                 \setlength{\partopsep}{0pt}}
  \item\relax}
 {\end{list}%
  \vspace{-.25\baselineskip}%
  \noindent\rule{\textwidth}{2pt}%
  \vspace{.5\baselineskip}%
  \end{minipage}}

% Itemize with no itemsep:
\newenvironment{nsitemize}%
 {\begin{itemize}\setlength{\itemsep}{0pt}}%
 {\end{itemize}}

% URL-like things:
\usepackage{omniURLDefs}

% Mark-up for configuration options
\newcommand{\confopt}[2]
  {\vspace{\baselineskip}\par\noindent\code{#1} ~~ \textit{default} =
   \code{#2}}

\newcommand{\confoptnd}[1]
  {\vspace{\baselineskip}\par\noindent\code{#1}}


%BEGIN LATEX
\makeatletter
\renewcommand{\confopt}[2]
  {\vspace{\baselineskip}\par\noindent\code{#1} ~~ \textit{default} =
   \code{#2}\\[-1ex]\@afterheading}
\renewcommand{\confoptnd}[1]
  {\vspace{\baselineskip}\par\noindent\code{#1}\\[-1ex]\@afterheading}
\makeatother
%END LATEX

\addtolength{\oddsidemargin}{-0.2in}
\addtolength{\evensidemargin}{-0.6in}
\addtolength{\textwidth}{0.5in}

%BEGIN LATEX
\newcommand{\dsc}{\discretionary{}{}{}}
%END LATEX
%HEVEA\newcommand{\dsc}{}

\pagestyle{headings}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\usepackage{listings}

\makeatletter
\let\lst@ifdraft\iffalse
\makeatother

\lstdefinelanguage{idl}%
  {keywords={abstract,any,attribute,boolean,case,char,const,context,custom,default,double,enum,exception,factory,FALSE,fixed,float,in,inout,interface,local,long,module,native,Object,octet,oneway,out,private,public,raises,readonly,sequence,short,string,struct,supports,switch,TRUE,truncatable,typedef,unsigned,union,ValueBase,valuetype,void,wchar,wstring},%
  sensitive,%
  morecomment=[s]{/*}{*/},%
  morecomment=[l]//,%
  morestring=[b]",%
  morestring=[b]',%
  moredirectives={define,elif,else,endif,error,if,ifdef,ifndef,line,%
     include,pragma,undef,warning}%
 }[keywords,comments,strings,directives]%

\lstset{basicstyle=\ttfamily\small,
        keywordstyle=,
        commentstyle=\itshape,
	stepnumber=1,
        numberstyle=\tiny,
        showstringspaces=false,
        abovecaptionskip=0pt,
        belowcaptionskip=0pt,
        xleftmargin=\parindent,
        escapechar=@,
        fontadjust}


\lstnewenvironment{idllisting}{\lstset{language=idl}}{}
\lstnewenvironment{cxxlisting}{\lstset{language=C++}}{}
\lstnewenvironment{makelisting}{\lstset{language=[gnu]make}}{}

% These things make up for HeVeA's lack of understanding:

%HEVEA\newcommand{\vfill}{}
%HEVEA\newcommand{\mainmatter}{}
%HEVEA\newcommand{\backmatter}{}

% Hyperref things for pdf and html:
\usepackage{hyperref}

\newif\ifpdf
\ifx\pdfoutput\undefined
  \pdffalse
\else
  \pdfoutput=1
  \pdftrue
\fi
\ifpdf
  \hypersetup{colorlinks,citecolor=blue,urlcolor=blue}
\fi


% Finally, the set-up is almost over, and we can start the document:

\begin{document}

\pagenumbering{roman}
\pagestyle{empty}

\begin{center}

\vfill

{ \Huge
The omniORB version 4.2\\[4mm]
Users' Guide
}

\vfill

{ \Large
Duncan Grisby\\
{\normalsize (\textit{\href{mailto:dgrisby@apasphere.com}%
                           {\email{dgrisby@apasphere.com}}})}%
                           \\[2ex]
}

\vfill

\end{center}

\cleardoublepage

%BEGIN LATEX
\tableofcontents

\cleardoublepage
%END LATEX

\pagestyle{headings}

\pagenumbering{arabic}

\mainmatter

%HEVEA{\LARGE \bf Contents}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

omniORB is an Object Request Broker (ORB) that implements version 2.6
of the Common Object Request Broker Architecture
(CORBA)~\cite{corba26-spec} specification. Where possible, backward
compatibility has been maintained back to specification 2.0. It passed
the Open Group CORBA compliant testsuite (for CORBA 2.1) and was one
of the three ORBs to be granted the CORBA brand in June 1999.

This user guide tells you how to use omniORB to develop CORBA
applications. It assumes a basic understanding of CORBA.

In this chapter, we give an overview of the main features of omniORB
and what you need to do to set up your environment to run omniORB.

\section{Features}

omniORB is quite feature-rich, but it does not slavishly implement
every last part of the CORBA specification. The goal is to provide the
most generally useful parts of the specification in a clean and
efficient manner. Highlights are:

\begin{itemize}

\item C++ and Python language bindings.

\item Support for the complete Portable Object Adapter (POA) specification.

\item Support for the Interoperable Naming Service (INS).

\item Internet Inter-ORB Protocol (IIOP 1.2) is used as the native
  protocol.

\item The omniORB runtime is fully multithreaded. It uses platform
  thread support encapsulated with a small class library, omnithread,
  to abstract away from differences in native thread APIs.

\item TypeCode and type Any are supported.

\item DynAny is supported.

\item The Dynamic Invocation and Dynamic Skeleton interfaces are supported.

\item Valuetype and abstract interfaces are supported.

\item Asynchronous Method Invocation (AMI) supported, including both
  polling and callback models.

\item Extensive control over connection management.

\item Soft real-time features including call deadlines and timeouts.

\item A COS Naming Service, omniNames.

\item Many platforms are supported, including most Unix platforms and
  Windows.

\item It has been successfully tested for interoperability via IIOP with
  other ORBs.

\end{itemize}


\subsection{Multithreading}

omniORB is fully multithreaded. To achieve low call overhead,
unnecessary call multiplexing is eliminated. With the default
policies, there is at most one call in-flight in each communication
channel between two address spaces at any one time. To do this without
limiting the level of concurrency, new channels connecting the two
address spaces are created on demand and cached when there are
concurrent calls in progress. Each channel is served by a dedicated
thread. This arrangement provides maximal concurrency and eliminates
any thread switching in either of the address spaces to process a
call. Furthermore, to maximise the throughput in processing large call
arguments, large data elements are sent as soon as they are processed
while the other arguments are being marshalled. With GIOP 1.2, large
messages are fragmented, so the marshaller can start transmission
before it knows how large the entire message will be.

omniORB also supports a flexible thread pool policy, and supports
sending multiple interleaved calls on a single connection. This policy
leads to a small amount of additional call overhead, compared to the
default thread per connection model, but allows omniORB to scale to
extremely large numbers of concurrent clients.


\subsection{Portability}

omniORB runs on many flavours of Unix, Windows, several embedded
operating systems, and relatively obscure systems such as OpenVMS and
Fujitsu-Siemens BS2000.  It is designed to be easy to port to new
platforms. The IDL to C++ mapping for all target platforms is the
same.

omniORB uses real C++ exceptions and nested classes. It keeps to the
CORBA specification's standard mapping as much as possible and does
not use the alternative mappings for C++ dialects. The only small
exception is the mapping of IDL modules, which can use either
namespaces according to the standard, or nested classes for truly
ancient C++ compilers without namespace support.

omniORB relies on native thread libraries to provide multithreading
capability. A small class library (omnithread~\cite{tjr96a}) is used
to encapsulate the APIs of the native thread libraries. In application
code, it is recommended but not mandatory to use this class library
for thread management. It should be easy to port omnithread to any
platform that either supports the POSIX thread standard or has a
thread package that supports similar capabilities.

Partly for historical reasons, and partly to support users with
archaic compilers, omniORB does not use the C++ standard library.

The omniORB IDL compiler, omniidl, requires Python 2.5, 2.6 or 2.7.


\subsection{Missing features}
\label{sec:missing}

omniORB is not a complete implementation of the CORBA 2.6 core.  The
following is a list of the most significant missing features.

\begin{itemize}

\item For some very dynamic uses of CORBA, you may need an Interface
  Repository. omniORB does not have its own one, but it can act as a
  client to an IfR. The omniifr project
  (\url{https://github.com/omniorb/omniifr}) aims to create an IfR
  for omniORB.

\item omniORB supports interceptors, but not the standard Portable
Interceptor API.

\end{itemize}



\section{Setting up your environment}
\label{sec:setup}

To get omniORB running, you first need to install omniORB according to
the instructions in the installation notes for your platform. See
\file{README.FIRST.txt} at the top of the omniORB tree for
instructions. Most Unix platforms can use the Autoconf
\file{configure} script to automate the configuration process.

Once omniORB is installed in a suitable location, you must configure
it according to your required setup. The configuration can be set with
a configuration file, environment variables, command-line arguments
or, on Windows, the Windows registry.

\begin{itemize}

\item On Unix platforms, the omniORB runtime looks for the environment
  variable \envvar{OMNIORB_CONFIG}. If this variable is defined, it
  contains the pathname of the omniORB configuration file. If the
  variable is not set, omniORB will use the compiled-in pathname to
  locate the file (by default \file{/etc/omniORB.cfg}).

\item On Win32 / Win64 platforms, omniORB first checks the environment
  variable \envvar{OMNIORB_CONFIG} to obtain the pathname of the
  configuration file. If this is not set, it then attempts to obtain
  configuration data in the system registry. It searches for the data
  under the key \file{HKEY_LOCAL_MACHINE\SOFTWARE\omniORB}.

\end{itemize}

omniORB has a large number of parameters than can be configured. See
chapter~\ref{chap:config} for full details. The files
\file{sample.cfg} and \file{sample.reg} contain an example
configuration file and set of registry entries respectively.

To get all the omniORB examples running, the main thing you need to
configure is the Naming service, omniNames. To do that, the
configuration file or registry should contain an entry of the form

\begin{verbatim}
  InitRef = NameService=corbaname::my.host.name
\end{verbatim}

\noindent See section~\ref{sec:corbaname} for full details of
corbaname URIs.


\section{Platform specific variables}

To compile omniORB programs correctly, several C++ preprocessor
defines \emph{must} be specified to identify the target platform. On
Unix platforms where omniORB was configured with Autoconf, the
\file{omniconfig.h} file sets these for you. On other platforms, and
Unix platforms when Autoconf is not used, you must specify the
following defines:

\begin{flushleft}
\begin{tabular}{|l|l|}
\hline
Platform            & CPP defines \\
\hline
Windows             & \verb|__x86__     __NT__       __OSVERSION__=4  __WIN32__| \\

Windows NT 3.5      & \verb|__x86__     __NT__       __OSVERSION__=3  __WIN32__| \\

Sun Solaris 2.5     & \verb|__sparc__   __sunos__    __OSVERSION__=5| \\

HPUX 10.x           & \verb|__hppa__    __hpux__     __OSVERSION__=10| \\

HPUX 11.x           & \verb|__hppa__    __hpux__     __OSVERSION__=11| \\

IBM AIX 4.x         & \verb|__aix__     __powerpc__  __OSVERSION__=4| \\

Digital Unix 3.2    & \verb|__alpha__   __osf1__     __OSVERSION__=3| \\

Linux 2.x (x86)     & \verb|__x86__     __linux__    __OSVERSION__=2| \\

Linux 2.x (powerpc) & \verb|__powerpc__ __linux__    __OSVERSION__=2| \\

OpenVMS 6.x (alpha) & \verb|__alpha__   __vms        __OSVERSION__=6 | \\

OpenVMS 6.x (vax)   & \verb|__vax__     __vms        __OSVERSION__=6 | \\

SGI Irix 6.x        & \verb|__mips__    __irix__     __OSVERSION__=6 | \\

Reliant Unix 5.43   & \verb|__mips__    __SINIX__    __OSVERSION__=5 | \\

ATMos 4.0           & \verb|__arm__     __atmos__    __OSVERSION__=4| \\

NextStep 3.x        & \verb|__m68k__    __nextstep__ __OSVERSION__=3| \\

Unixware 7          & \verb|__x86__     __uw7__      __OSVERSION__=5| \\
\hline
\end{tabular}
\end{flushleft}

The preprocessor defines for new platform ports not listed above can
be found in the corresponding platform configuration files. For
instance, the platform configuration file for Sun Solaris 2.6 is in
\file{mk/platforms/sun4_sosV_5.6.mk}. The preprocessor defines to
identify a platform are in the make variable
\makevar{IMPORT_CPPFLAGS}.

In a single source multi-target environment, you can put the
preprocessor defines as the command-line arguments for the compiler.
If you are building for a single platform, you can edit
include/omniconfig.h to add the definitions.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{The Basics}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:basic}

In this chapter, we go through three examples to illustrate the
practical steps to use omniORB. By going through the source code of
each example, the essential concepts and APIs are introduced. If you
have no previous experience with using CORBA, you should study this
chapter in detail. There are pointers to other essential documents you
should be familiar with.

If you have experience with using other ORBs, you should still go
through this chapter because it provides important information about
the features and APIs that are necessarily omniORB specific. With the
Portable Object Adapter, there are very few omniORB specific details.


\section{The Echo Object Example}

Our example is an object which has only one method. The method simply
echos the argument string. We have to:

\begin{enumerate}

\item define the object interface in IDL
\item use the IDL compiler to generate the stub code, which provides
  the object mapping as defined in the CORBA specification
\item provide the \term{servant} object implementation
\item write the client code.

\end{enumerate}

These examples are in the \file{src/examples/echo} directory of the
omniORB distribution; there are several other examples in
\file{src/examples}.


\section{Specifying the Echo interface in IDL}

We define an object interface, called \intf{Echo}, as follows:

\begin{idllisting}
interface Echo {
  string echoString(in string mesg);
};
\end{idllisting}

If you are new to IDL, you can learn about its syntax in Chapter 3 of
the CORBA 2.6 specification~\cite{corba26-spec}. For the moment, you
only need to know that the interface consists of a single operation,
\op{echoString}, which takes a string as an input argument and returns
a copy of the same string.

The interface is written in a file, called \file{echo.idl}. It is part
of the CORBA standard that all IDL files must have the extension
`\file{.idl}', although omniORB does not enforce this. In the omniORB
distribution, this file is in \file{idl/echo.idl}.

For simplicity, the interface is defined in the global IDL namespace.
You should normally avoid this practice for the sake of object
reusability.  If every CORBA developer defines their interfaces in the
global IDL namespace, there is a danger of name clashes between two
independently defined interfaces. Therefore, it is better to qualify
your interfaces by defining them inside \code{module} names. Of
course, this does not eliminate the chance of a name clash unless some
form of naming convention is agreed globally. Nevertheless, a
well-chosen module name can help a lot.


\section{Generating the C++ stubs}

From the IDL file, we use the IDL compiler to produce the C++ mapping
of the interface. The IDL compiler for omniORB is called omniidl.
Given the IDL file, omniidl produces two stub files: a C++ header file
and a C++ source file. For example, from the file \file{echo.idl}, the
following files are produced:

\begin{nsitemize}
\item \file{echo.hh}
\item \file{echoSK.cc}
\end{nsitemize}

\noindent omniidl must be invoked with the \cmdline{-bcxx} argument to
tell it to generate C++ stubs. The following command line generates
the stubs for \file{echo.idl}:

\begin{makelisting}
omniidl -bcxx echo.idl
\end{makelisting}

Note that the names \file{echo.hh} and \file{echoSK.cc} are not
defined in the C++ mapping standard. Other CORBA implementations may
use different file names. To aid migration omniidl from other
implementations, omniidl has options to override the default output
file names. See section~\ref{sec:cxx_backend} for details.


If you are using our make environment, you don't need to invoke
omniidl explicitly. In the example file \file{dir.mk}, we have the
following line:

\begin{makelisting}
CORBA_INTERFACES = echo
\end{makelisting}

\noindent That is all we need to instruct the build system to generate
the stubs. You won't find the stubs in your working directory because
all stubs are written into the \file{stub} directory at the top level
of your build tree.

The full arguments to omniidl are detailed in
chapter~\ref{chap:omniidl}.


\section{Object References and Servants}

We contact a CORBA object through an \term{object reference}. The
actual implementation of a CORBA object is termed a \term{servant}.

Object references and servants are quite separate entities, and it is
important not to confuse the two. Client code deals purely with object
references, so there can be no confusion; object implementation code
must deal with both object references and servants. omniORB uses
distinct C++ types for object references and servants, so the C++
compiler will complain if you use a servant when an object reference
is expected, or vice-versa.


\section{A quick look at the C++ mapping}

The C++ stubs conform to the standard mapping defined in the CORBA
specification~\cite{cxxmapping}. Sadly, since it pre-dates the C++
standard library, the C++ language mapping is quite hard to use,
especially because it has complex memory management rules.

The best way to understand the mapping is to read either the
specification or, better, a book about using CORBA from C++. Reading
the code generated by omniidl is hard-going, and it is difficult to
distinguish the parts you need to know from the implementation
details.


\subsection{Mapping overview}

For interface \type{Echo}, omniidl generates four things of note:

\begin{itemize}
\item class \type{Echo}, containing static functions and type
  definitions

\item \type{Echo\_ptr}, an \emph{object reference} type with pointer
  semantics

\item \type{Echo\_var}, a memory management helper for
  \type{Echo\_ptr}

\item class \type{POA\_Echo}, the server-side \emph{skeleton} class

\end{itemize}


\subsection{Interface scope type}

A C++ class \type{Echo} is defined to hold a number of static
functions and type definitions. It looks like this:

\begin{cxxlisting}
class Echo {
public:
  typedef Echo_ptr _ptr_type;
  typedef Echo_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();
};
\end{cxxlisting}

The \type{\_ptr\_type} and \type{\_var\_type} typedefs are there to
facilitate template programming. The static functions are described
below.


\subsection{Object reference pointer type}

For interface \intf{Echo}, the mapping defines the object reference
type \type{Echo\_ptr} which has pointer semantics. The \type{\_ptr}
type provides access to the interface's operations. The concrete type
of an object reference is opaque, i.e.\ you must not make any
assumptions about how an object reference is implemented. You can
imagine it looks something like this:

\begin{cxxlisting}
class @\textit{private\_class}@ : public @\textit{some\_base\_class}@ {
  char* echoString(const char* mesg);
};

typedef @\textit{something}@ Echo_ptr;
\end{cxxlisting}

To use an object reference, you use the arrow operator `\code{->}' to
invoke its operations, but you must not use it as a C++ pointer in any
other respect. It is non-compliant to convert it to \type{void*},
perform arithmetic or relational operations including testing for
equality using \code{operator==}.

In some CORBA implementations, \type{Echo\_ptr} is a typedef to
\type{Echo*}. In omniORB, it is not---the object reference type is
distinct from class \type{Echo}.


\subsubsection{Nil object reference}

Object references can be \emph{nil}. To obtain a nil object reference
for interface \type{Echo}, call \op{Echo::\_nil}. To test if an
object reference is nil, use \op{CORBA::\_is\_nil}:

\begin{cxxlisting}
CORBA::Boolean true_result = CORBA::is_nil(Echo::_nil());
\end{cxxlisting}

\op{Echo::\_nil} is the only compliant way to obtain a nil Echo
reference, and \op{CORBA::is\_nil} is the only compliant way to check
if an object reference is nil. You should not use the equality
\code{operator==}. Many C++ ORBs use the null pointer to represent a
nil object reference, but \emph{omniORB does not}.


\subsubsection{Object reference lifecycle}

Object references are reference counted. That is, the opaque C++
objects on the client side that implement \type{Echo\_ptr} are
reference counted, so they are deleted when the count goes to zero.
The lifetime of an object reference has no bearing at all on the
lifetime of the CORBA object to which it is a reference---when an
object reference is deleted, it has \emph{no effect} on the object in
the server.

Reference counting for \type{Echo} object references is performed with
\op{Echo::\dsc{}\_duplicate} and \op{CORBA::release}.

The \op{\_duplicate} function returns a new object reference of the
Echo interface. The new object reference can be used interchangeably
with the old object reference to perform an operation on the same
object.

To indicate that an object reference will no longer be accessed, you
must call the \op{CORBA::release} operation. Its signature is as
follows:

\begin{cxxlisting}
namespace CORBA {
  void release(CORBA::Object_ptr obj);
  ... // other methods
};
\end{cxxlisting}

Once you have called \op{CORBA::release} on an object reference, you
may no longer use that reference. This is because the associated
resources may have been deallocated. Remember that we are referring to
the resources associated with the object reference and \emph{not the
  servant object}. Servant objects are not affected by the lifetimes
of object references. In particular, servants are not deleted when all
references to them have been released---CORBA does not perform
distributed garbage collection.

Nil object references are \emph{not} reference counted, so there is no
need to call \op{\_duplicate} and \op{release} with them, although it
does no harm.

Since object references must be released explicitly, their usage is
prone to error and can lead to memory leaks or invalid memory
accesses. The mapping defines the \term{object reference variable}
type \type{Echo\_var} to make life somewhat easier.

The \type{Echo\_var} is more convenient to use because it
automatically releases its object reference when it goes out of scope
or when assigned a new object reference. For many operations, mixing
data of type \type{Echo\_var} and \type{Echo\_ptr} is possible without
any explicit operations or casting. For instance, the \op{echoString}
operation can be called using the arrow (`\code{->}') on a
\type{Echo\_var}, as one can do with a \type{Echo\_ptr}.

The usage of \type{Echo\_var} is illustrated below:

\begin{cxxlisting}
Echo_var a;
Echo_ptr p = ... // somehow obtain an object reference

a = p;           // a assumes ownership of p, must not use p any more

Echo_var b = a;  // implicit _duplicate

p = ...          // somehow obtain another object reference

a = Echo::_duplicate(p);     // release old object reference
                             // a now holds a copy of p.
\end{cxxlisting}

The mappings of many other IDL data types include \type{\_var} types
with similar semantics.


\subsubsection{Object reference inheritance}

All CORBA objects inherit from the generic object
\type{CORBA::Object}.  \type{CORBA::\dsc{}Object\_ptr} is the object
reference type for base \type{CORBA::Object}. Object references can be
implicitly \emph{widened} to base interface types, so this is valid:

\begin{cxxlisting}
Echo_ptr echo_ref = // get reference from somewhere
CORBA::Object_ptr base_ref = echo_ref; // widen
\end{cxxlisting}

An object reference such as \type{Echo\_ptr} can be used in places
where a \type{CORBA::\dsc{}Object\_ptr} is expected. Conversely, the
\op{Echo::\_narrow} function takes an argument of type
\type{CORBA::Object\_ptr} and returns a new object reference of the
\intf{Echo} interface.  If the actual (runtime) type of the argument
object reference can be narrowed to \type{Echo\_ptr}, \op{\_narrow}
will return a valid object reference. Otherwise it will return a nil
object reference. Note that \op{\_narrow} performs an implicit
duplication of the object reference, so the result must be released.
Note also that \op{\_narrow} may involve a remote call to check the
type of the object, so it may throw CORBA system exceptions such as
\code{TRANSIENT} or \code{OBJECT\_NOT\_EXIST}.


\subsubsection{Object reference equivalence}

As described above, the equality \code{operator==} should not be used
on object references. To test if two object references are equivalent,
the member function \op{\_is\_equivalent} of the generic object
\type{CORBA::Object} can be used. Here is an example of its usage:

\begin{cxxlisting}
Echo_ptr a;
...            // initialise a to a valid object reference 
Echo_ptr b = a;
CORBA::Boolean true_result = a->_is_equivalent(a); 
// Note: the above call is guaranteed to be true
\end{cxxlisting}

\op{\_is\_equivalent} does \emph{not} contact the object to check for
equivalence---it uses purely local knowledge, meaning that it is
possible to construct situations in which two object references refer
to the same object, but \op{\_is\_equivalent} does not consider them
equivalent. If you need a strong sense of object identity, you must
implement it with explicit IDL operations.


\subsection{Servant Object Implementation}
\label{stubobjimpl}

For each object interface, a \term{skeleton} class is generated.  In
our example, the POA specification says that the skeleton class for
interface \intf{Echo} is named \type{POA\_Echo}. A servant
implementation can be written by creating an implementation class that
derives from the skeleton class.

The skeleton class \type{POA\_Echo} is defined in \file{echo.hh}. The
relevant section of the code is reproduced below.

\begin{cxxlisting}
class POA_Echo :
  public virtual PortableServer::ServantBase
{
public:
  Echo_ptr _this();

  virtual char * echoString(const char* mesg) = 0;
};
\end{cxxlisting}

The code fragment shows the only member functions that can be used in
the object implementation code. Other member functions are generated
for internal use only. As with the code generated for object
references, other POA-based ORBs will generate code which looks
different, but is functionally equivalent to this.


\begin{description}

\item[\op{echoString}]\mbox{}\\
%
It is through this abstract function that an implementation class
provides the implementation of the \op{echoString} operation. Notice
that its signature is the same as the \op{echoString} function that
can be invoked via the \type{Echo\_ptr} object reference. This will be
the case most of the time, but object reference operations for certain
parameter types use special helper classes to facilitate correct
memory management.

\item[\op{\_this}]\mbox{}\\
%
The \op{\_this} function returns an object reference for the target
object, provided the POA policies permit it. The returned value must
be deallocated via \op{CORBA::\dsc{}release}.  See
section~\ref{objeg1} for an example of how this function is used.

\end{description}


\section{Writing the servant implementation}
\label{objimpl}

You define a class to provide the servant implementation. There is
little constraint on how you design your implementation class except
that it has to inherit from the skeleton class\footnote{Rather than
  deriving from the skeleton class, an alternative is to use a
  \term{tie} template, described in section~\ref{sec:tie}.} and to
implement all the abstract functions defined in the skeleton
class. Each of these abstract functions corresponds to an operation of
the interface. They are the hooks for the ORB to perform upcalls to
your implementation. Here is a simple implementation of the Echo
object.

\begin{cxxlisting}
class Echo_i : public POA_Echo
{
public:
  inline Echo_i() {}
  virtual ~Echo_i() {}
  virtual char* echoString(const char* mesg);
};

char* Echo_i::echoString(const char* mesg)
{
  return CORBA::string_dup(mesg);
}
\end{cxxlisting}

\noindent There are four points to note here:

\begin{description}

\item[Storage Responsibilities]\mbox{}\\
%
String, which is used both as an in argument and the return value of
\op{echoString}, is a variable sized data type. Other examples of
variable sized data types include sequences, type `any', etc. For
these data types, you must be clear about whose responsibility it is
to allocate and release the associated storage. As a rule of thumb,
the client (or the caller to the implementation functions) owns the
storage of all \emph{in} arguments, the object implementation (or the
callee) must copy the data if it wants to retain a copy. For
\emph{out} arguments and return values, the object implementation
allocates the storage and passes the ownership to the client. The
client must release the storage when the variables will no longer be
used.  For details, see the C++ mapping specification.

\item[Multi-threading]\mbox{}\\
%
As omniORB is fully multithreaded, multiple threads may perform the
same upcall to your implementation concurrently. It is up to your
implementation to synchronise the threads' accesses to shared data.
In our simple example, we have no shared data to protect so no thread
synchronisation is necessary.

Alternatively, you can create a POA which has the
\code{SINGLE\_THREAD\_MODEL} Thread Policy. This guarantees that all
calls to that POA are processed sequentially.

\item[Reference Counting]\mbox{}\\
%
All servant objects are reference counted. The base
\type{PortableServer::\dsc{}ServantBase} class from which all servant
skeleton classes derive defines member functions named \op{\_add\_ref}
and \op{\_remove\_ref}\footnote{In the previous 1.0 version of the C++
mapping, servant reference counting was optional, chosen by inheriting
from a mixin class named \type{RefCountServantBase}. That has been
deprecated in the 1.1 version of the C++ mapping, but the class is
still available as an empty struct, so existing code that inherits
from \type{RefCountServantBase} will continue to work.}. The reference
counting means that an \type{Echo\_i} instance will be deleted when no
more references to it are held by application code or the POA
itself. Note that this is totally separate from the reference counting
which is associated with object references---a servant object is
\emph{never} deleted due to a CORBA object reference being released.

\item[Instantiation]\mbox{}\\
%
Servants are usually instantiated on the heap, i.e.\ using the
\code{new} operator. However, they can also be created on the stack as
automatic variables. If you do that, it is vital to make sure that the
servant has been deactivated, and thus released by the POA, before the
variable goes out of scope and is destroyed.

\end{description}

\section{Writing the client}

Here is an example of how an \type{Echo\_ptr} object reference is
used.

\lstset{numbers=left,gobble=4}
\begin{cxxlisting}
 1  void
 2  hello(CORBA::Object_ptr obj)
 3  {
 4    Echo_var e = Echo::_narrow(obj);
 5
 6    if (CORBA::is_nil(e)) {
 7      cerr << "cannot invoke on a nil object reference."
 8           << endl;
 9      return;
10    }
11
12    CORBA::String_var src = (const char*) "Hello!";
13    CORBA::String_var dest;
14
15    dest = e->echoString(src);
16
17    cout << "I said,\"" << src << "\"."
18         << " The Object said,\"" << dest <<"\"" << endl;
19  }
\end{cxxlisting}
\lstset{numbers=none,gobble=0}

The \op{hello} function accepts a generic object reference.  The
object reference (\code{obj}) is narrowed to \type{Echo\_ptr}. If the
object reference returned by \op{Echo::\dsc{}\_narrow} is not nil, the
operation \op{echoString} is invoked. Finally, both the argument to
and the return value of \op{echoString} are printed to \code{cout}.

The example also illustrates how \type{T\_var} types are used. As was
explained in the previous section, \type{T\_var} types take care of
storage allocation and release automatically when variables are
reassigned or when the variables go out of scope.

In line 4, the variable \code{e} takes over the storage responsibility
of the object reference returned by \op{Echo::\_narrow}. The object
reference is released by the destructor of \code{e}. It is called
automatically when the function returns. Lines 6 and 15 show how a
\type{Echo\_var} variable is used. As explained earlier, the
\type{Echo\_var} type can be used interchangeably with the
\type{Echo\_ptr} type.

The argument and the return value of \op{echoString} are stored in
\type{CORBA::\dsc{}String\_var} variables \code{src} and \code{dest}
respectively. The strings managed by the variables are deallocated by
the destructor of \type{CORBA::String\_var}. It is called
automatically when the variable goes out of scope (as the function
returns). Line 15 shows how \type{CORBA::String\_var} variables are
used. They can be used in place of a string (for which the mapping is
\type{char*})\footnote{A conversion operator of
\type{CORBA::String\_var} converts a \type{CORBA::\dsc{}String\_var}
to a \type{char*}.}. As used in line 12, assigning a constant string
(\type{const char*}) to a \type{CORBA::String\_var} causes the string
to be copied. On the other hand, assigning a \type{char*} to a
\type{CORBA::String\_var}, as used in line 15, causes the latter to
assume the ownership of the string\footnote{Please refer to the C++
mapping specification for details of the String\_var mapping.}.

Under the C++ mapping, \type{T\_var} types are provided for all the
non-basic data types.  One should use automatic variables whenever
possible both to avoid memory leaks and to maximise performance.
However, when one has to allocate data items on the heap, it is a good
practice to use the \type{T\_var} types to manage the heap storage.

\section{Example 1 --- Colocated Client and Servant}
\label{objeg1}

Having introduced the client and the object implementation, we can now
describe how to link up the two via the ORB and POA. In this section,
we describe an example in which both the client and the object
implementation are in the same address space. In the next two
sections, we shall describe the case where the two are in different
address spaces.

The code for this example is reproduced below:

\lstset{numbers=left,gobble=4}
\begin{cxxlisting}
 1  int
 2  main(int argc, char **argv)
 3  {
 4    CORBA::ORB_ptr orb = CORBA::ORB_init(argc, argv, "omniORB4");
 5
 6    CORBA::Object_var       obj = orb->resolve_initial_references("RootPOA");
 7    PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);
 8
 9    PortableServer::Servant_var<Echo_i> myecho = new Echo_i();
10    PortableServer::ObjectId_var myechoid = poa->activate_object(myecho);
11
12    Echo_var myechoref = myecho->_this();
13
14    PortableServer::POAManager_var pman = poa->the_POAManager();
15    pman->activate();
16
17    hello(myechoref);
18
19    orb->destroy();
20    return 0;
21  }
\end{cxxlisting}
\lstset{numbers=none,gobble=0}

The example illustrates several important interactions among the ORB,
the POA, the servant, and the client. Here are the details:

\subsection{ORB initialisation}

\begin{description}

\item[Line 4]\mbox{}\\
%
The ORB is initialised by calling the \op{CORBA::ORB\_init}
function. The function uses the optional 3rd argument to determine
which ORB should be returned. Unless you are using omniORB specific
features, it is usually best to leave it out, and get the default
ORB. To explicitly ask for omniORB 4.x, this argument must be
`omniORB4'\footnote{For backwards compatibility, the ORB identifiers
`omniORB2' and `omniORB3' are also accepted.}.

\op{CORBA::ORB\_init} takes the list of command line arguments and
processes any that start `\code{-ORB}'. It removes these arguments
from the list, so application code does not have to deal with them.

If any error occurs during ORB initialisation, such as invalid ORB
arguments, or an invalid configuration file, the
\code{CORBA::INITIALIZE} system exception is raised.

\end{description}


\subsection{Obtaining the Root POA}

\begin{description}

\item[Lines 6--7]\mbox{}\\
%
To activate our servant object and make it available to clients, we
must register it with a POA. In this example, we use the \term{Root
POA}, rather than creating any child POAs. The Root POA is found with
\op{orb->resolve\_initial\_\dsc{}references}, which returns a plain
\type{CORBA::Object}. In line 7, we narrow the reference to the right
type for a POA.

A POA's behaviour is governed by its \term{policies}. The Root POA has
suitable policies for many simple servers, and closely matches the
`policies' used by omniORB 2's BOA. See Chapter 11 of the CORBA 2.6
specification\cite{corba26-spec} for details of all the POA policies
which are available.

\end{description}


\subsection{Object initialisation}

\begin{description}

\item[Line 9]\mbox{}\\
%
An instance of the Echo servant is initialised using the \code{new}
operator. The \type{PortableServer::Servant\_var<>} template
automatically is analogous to the \type{T\_var} types generated by the
IDL compiler. It releases our reference to the servant when it goes
out of scope.

\item[Line 10]\mbox{}\\
%
The servant object is activated in the Root POA using
\op{poa->activate\_\dsc{}object}, which returns an object identifier
(of type \type{PortableServer::\dsc{}ObjectId*}). The object id must
be passed back to various POA operations. The caller is responsible
for freeing the object id, so it is assigned to a \type{\_var} type.

\item[Line 12]\mbox{}\\
%
The object reference is obtained from the servant object by calling
its \op{\_this} method. Like all object references, the return value
of \op{\_this} must be released by \op{CORBA::release} when it is no
longer needed. In this case, we assign it to a \type{\_var} type, so
the release is implicit at the end of the function.

One of the important characteristics of an object reference is that it
is completely location transparent. A client can invoke on the object
using its object reference without any need to know whether the
servant object is colocated in the same address space or is in a
different address space.

In the case of colocated client and servant, omniORB is able to
short-circuit the client calls so they do not involve IIOP. The calls
still go through the POA, however, so the various POA policies affect
local calls in the same way as remote ones. This optimisation is
applicable not only to object references returned by \op{\_this}, but
to any object references that are passed around within the same
address space or received from other address spaces via remote calls.

\end{description}


\subsection{Activating the POA}

\begin{description}

\item[Lines 15--16]\mbox{}\\
%
POAs are initially in the \term{holding} state, meaning that incoming
requests are blocked. Lines 15 and 16 acquire a reference to the POA's
POA manager, and use it to put the POA into the \term{active} state.
Incoming requests are now served. \textbf{Failing to activate the POA
is one of the most common programming mistakes. If your program
appears deadlocked, make sure you activated the POA!}

\end{description}


\subsection{Performing a call}

\begin{description}

\item[Line 18]\mbox{}\\
%
At long last, we can call \op{hello} with this object reference. The
argument is widened implicitly to the generic object reference
\type{CORBA::Object\_ptr}.

\end{description}


\subsection{ORB destruction}

\begin{description}

\item[Line 20]\mbox{}\\
%
Shutdown the ORB permanently. This call causes the ORB to release all
its resources, e.g.\ internal threads, and also to deactivate any
servant objects which are currently active. When it deactivates the
\type{Echo\_i} instance, the servant's reference count drops to zero,
so the servant is deleted.

This call is particularly important when writing a CORBA DLL on
Windows NT that is to be used from ActiveX. If this call is absent,
the application will hang when the CORBA DLL is unloaded.

\end{description}



\section{Example 2 --- Different Address Spaces}

In this example, the client and the object implementation reside in
two different address spaces. The code of this example is almost the
same as the previous example. The only difference is the extra work
which needs to be done to pass the object reference from the object
implementation to the client.

The simplest (and quite primitive) way to pass an object reference
between two address spaces is to produce a \term{stringified} version
of the object reference and to pass this string to the client as a
command-line argument.  The string is then converted by the client
into a proper object reference.  This method is used in this
example. In the next example, we shall introduce a better way of
passing the object reference using the CORBA Naming Service.

\subsection{Making a Stringified Object Reference}

The \op{main} function of the server side is reproduced below. The
full listing (\file{eg2_impl.cc}) can be found at the end of this
chapter.

\lstset{numbers=left,gobble=4}
\begin{cxxlisting}
 1  int main(int argc, char** argv)
 2  {
 3    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);
 4
 5    CORBA::Object_var       obj = orb->resolve_initial_references("RootPOA");
 6    PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);
 7
 8    PortableServer::Servant_var<Echo_i> myecho = new Echo_i();
 9
10    PortableServer::ObjectId_var myechoid = poa->activate_object(myecho);
11
12    obj = myecho->_this();
13    CORBA::String_var sior(orb->object_to_string(obj));
14    cerr << sior << endl;
15
16    PortableServer::POAManager_var pman = poa->the_POAManager();
17    pman->activate();
18
19    orb->run();
20    orb->destroy();
21    return 0;
22  }
\end{cxxlisting}
\lstset{numbers=none,gobble=0}

The stringified object reference is obtained by calling the ORB's
\op{object\_to\_\dsc{}string} function (line 13). This results in a
string starting with the signature `\code{IOR:}' and followed by quite
a lot of hexadecimal digits. All CORBA compliant ORBs are able to
convert the string into its internal representation of a so-called
Interoperable Object Reference (IOR). The IOR contains the location
information and a key to uniquely identify the object implementation
in its own address space. From the IOR, an object reference can be
constructed.

\subsection{Client: Using a Stringified Object Reference}
\label{clnt2}

The stringified object reference is passed to the client as a
command-line argument. The client uses the ORB's
\op{string\_to\_object} function to convert the string into a generic
object reference (\type{CORBA::Object\_ptr}). The relevant section of
the code is reproduced below. The full listing (\file{eg2_clt.cc}) can
be found at the end of this chapter.

\begin{cxxlisting}
try {
  CORBA::Object_var obj = orb->string_to_object(argv[1]);
  hello(obj);
}
catch (CORBA::TRANSIENT&) {
  ... // code to handle transient exception...
}
\end{cxxlisting}


\subsection{Catching System Exceptions}

When omniORB detects an error condition, it may raise a system
exception.  The CORBA specification defines a series of exceptions
covering most of the error conditions that an ORB may encounter. The
client may choose to catch these exceptions and recover from the error
condition\footnote{If a system exception is not caught, the C++
runtime will call the \op{terminate} function. This function is
defaulted to abort the whole process and on some systems will cause a
core file to be produced.}. For instance, the code fragment, shown in
section~\ref{clnt2}, catches the \code{TRANSIENT} system exception
which indicates that the object could not be contacted at the time of
the call, usually meaning the server is not running.

All system exceptions inherit from \type{CORBA::SystemException}.
Unless you have a truly ancient C++ compiler, a single catch of
\code{CORBA::SystemException} will catch all the different system
exceptions.


\subsection{Lifetime of a CORBA object}

CORBA objects are either \term{transient} or \term{persistent}. The
majority are transient, meaning that the lifetime of the CORBA object
(as contacted through an object reference) is the same as the lifetime
of its servant object. Persistent objects can live beyond the
destruction of their servant object, the POA they were created in, and
even their process. Persistent objects are, of course, only
contactable when their associated server processes are running, and
their servants are active or can be activated by their POA with a
servant manager\footnote{The POA itself can be activated on demand
  with an adapter activator.}. A reference to a persistent object can
be published, and will remain valid even if the server process is
restarted.

To support persistent objects, the servants must be activated in their
POA with the same object identifier each time. Also, the server must
be configured with the same \term{endpoint} details so it is
contactable in the same way as previous invocations. See
section~\ref{sec:endpoints} for details.

A POA's Lifespan Policy determines whether objects created within it
are transient or persistent. The Root POA has the \code{TRANSIENT}
policy.

An alternative to creating persistent objects is to register object
references in a \term{naming service} and bind them to fixed path
names. Clients can bind to the object implementations at run time by
asking the naming service to resolve the path names to the object
references. CORBA defines a standard naming service, which is a
component of the Common Object Services (COS)~\cite{corbaservices},
that can be used for this purpose. The next section describes an
example of how to use the COS Naming Service.


\section{Example 3 --- Using the Naming Service}

In this example, the object implementation uses the Naming
Service~\cite{corbaservices} to pass on the object reference to the
client.  This method is often more practical than using stringified
object references. The full listing of the object implementation
(\file{eg3_impl.cc}) and the client (\file{eg3_clt.cc}) can be found
at the end of this chapter.

The names used by the Naming service consist of a sequence of
\term{name components}. Each name component has an \term{id} and a
\term{kind} field, both of which are strings. All name components
except the last one are bound to a naming context. A naming context is
analogous to a directory in a filing system: it can contain names of
object references or other naming contexts. The last name component is
bound to an object reference.

Sequences of name components can be represented as a flat string,
using `.' to separate the id and kind fields, and `/' to separate name
components from each other\footnote{There are escaping rules to cope
with id and kind fields which contain `.' and `/' characters. See
chapter~\ref{chap:ins} of this manual, and chapter 3 of the CORBA
services specification, as updated for the Interoperable Naming
Service~\cite{inschapters}.}. In our example, the Echo object
reference is bound to the stringified name
`\file{test.my_context/Echo.Object}'.

The kind field is intended to describe the name in a
syntax-independent way. The naming service does not interpret, assign,
or manage these values. However, both the name and the kind attribute
must match for a name lookup to succeed. In this example, the kind
values for \file{test} and \file{Echo} are chosen to be
`\file{my_context}' and `\file{Object}' respectively. This is an
arbitrary choice as there is no standardised set of kind values.



\subsection{Obtaining the Root Context Object Reference}
\label{resolveinit}

The initial contact with the Naming Service can be established via the
\term{root} context. The object reference to the root context is
provided by the ORB and can be obtained by calling
\op{resolve\_initial\_references}. The following code fragment shows
how it is used:

\begin{cxxlisting}
CORBA::ORB_ptr orb = CORBA::ORB_init(argc,argv);
CORBA::Object_var obj = orb->resolve_initial_references("NameService");

CosNaming::NamingContext_var rootContext;
rootContext = CosNaming::NamingContext::_narrow(obj);
\end{cxxlisting}

Remember from section~\ref{sec:setup}, omniORB constructs its internal
list of initial references at initialisation time using the
information provided in the configuration file \file{omniORB.cfg}, or
given on the command line. If this file is not present, the internal
list will be empty and \op{resolve\_initial\_references} will raise a
\code{CORBA::ORB::\dsc{}InvalidName} exception.

\subsection{The Naming Service Interface}

It is beyond the scope of this chapter to describe in detail the
Naming Service interface. You should consult the CORBA services
specification~\cite{corbaservices} (chapter 3). The code listed in
\file{eg3_impl.cc} and \file{eg3_clt.cc} are good examples of how the
service can be used.


\section{Example 4 --- Using tie implementation templates}
\label{sec:tie}

omniORB supports \term{tie} implementation templates as an alternative
way of providing servant classes. If you use the \texttt{-Wbtp} option
to omniidl, it generates an extra template class for each interface.
This template class can be used to tie a C++ class to the skeleton
class of the interface.

The source code in \file{eg3_tieimpl.cc} at the end of this chapter
illustrates how the template class can be used. The code is almost
identical to \file{eg3_impl.cc} with only a few changes.

Firstly, the servant class \type{Echo\_i} does not inherit from any
skeleton classes. This is the main benefit of using the template class
because there are applications in which it is difficult to require
every servant class to derive from CORBA classes.

Secondly, the instantiation of a CORBA object now involves creating an
instance of the implementation class \emph{and} an instance of the
template.  Here is the relevant code fragment:

\begin{cxxlisting}
class Echo_i { ... };

Echo_i *myimpl = new Echo_i();
POA_Echo_tie<Echo_i> myecho(myimpl);

PortableServer::ObjectId_var myechoid = poa->activate_object(&myecho);
\end{cxxlisting}


For interface \intf{Echo}, the name of its tie implementation template
is \type{POA\_Echo\_\dsc{}tie}. The template parameter is the servant
class that contains an implementation of each of the operations
defined in the interface. As used above, the tie template takes
ownership of the \type{Echo\_i} instance, and deletes it when the tie
object goes out of scope. The tie constructor has an optional boolean
argument (defaulted to \code{true}) which indicates whether or not it
should delete the servant object. For full details of using tie
templates, see the CORBA C++ mapping specification.


\clearpage
\section{Source Listings}

\subsection{eg1.cc}

\lstinputlisting[language=C++]{../../src/examples/echo/eg1.cc}

\clearpage
\subsection{eg2\_impl.cc}

\lstinputlisting[language=C++]{../../src/examples/echo/eg2_impl.cc}

\clearpage
\subsection{eg2\_clt.cc}

\lstinputlisting[language=C++]{../../src/examples/echo/eg2_clt.cc}

\clearpage
\subsection{eg3\_impl.cc}

\lstinputlisting[language=C++]{../../src/examples/echo/eg3_impl.cc}

\clearpage
\subsection{eg3\_clt.cc}

\lstinputlisting[language=C++]{../../src/examples/echo/eg3_clt.cc}

\clearpage
\subsection{eg3\_tieimpl.cc}

\lstinputlisting[language=C++]{../../src/examples/echo/eg3_tieimpl.cc}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{C++ language mapping}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Now that you are familiar with the basics, it is important to
familiarise yourself with the standard IDL to C++ language mapping.
The mapping is described in detail in~\cite{cxxmapping}. If you have
not done so, you should obtain a copy of the document and use that as
the programming guide to omniORB.

The specification is not an easy read. The alternative is to use one
of the books on CORBA programming. For instance, Henning and Vinoski's
`Advanced CORBA Programming with C++'~\cite{henning1999} includes many
example code fragments to illustrate how to use the C++ mapping.


\section{omniORB 2 BOA compatibility}
\label{sec:BOAcompat}

Before the Portable Object Adapter (POA) specification, many of the
details of how servant objects should be implemented and registered
with the system were unspecified, so server-side code was not portable
between ORBs. The POA specification rectifies that. For compatibility,
omniORB 4 still supports the old omniORB 2.x BOA mapping, but you
should always use the POA mapping for new code. BOA code and POA code
can coexist within a single program. 

If you use the \cmdline{-WbBOA} option to omniidl, it will generate
skeleton code with (nearly) the same interface as the old omniORB 2
BOA mapping, as well as code to be used with the POA. Note that since
the major problem with the BOA specification was that server code was
not portable between ORBs, it is unlikely that omniORB's BOA
compatibility will help you much if you are moving from a different
BOA-based ORB.

The BOA compatibility permits the majority of BOA code to compile
without difficulty. However, there are a number of constructs which
relied on omniORB 2 implementation details which no longer work.

\begin{itemize}

\item omniORB 2 did not use distinct types for object references and
servants, and often accepted a pointer to a servant when the CORBA
specification says it should only accept an object reference. Such
code will not compile under omniORB 4.

\item The reverse is true for \op{BOA::obj\_is\_ready}. It now only
works when passed a pointer to a servant object, not an object
reference. The more commonly used mechanism of calling
\code{\_obj\_is\_ready(boa)} on the servant object still works as
expected.

\item It used to be the case that the skeleton class for interface
\intf{I} (\type{\_sk\_I}) was derived from class \type{I}. This meant
that the names of any types declared in the interface were available
in the scope of the skeleton class. This is no longer true. If you
have an interface:

\begin{idllisting}
interface I {
  struct S {
    long a,b;
  };
  S op();
};
\end{idllisting}

\noindent then where before the implementation code might have been:

\begin{cxxlisting}
class I_impl : public virtual _sk_I {
  S op();  // _sk_I is derived from I
};
I::S I_impl::op() {
  S ret;
  // ...
}
\end{cxxlisting}

\noindent it is now necessary to fully qualify all uses of \type{S}:

\begin{cxxlisting}
class I_impl : public virtual _sk_I {
  I::S op(); // _sk_I is not derived from I
};
I::S I_impl::op() {
  I::S ret;
  // ...
}
\end{cxxlisting}


\item The proprietary omniORB 2 LifeCycle extensions are no longer
supported. All of the facilities it offered can be implemented with
the POA interfaces, and the \code{omniORB::LOCATION\_FORWARD}
exception (see section~\ref{sec:locationForward}). Code which used the
old interfaces will have to be rewritten.


\end{itemize}


\section{omniORB 3.0 compatibility}

omniORB 4 is almost completely source-code compatible with omniORB
3.0. There are two main cases where code may have to change. The first
is code that uses the omniORB API, some aspects of which have
changed. The omniORB configuration file also has a new format. See the
next chapter for details of the new API and configuration file.

The second case of code that may have to change is code using the
Dynamic Any interfaces. The standard changed quite significantly
between CORBA 2.2 and CORBA 2.3; omniORB 3.0 supported the old CORBA
2.2 interfaces; omniORB 4 uses the new mapping. The changes are
largely syntax changes, rather than semantic differences.


\section{omniORB 4.0 compatibility}

omniORB 4.2 is source-code compatible with omniORB 4.0, with four
exceptions:

\begin{enumerate}

\item As required by the 1.1 version of the CORBA C++ mapping
  specification, the \type{RefCountServantBase} class has been
  deprecated, and the reference counting functionality moved into
  \type{ServantBase}. For backwards compatibility,
  \type{RefCountServantBase} still exists, but is now defined as an
  empty struct. Most code will continue to work unchanged, but code
  that explicitly calls \op{RefCountServantBase::\_add\_ref} or
  \op{\_remove\_ref} will no longer compile.

\item omniORB 4.0 had an option for Any extraction semantics that was
  compatible with omniORB 2.7, where ownership of extracted values was
  not maintained by the Any. That option is no longer available.

\item The members of the \code{clientSendRequest} interceptor have
  been changed, replacing all the separate variables with a single
  member of type \code{GIOP\_C}. All the values previously available
  can be accessed through the \code{GIOP\_C} instance.

\item The C++ mapping contains Any insertion operators for sequence
  types that are passed by pointer, which cause the Any to take
  ownership of the inserted sequence. In omniORB 4.0 and earlier, the
  sequence was immediately marshalled into the Any's internal buffer,
  and the sequence was deleted. In omniORB 4.1, the sequence pointer
  is stored by the Any, and the sequence is deleted later when the Any
  is destroyed.

  For most uses, this change is not visible to application code.
  However, if a sequence is constructed using an application-supplied
  buffer with the release flag set to \code{false} (meaning that the
  application continues to own the buffer), it is now important that
  the buffer is not deleted or modified while the Any exists, since
  the Any continues to refer to the buffer contents.  This change
  means that code that worked with omniORB 4.0 may now fail with 4.1,
  with the Any seeing modified data or the process crashing due to
  accessing deleted data. To avoid this situation, use the alternative
  Any insertion operator using a const reference, which copies the
  sequence.

\end{enumerate}


\section{omniORB 4.1 compatibility}

omniORB 4.2 is source-code compatible with omniORB 4.1 with one
exception:

\begin{enumerate}

\item When omniORB 4.1 and earlier detected a timeout condition, they
  would throw the \code{CORBA::TRANSIENT} system exception. omniORB
  4.2 supports the \code{CORBA::TIMEOUT} system exception that was
  introduced with the CORBA Messaging specification. Application code
  that caught \code{CORBA::TRANSIENT} to handle timeout situations
  should be updated to catch \code{CORBA::TIMEOUT}
  instead. Alternatively, to avoid code changes, omniORB can be
  configured to throw \code{CORBA::TRANSIENT} for timeouts, by setting
  the \code{throwTransient\dsc{}OnTimeout} parameter to \code{1}. See
  section~\ref{sec:clientconf}.

\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{omniORB configuration and API}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:config}

omniORB has a wide range of parameters that can be configured. They
can be set in the configuration file / Windows registry, as
environment variables, on the command line, or within a proprietary
extra argument to \op{CORBA::ORB\_init}. A few parameters can be
configured at run time. This chapter lists all the configuration
parameters, and how they are used.

\section{Setting parameters}

When \op{CORBA::ORB\_init} is called, the value for each configuration
parameter is searched for in the following order:

\begin{enumerate}

\item Command line arguments
\item \op{ORB\_init} options
\item Environment variables
\item Configuration file / Windows registry
\item Built-in defaults

\end{enumerate}

\subsection{Command line arguments}

Command line arguments take the form
`\cmdline{-ORB}\textit{parameter}', and usually expect another
argument. An example is `\cmdline{-ORBtraceLevel 10}'.


\subsection{ORB\_init() parameter}

\op{ORB\_init}'s extra argument accepts an array of two-dimensional
string arrays, like this:

\begin{cxxlisting}
const char* options[][2] = { { "traceLevel", "1" }, { 0, 0 } }; 
orb = CORBA::ORB_init(argc,argv,"omniORB4",options); 
\end{cxxlisting}


\subsection{Environment variables}

Environment variables consist of the parameter name prefixed with
`\cmdline{ORB}'. Using bash, for example

\begin{makelisting}
export ORBtraceLevel=10
\end{makelisting}


\subsection{Configuration file}

The best way to understand the format of the configuration file is to
look at the \file{sample.cfg} file in the omniORB distribution. Each
parameter is set on a single line like

\begin{verbatim}
traceLevel = 10
\end{verbatim}

Some parameters can have more than one value, in which case the
parameter name may be specified more than once, or you can leave it
out:

\begin{verbatim}
InitRef = NameService=corbaname::host1.example.com
        = InterfaceRepository=corbaloc::host2.example.com:1234/IfR
\end{verbatim}


\begin{statement}
Command line arguments and environment variables prefix parameter
names with `-ORB' and `ORB' respectively, but the configuration file
and the extra argument to \op{ORB\_init} do not use a prefix.
\end{statement}


\subsection{Windows registry}

On Windows, configuration parameters can be stored in the registry,
under the key \file{HKEY_LOCAL_MACHINE\SOFTWARE\omniORB}.

The file \file{sample.reg} shows the settings that can be made. It can
be edited and then imported into regedit.



\section{Tracing options}

The following options control debugging trace output.


\confopt{traceLevel}{1}

omniORB can output tracing and diagnostic messages to the standard
error stream. The following levels are defined:

\vspace{\baselineskip}

\begin{tabular}{lp{.6\textwidth}}
%HEVEA\\

level 0      & critical errors only\\
level 1      & informational messages only\\
level 2      & configuration information and warnings\\

level 5      & notifications when server threads are
               created and communication endpoints are shutdown\\

level 10     & execution and exception traces\\
level 25     & trace each send or receive of a GIOP message\\
level 30     & dump up to 128 bytes of each GIOP message\\
level 40     & dump complete contents of each GIOP message\\
\end{tabular}

\vspace{\baselineskip}

\noindent The trace level is cumulative, so at level 40, all trace
messages are output.


\confopt{traceExceptions}{0}

If the \code{traceExceptions} parameter is set \code{true}, all system
exceptions are logged as they are thrown, along with details about
where the exception is thrown from. This parameter is enabled by
default if the traceLevel is set to 10 or more.


\confopt{traceInvocations}{0}

If the \code{traceInvocations} parameter is set \code{true}, all local
and remote invocations are logged, in addition to any logging that may
have been selected with \code{traceLevel}.


\confopt{traceInvocationReturns}{0}

If the \code{traceInvocationReturns} parameter is set \code{true}, a
log message is output as an operation invocation returns. In
conjunction with \code{traceInvocations} and \code{traceTime}
(described below), this provides a simple way of timing CORBA calls
within your application.


\confopt{traceThreadId}{1}

If \code{traceThreadId} is set \code{true}, all trace messages are
prefixed with the id of the thread outputting the message. This can be
handy for making sense of multi-threaded code, but it adds overhead to
the logging so it can be disabled.


\confopt{traceTime}{1}

If \code{traceTime} is set \code{true}, all trace messages are
prefixed with the time. This is useful, but on some platforms it adds
a very large overhead, so it can be turned off.


\confopt{traceFile}{}

omniORB's tracing is normally sent to stderr. If \code{traceFile} it
set, the specified file name is used for trace messages.


\subsection{Tracing API}

The tracing parameters can be modified at runtime by assigning to the
following variables

\begin{cxxlisting}
namespace omniORB {
  CORBA::ULong   traceLevel;
  CORBA::Boolean traceExceptions;
  CORBA::Boolean traceInvocations;
  CORBA::Boolean traceInvocationReturns;
  CORBA::Boolean traceThreadId;
  CORBA::Boolean traceTime;
};
\end{cxxlisting}

\noindent
Log messages can be sent somewhere other than stderr by registering a
logging function which is called with the text of each log message:

\begin{cxxlisting}
namespace omniORB {
  typedef void (*logFunction)(const char*);
  void setLogFunction(logFunction f);
};
\end{cxxlisting}

\noindent
The log function must not make any CORBA calls, since that could lead
to infinite recursion as outputting a log message caused other log
messages to be generated, and so on.




\section{Miscellaneous global options}

These options control miscellaneous features that affect the whole ORB
runtime.

\confopt{dumpConfiguration}{0}

If set \code{true}, the ORB dumps the values of all configuration
parameters at start-up.


\confopt{scanGranularity}{5}

As explained in chapter~\ref{chap:connections}, omniORB regularly
scans incoming and outgoing connections, so it can close unused
ones. This value is the granularity in seconds at which the ORB
performs its scans. A value of zero turns off the scanning altogether.


\confopt{nativeCharCodeSet}{ISO-8859-1}

The native code set the application is using for \type{char} and
\type{string}. See chapter~\ref{chap:codesets}.


\confopt{nativeWCharCodeSet}{UTF-16}

The native code set the application is using for \type{wchar} and
\type{wstring}. See chapter~\ref{chap:codesets}.


\confopt{defaultCharCodeSet}{\textit{none}}

The default code set used for \type{char} and \type{string} if the
server does not specify it in its IORs. See
chapter~\ref{chap:codesets}.


\confopt{defaultWCharCodeSet}{\textit{none}}

The default code set used for \type{wchar} and \type{wstring} if the
server does not specify it in its IORs. See
chapter~\ref{chap:codesets}.


\confopt{copyValuesInLocalCalls}{1}

Determines whether valuetype parameters in local calls are copied or
not. See chapter~\ref{chap:valuetype}.


\confopt{abortOnInternalError}{0}

If this is set \code{true}, internal fatal errors will abort
immediately, rather than throwing the \type{omniORB::fatalException}
exception.  This can be helpful for tracking down bugs, since it
leaves the call stack intact.

\confopt{abortOnNativeException}{0}

On Windows, `native' exceptions such as segmentation faults and divide
by zero appear as C++ exceptions that can be caught with \code{catch
  (...)}. Setting this parameter to \code{true} causes such exceptions
to abort the process instead.


\vspace{\baselineskip}\par
\noindent
\code{maxSocketSend}\\
\code{maxSocketRecv}\\[.1ex]

\noindent
On some platforms, calls to send() and recv() have a limit on the
buffer size that can be used. These parameters set the limits in bytes
that omniORB uses when sending / receiving bulk data.

The default values are platform specific. It is unlikely that you will
need to change the values from the defaults.

The minimum valid limit is 1KB, 1024 bytes.


\confopt{socketSendBuffer}{-1 \textit{or} 16384}

On Windows, there is a kernel buffer used during send operations.  A
bug in Windows means that if a send uses the entire kernel buffer, a
select() on the socket blocks until all the data has been acknowledged
by the receiver, resulting in dreadful performance. This parameter
modifies the socket send buffer from its default (8192 bytes on
Windows) to the value specified. If this parameter is set to -1, the
socket send buffer is left at the system default.

On Windows, the default value of this parameter is 16384 bytes; on all
other platforms the default is -1.


\confopt{validateUTF8}{0}

When transmitting a string that is supposed to be UTF-8, omniORB
usually passes it directly, assuming that it is valid. With this
parameter set \code{true}, omniORB checks that all UTF-8 strings are
valid, and throws DATA\_CONVERSION if not.


\section{Client side options}
\label{sec:clientconf}

These options control aspects of client-side behaviour.


\confopt{InitRef}{\textit{none}}

Specify objects available from
\op{ORB::resolve\_initial\_references}. The arguments take the form
<\textit{key}>=<\textit{uri}>, where \textit{key} is the name given to
\op{resolve\_\dsc{}initial\_\dsc{}references} and \textit{uri} is a
valid CORBA object reference URI, as detailed in
chapter~\ref{chap:ins}.


\confopt{DefaultInitRef}{\textit{none}}

Specify the default URI prefix for
\op{resolve\_\dsc{}initial\_\dsc{}references}, as explained in
chapter~\ref{chap:ins}.


\confopt{clientTransportRule}{* unix,tcp,ssl}

Used to specify the way the client contacts a server, depending on the
server's address. See section~\ref{sec:clientRule} for details.


\confopt{clientCallTimeOutPeriod}{0}

Call timeout in milliseconds for the client side. If a call takes
longer than the specified number of milliseconds, the ORB closes the
connection to the server and raises a \code{TRANSIENT} exception. A
value of zero means no timeout; calls can block for ever. See
section~\ref{sec:timeoutAPI} for more information about timeouts.

\vspace{.5\baselineskip}

\noindent\textbf{Note}: omniORB 3 had timeouts specified in seconds;
omniORB 4.0 and later use milliseconds for timeouts.


\confopt{clientConnectTimeOutPeriod}{0}

The timeout that is used in the case that a new network connection is
established to the server. A value of zero means that the normal call
timeout is used. See section~\ref{sec:timeoutAPI} for more information
about timeouts.


\confopt{supportPerThreadTimeOut}{0}

If this parameter is set \code{true}, timeouts can be set on a per
thread basis, as well as globally and per object. Checking per-thread
storage has a noticeable performance impact, so it is turned off by
default.


\confopt{resetTimeoutOnRetries}{0}

If \code{true}, the call timeout is reset when an exception handler
causes a call to be retried. If \code{false}, the timeout is not
reset, and therefore applies to the call as a whole, rather than to
each individual call attempt.

\confopt{throwTransientOnTimeout}{0}

omniORB 4.2 supports the \code{CORBA::TIMEOUT} exception that is part
of the CORBA Messaging specification. By default, that is the
exception thrown when timeouts occur. Previous omniORB releases did
not have the \code{CORBA::TIMEOUT} exception, and instead used
\code{CORBA::TRANSIENT}. If this parameter is set \code{true}, omniORB
follows the old behaviour of throwing \code{CORBA::TRANSIENT} when a
timeout occurs.


\confopt{outConScanPeriod}{120}

Idle timeout in seconds for outgoing (i.e.\ client initiated)
connections. If a connection has been idle for this amount of time,
the ORB closes it. See section~\ref{sec:connShutdown}.


\confopt{maxGIOPConnectionPerServer}{5}

The maximum number of concurrent connections the ORB will open to a
\emph{single} server. If multiple threads on the client call the same
server, the ORB opens additional connections to the server, up to the
maximum specified by this parameter. If the maximum is reached,
threads are blocked until a connection becomes free for them to use.


\confopt{oneCallPerConnection}{1}

When this parameter is set to \code{true} (the default), the ORB will
only send a single call on a connection at a time. If multiple client
threads invoke on the same server, multiple connections are opened, up
to the limit specified by
\code{maxGIOP\dsc{}ConnectionPerServer}. With this parameter set to
\code{false}, the ORB will allow concurrent calls on a single
connection. This saves connection resources, but requires slightly
more management work for both client and server. Some server-side ORBs
(including omniORB versions before 4.0) serialise all incoming calls
on a single connection.

\confopt{maxInterleavedCallsPerConnection}{5}

The maximum number of calls that can be interleaved on a connection.
If more concurrent calls are made, they are queued.


\confopt{offerBiDirectionalGIOP}{0}

If set \code{true}, the client will indicate to servers that it is
willing to accept callbacks on client-initiated connections using
bidirectional GIOP, provided the relevant POA policies are set. See
section~\ref{sec:bidir}.


\confopt{diiThrowsSysExceptions}{0}

If this is \code{true}, DII functions throw system exceptions; if it
is \code{false}, system exceptions that occur are passed through the
\type{Environment} object.


\confopt{verifyObjectExistsAndType}{1}

By default, omniORB uses the GIOP \code{LOCATE\_REQUEST} message to
verify the existence of an object prior to the first invocation. In
the case that the full type of the object is not known, it instead
calls the \op{\_is\_a} operation to check the object's type. Some ORBs
have bugs that mean one or other of these operations fail. Setting
this parameter \code{false} prevents omniORB from making these calls.


\confopt{giopTargetAddressMode}{0}

GIOP 1.2 supports three addressing modes for contacting objects. This
parameter selects the mode that omniORB uses. A value of 0 means
\code{GIOP::KeyAddr}; 1 means \code{GIOP::ProfileAddr}; 2 means
\code{GIOP::ReferenceAddr}.


\confopt{immediateAddressSwitch}{0}

If \code{true}, the client will immediately switch to use a new
address to contact an object after a failure. If \code{false} (the
default), the current address will be retried in certain
circumstances.

\confopt{resolveNamesForTransportRules}{1}

If \code{true}, names in IORs will be resolved when evaluating client
transport rules, and remembered from then on; if \code{false}, names
will not be resolved until connect time. Client transport rules based
on IP address will therefore not match, but some platforms can use
external knowledge to pick the best address to use if given a name to
connect to.

\confopt{retainAddressOrder}{1}

For IORs with multiple addresses, determines how the address to
connect to is chosen. When first establishing a connection, the
addresses are ordered according to the client transport rules (after
resolving names if \code{resolveNamesFor\dsc{}TransportRules} is
\code{true}), and the addresses are tried in priority order until one
connects successfully. For as long as there is at least one connection
open to the address, new connections continue to use the same address.

After a failure, or after all open connections have been scavenged and
closed, this parameter determines the address used to reconnect on the
next call. If this parameter is \code{true} (the default), the address
order and chosen address within the order is remembered; if
\code{false}, a new connection attempt causes re-evaluation of the
order (in case name resolutions change), and the highest priority
address is tried first.

\confopt{bootstrapAgentHostname}{\textit{none}}

If set, this parameter indicates the hostname to use for look-ups
using the obsolete Sun bootstrap agent. This mechanism is superseded
by the interoperable naming service.


\confopt{bootstrapAgentPort}{900}

The port number for the obsolete Sun bootstrap agent.


\confopt{principal}{\textit{none}}

GIOP 1.0 and 1.1 have a request header field named `principal', which
contains a sequence of octets. It was never defined what it should
mean, and its use is now deprecated; GIOP 1.2 has no such field. Some
systems (e.g.\ Gnome) use the principal field as a primitive
authentication scheme. This parameter sets the data omniORB uses in
the principal field. The default is an empty sequence.



\section{Server side options}

These parameters affect server-side operations.


\vspace{\baselineskip}

\noindent
\code{endPoint~~~~~~~~~} ~~ \textit{default} = \code{giop:tcp::}\\
\code{endPointNoListen}\\
\code{endPointPublish}\\
\code{endPointNoPublish}\\
\code{endPointPublishAllIFs}\\[.1ex]

\noindent
These options determine the end-points the ORB should listen on, and
the details that should be published in IORs. See
chapter~\ref{chap:connections} for details.



\confopt{serverTransportRule}{* unix,tcp,ssl}

Configure the rules about whether a server should accept an incoming
connection from a client. See section~\ref{sec:serverRule} for
details.


\confopt{serverCallTimeOutPeriod}{0}

This timeout is used to catch the situation that the server starts
receiving a request, but the end of the request never comes. If a
calls takes longer than the specified number of milliseconds to
arrive, the ORB shuts the connection. A value of zero means never
timeout.


\confopt{inConScanPeriod}{180}

Idle timeout in seconds for incoming connections. If a connection has
been idle for this amount of time, the ORB closes it. See
section~\ref{sec:connShutdown}.


\confopt{threadPerConnectionPolicy}{1}

If \code{true} (the default), the ORB dedicates one server thread to
each incoming connection. Setting it \code{false} means the server
should use a thread pool.


\confopt{maxServerThreadPerConnection}{100}

If the client multiplexes several concurrent requests on a single
connection, omniORB uses extra threads to service them. This parameter
specifies the maximum number of threads that are allowed to service a
single connection at any one time.


\confopt{maxServerThreadPoolSize}{100}

The maximum number of threads the server will allocate to do various
tasks, including dispatching calls in the thread pool mode. This
number does not include threads dispatched under the thread per
connection server mode.


\confopt{threadPerConnectionUpperLimit}{10000}

If the \code{threadPerConnectionPolicy} parameter is \code{true}, the
ORB can automatically transition to thread pool mode if too many
connections arrive. This parameter sets the number of connections at
which thread pooling is started. The default of 10000 is designed to
mean that it never happens.


\confopt{threadPerConnectionLowerLimit}{9000}

If thread pooling was started because the number of connections hit
the upper limit, this parameter determines when thread per connection
should start again.


\confopt{threadPoolWatchConnection}{1}

After dispatching an upcall in thread pool mode, the thread that has
just performed the call can watch the connection for a short time
before returning to the pool. This leads to less thread switching for
a series of calls from a single client, but is less fair if there are
concurrent clients. The connection is watched if the number of threads
concurrently handling the connection is less than or equal to the
value of this parameter. i.e.\ if the parameter is zero, the
connection is never watched; if it is 1, the last thread managing a
connection watches it; if 2, the connection is still watched if there
is one other thread still in an upcall for the connection, and so
on. See section~\ref{sec:watchConn}.


\confopt{connectionWatchPeriod}{50000}

For each endpoint, the ORB allocates a thread to watch for new
connections and to monitor existing connections for calls that should
be handed by the thread pool. The thread blocks in select() or similar
for a period, after which it re-scans the lists of connections it
should watch. This parameter is specified in microseconds.


\confopt{connectionWatchImmediate}{0}

When a thread handles an incoming call, it unmarshals the arguments
then marks the connection as watchable by the connection watching
thread, in case the client sends a concurrent call on the same
connection. If this parameter is set to the default \code{false}, the
connection is not actually watched until the next connection watch
period (determined by the \code{connectionWatchPeriod} parameter).  If
this parameter is set \code{true}, the connection watching thread is
immediately signalled to watch the connection. That leads to faster
interactive response to clients that multiplex calls, but adds
significant overhead along the call chain.

Note that this setting has no effect on Windows, since it has no
mechanism for signalling the connection watching thread.


\confopt{acceptBiDirectionalGIOP}{0}

Determines whether a server will ever accept clients' offers of
bidirectional GIOP connections. See section~\ref{sec:bidir}.


\confopt{unixTransportDirectory}{/tmp/omni-\%u}

(Unix platforms only). Selects the location used to store Unix domain
sockets. The `\code{\%u}' is expanded to the user name.


\confopt{unixTransportPermission}{0777}

(Unix platforms only). Determines the octal permission bits for Unix
domain sockets. By default, all users can connect to a server, just as
with TCP.


\confopt{supportCurrent}{1}

omniORB supports the \type{PortableServer::Current} interface to
provide thread context information to servants. Supporting current has
a small but noticeable run-time overhead due to accessing thread
specific storage, so this option allows it to be turned off.


\confopt{objectTableSize}{0}

Hash table size of the Active Object Map. If this is zero, the ORB
uses a dynamically resized open hash table. This is normally the best
option, but it leads to less predictable performance since any
operation which adds or removes a table entry may trigger a resize. If
set to a non-zero value, the hash table has the specified number of
entries, and is never resized. Note that the hash table is open, so
this does not limit the number of active objects, just how efficiently
they can be located.


\confopt{poaHoldRequestTimeout}{0}

If a POA is put in the \code{HOLDING} state, calls to it will be timed
out after the specified number of milliseconds, by raising a
\code{CORBA::TIMEOUT} exception. Zero means no timeout.

\confopt{poaUniquePersistentSystemIds}{1}

The POA specification requires that object ids in POAs with the
PERSISTENT and SYSTEM\_ID policies are unique between instantiations
of the POA. Older versions of omniORB did not comply with that, and
reused object ids. With this value \code{true}, the POA has the
correct behaviour; with \code{false}, the POA uses the old scheme for
compatibility.

\confopt{idleThreadTimeout}{10}

When a thread created by omniORB becomes idle, it is kept alive for a
while, in case a new thread is required. Once a thread has been idle
for the number of seconds specified in this parameter, it exits.

\confopt{supportBootstrapAgent}{0}

If set \code{true}, servers support the Sun bootstrap agent protocol.


\subsection{Main thread selection}

There is one server-side parameter that must be set with an API
function, rather than a normal configuration parameter:

\begin{cxxlisting}
namespace omniORB {
  void setMainThread();
};
\end{cxxlisting}

\noindent
POAs with the \code{MAIN\_THREAD} policy dispatch calls on the `main'
thread.  By default, omniORB assumes that the thread that initialised
the omnithread library is the `main' thread. To choose a different
thread, call this function from the desired `main' thread. The calling
thread must have an \code{omni\_thread} associated with it (i.e.\ it
must have been created by omnithread, or
\op{omni\_thread::create\_\dsc{}dummy} must have been called). If it
does not, the function throws \code{CORBA::\dsc{}INITIALIZE}.
                                                                  
Note that calls are only actually dispatched to the `main' thread if
\op{ORB::run} or \op{ORB::perform\_work} is called from that thread.




\section{GIOP and interoperability options}

These options control omniORB's use of GIOP, and cover some areas
where omniORB can work around buggy behaviour by other ORBs.


\confopt{maxGIOPVersion}{1.2}

Choose the maximum GIOP version the ORB should support. Valid values
are 1.0, 1.1 and 1.2.


\confopt{giopMaxMsgSize}{2097152}

The largest message, in bytes, that the ORB will send or receive, to
avoid resource starvation. If the limit is exceeded, a \code{MARSHAL}
exception is thrown. The size must be >= 8192.

\confopt{strictIIOP}{1}

If \code{true}, be strict about interpretation of the IIOP
specification; if \code{false}, permit some buggy behaviour to pass.


\confopt{lcdMode}{0}

If \code{true}, select `Lowest Common Denominator' mode. This disables
various IIOP and GIOP features that are known to cause problems with
some ORBs.


\confopt{tcAliasExpand}{0}

This flag is used to indicate whether TypeCodes associated with Anys
should have aliases removed. This functionality is included because
some ORBs will not recognise an Any containing a TypeCode with aliases
to be the same as the actual type contained in the Any. There is a
performance penalty when inserting into an Any if \code{tcAliasExpand}
is set to 1.


\confopt{useTypeCodeIndirections}{1}

TypeCode Indirections reduce the size of marshalled TypeCodes, and are
essential for recursive types, but some old ORBs do not support them.
Setting this flag to \code{false} prevents the use of indirections
(and, therefore, prevents the use of recursive TypeCodes).


\confopt{acceptMisalignedTcIndirections}{0}

If \code{true}, try to fix a mis-aligned indirection in a
typecode. This is used to work around a bug in some old versions of
Visibroker's Java ORB.


\vspace{2\baselineskip}


\section{System Exception Handlers}

By default, all system exceptions that are raised during an operation
invocation, with the exception of some cases of
\code{CORBA::TRANSIENT}, are propagated to the application code. Some
applications may prefer to trap these exceptions within the proxy
objects so that the application logic does not have to deal with the
error condition. For example, when a \code{CORBA::COMM\_FAILURE} is
received, an application may just want to retry the invocation until
it finally succeeds. This approach is useful for objects that are
persistent and have idempotent operations.

omniORB provides a set of functions to install exception handlers.
Once they are installed, proxy objects will call these handlers when
the associated system exceptions are raised by the ORB runtime.
Handlers can be installed for \code{CORBA::\dsc{}TRANSIENT},
\code{CORBA::\dsc{}TIMEOUT}, \code{CORBA::COMM\_FAILURE} and
\code{CORBA::\dsc{}SystemException}.  This last handler covers all
system exceptions other than the three specific ones covered by the
first three handlers. An exception handler can be installed for
individual proxy objects, or it can be installed for all proxy objects
in the address space.


\subsection{Minor codes}

omniORB makes extensive use of exception minor codes to indicate the
specific circumstances surrounding a system exception.  The file
\file{include/omniORB4/minorCode.h} contains definitions of all the
minor codes used in omniORB, covering codes allocated in the CORBA
specification, and ones specific to omniORB. In compilers with
namespace support, the minor code constants appear in namespace
\code{omni}; otherwise they are in the global scope.

Applications can use minor codes to adjust their behaviour according
to the condition, e.g.

\begin{cxxlisting}
try {
  ...
}
catch (CORBA::TRANSIENT& ex) {
  if (ex.minor() == omni::TRANSIENT_ConnectFailed) {
    // retry with a different object reference...
  }
  else {
    // print an error message...
  }
}
\end{cxxlisting}



\subsection{CORBA::TRANSIENT handlers}

\code{TRANSIENT} exceptions can occur in many circumstances. One
circumstance is as follows:

\begin{enumerate}

\item The client invokes on an object reference.
\item The object replies with a \code{LOCATION\_FORWARD} message.
\item The client caches the new location and retries to the new location.
\item Time passes...
\item The client tries to invoke on the object again, using the
      cached, forwarded location. 
\item The attempt to contact the object fails.
\item The ORB runtime resets the location cache and throws a
      \code{TRANSIENT} exception with minor code
      \code{TRANSIENT\_FailedOnForwarded}.

\end{enumerate}

In this situation, the default \code{TRANSIENT} exception handler
retries the call, using the object's original location. If the retry
results in another \code{LOCATION\_\dsc{}FORWARD}, to the same or a
different location, and \emph{that} forwarded location fails
immediately, the \code{TRANSIENT} exception will occur again, and the
pattern will repeat. With repeated exceptions, the handler starts
adding delays before retries, with exponential back-off.

In all other circumstances, the default \code{TRANSIENT} handler just
passes the exception on to the caller.

Applications can override the default behaviour by installing their
own exception handler. The API to do so is summarised below:

\begin{cxxlisting}
namespace omniORB {
  
  typedef CORBA::Boolean 
  (*transientExceptionHandler_t)(void* cookie,
                                 CORBA::ULong n_retries,
                                 const CORBA::TRANSIENT& ex);

  void 
  installTransientExceptionHandler(void* cookie,
                                   transientExceptionHandler_t fn);

  void
  installTransientExceptionHandler(CORBA::Object_ptr obj,
                                   void* cookie,
                                   transientExceptionHandler_t fn);
}
\end{cxxlisting}

The overloaded \op{installTransientExceptionHandler} function is used
to install the exception handlers for \code{CORBA::TRANSIENT}.  Two
forms are available: the first form installs an exception handler for
all object references except for those which have an exception handler
installed by the second form, which takes an additional argument to
identify the target object reference. The argument \code{cookie} is an
opaque pointer which will be passed on by the ORB when it calls the
exception handler.

An exception handler will be called by proxy objects with three
arguments. The \code{cookie} is the opaque pointer registered by
\op{installTransientException\dsc{}Handler}. The argument
\code{n\_retries} is the number of times the proxy has called this
handler for the same invocation. The argument \code{ex} is the value
of the exception caught.  The exception handler is expected to do
whatever is appropriate and return a boolean value. If the return
value is \code{true}, the proxy object retries the operation. If the
return value is \code{false}, the original exception is propagated
into the application code. In the case of a \code{TRANSIENT} exception
due to a failed location forward, the exception propagated to the
application is the \emph{original} exception that caused the
\code{TRANSIENT} (e.g.\ a \code{COMM\_FAILURE} or
\code{OBJECT\_NOT\_EXIST}), rather than the \code{TRANSIENT}
exception\footnote{This is different from omniORB 4.0 and earlier,
  where it was the \code{TRANSIENT} exception that was propagated to
  the application.}.

The following sample code installs a simple exception handler for all
objects and for a specific object:

\begin{cxxlisting}
CORBA::Boolean my_transient_handler1(void* cookie,
                                     CORBA::ULong retries,
                                     const CORBA::TRANSIENT& ex)
{
   cerr << "transient handler 1 called." << endl;
   return true;           // retry immediately.
}
 
CORBA::Boolean my_transient_handler2(void* cookie,
                                     CORBA::ULong retries,
                                     const CORBA::TRANSIENT& ex)
{
   cerr << "transient handler 2 called." << endl;
   return false;          // do not retry.
}


static Echo_ptr myobj;

void installhandlers()
{
   omniORB::installTransientExceptionHandler(0, my_transient_handler1);
   // All proxy objects will call my_transient_handler1 from now on.

   omniORB::installTransientExceptionHandler(myobj, 0, my_transient_handler2);
   // The proxy object of myobj will call my_transient_handler2 from now on.
}
\end{cxxlisting}


\subsection{CORBA::TIMEOUT}

When a call timeout occurs, by default the ORB throws
\code{CORBA::TIMEOUT}. The default behaviour of the proxy objects is
to propagate this exception to the application. Applications can
override the default behaviour by installing their own exception
handlers. The API to do so is summarised below:

\begin{cxxlisting}
typedef CORBA::Boolean
(*timeoutExceptionHandler_t)(void* cookie,
                             CORBA::ULong n_retries,
                             const CORBA::TIMEOUT& ex);

void
installTimeoutExceptionHandler(void* cookie,
                               timeoutExceptionHandler_t fn);

void
installTimeoutExceptionHandler(CORBA::Object_ptr obj,
                               void* cookie,
                               timeoutExceptionHandler_t fn);
\end{cxxlisting}

The functions are equivalent to their counterparts for
\code{CORBA::TRANSIENT}.

omniORB version 4.1 and earlier did not have the \code{CORBA::TIMEOUT}
exception, and threw \code{CORBA::TRANSIENT} instead. If the
\code{throwTransientOnTimeout} configuration parameter is set to
\code{1}, omniORB 4.2 reverts to this behaviour, and calls the
transient exception handler instead of the timeout exception handler.

The timeout exception handler is used when a CORBA call times out. It
is \emph{not} called when an AMI poller operation throws
\code{CORBA::TIMEOUT}. In that situation, the exception is always
propagated to the caller.



\subsection{CORBA::COMM\_FAILURE}

If the ORB has successfully contacted a server at some point, and
access to it subsequently fails (and the condition for
\code{TRANSIENT} described above does not occur), the ORB raises a
\code{CORBA::COMM\_\dsc{}FAILURE} exception.

The default behaviour of the proxy objects is to propagate this
exception to the application. Applications can override the default
behaviour by installing their own exception handlers. The API to do so
is summarised below:

\begin{cxxlisting}
typedef CORBA::Boolean
(*commFailureExceptionHandler_t)(void* cookie,
                                 CORBA::ULong n_retries,
                                 const CORBA::COMM_FAILURE& ex);

void
installCommFailureExceptionHandler(void* cookie,
                                   commFailureExceptionHandler_t fn);

void
installCommFailureExceptionHandler(CORBA::Object_ptr obj,
                                   void* cookie,
                                   commFailureExceptionHandler_t fn);
\end{cxxlisting}

The functions are equivalent to their counterparts for
\code{CORBA::TRANSIENT}.


\subsection{CORBA::SystemException}

If a system exceptions other than \code{TRANSIENT}, \code{TIMEOUT} or
\code{COMM\_FAILURE} occurs, the default behaviour of the proxy
objects is to propagate this exception to the application.
Applications can override the default behaviour by installing their
own exception handlers. The API to do so is summarised below:


\begin{cxxlisting}
typedef CORBA::Boolean
(*systemExceptionHandler_t)(void* cookie,
                            CORBA::ULong n_retries,
                            const CORBA::SystemException& ex);

void
installSystemExceptionHandler(void* cookie,
                              systemExceptionHandler_t fn);

void
installSystemExceptionHandler(CORBA::Object_ptr obj,
                              void* cookie,
                              systemExceptionHandler_t fn);
\end{cxxlisting}

The functions are equivalent to their counterparts for
\code{CORBA::TRANSIENT}.



\subsection{Extended exception handlers}

New in omniORB 4.2, each of the exception handlers described above
also has an `extended' form in which the exception handler takes two
additional parameters, the object reference being invoked upon, and a
string containing the name of the operation invoked. e.g.:

\begin{cxxlisting}
namespace omniORB {
  
  typedef CORBA::Boolean 
  (*transientExceptionHandlerExt_t)(void*                   cookie,
                                    CORBA::ULong            n_retries,
                                    const CORBA::TRANSIENT& ex,
                                    CORBA::Object_ptr       obj,
                                    const char*             op);

  void 
  installTransientExceptionHandlerExt(void* cookie,
                                     transientExceptionHandlerExt_t fn);

  void
  installTransientExceptionHandlerExt(CORBA::Object_ptr obj,
                                      void* cookie,
                                      transientExceptionHandlerExt_t fn);
}
\end{cxxlisting}

Note that the operation parameter can sometimes be null. By default,
omniORB sends a \code{LocateRequest} message prior to the first
operation invocation on an object reference. That \code{LocateRequest}
is subject to the same exception handling mechanism as a normal
operation invocation, but it is represented with a null operation
name. Exception handler code that uses the operation name must
correctly handle a null operation name pointer.



\section{Location forwarding}
\label{sec:locationForward}

Any CORBA operation invocation can return a \code{LOCATION\_FORWARD}
message to the caller, indicating that it should retry the invocation
on a new object reference. The standard allows ServantManagers to
trigger \code{LOCATION\_FORWARD}s by raising the
\code{PortableServer::ForwardRequest} exception, but it does not
provide a similar mechanism for normal servants. omniORB provides the
\code{omniORB::\dsc{}LOCATION\_FORWARD} exception for this purpose. It
can be thrown by any operation implementation.

\begin{cxxlisting}
namespace omniORB {
  class LOCATION_FORWARD {
  public:
    LOCATION_FORWARD(CORBA::Object_ptr objref);
  };
};
\end{cxxlisting}

\noindent The exception object consumes the object reference it is
passed.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{The IDL compiler}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:omniidl}

omniORB's IDL compiler is called omniidl. It consists of a generic
front-end parser written in C++, and a number of back-ends written in
Python. omniidl is very strict about IDL validity, so you may find
that it reports errors in IDL which compiles fine with other IDL
compilers.

The general form of an omniidl command line is:

\begin{quote} % Not the clearest bit of mark-up ever... :-)
\cmdline{omniidl }[\textit{options}]\cmdline{ -b}%
<\textit{back-end}>\cmdline{ }[\textit{back-end options}]%
\cmdline{ }<\textit{file}>
\end{quote}

\section{Common options}

The following options are common to all back-ends:

\begin{tabbing}
\cmdline{-D}\textit{name}[\cmdline{=}\textit{value}]~~ \= \kill
%HEVEA\\

\cmdline{-b}\textit{back-end}
     \> Run the specified back-end. For the C++ ORB, use \cmdline{-bcxx}.\\

\cmdline{-D}\textit{name}[\cmdline{=}\textit{value}]
     \> Define \textit{name} for the preprocessor.\\

\cmdline{-U}\textit{name}
     \> Undefine \textit{name} for the preprocessor.\\

\cmdline{-I}\textit{dir}
     \> Include \textit{dir} in the preprocessor search path.\\

\cmdline{-E}
     \> Only run the preprocessor, sending its output to stdout.\\

\cmdline{-Y}\textit{cmd}
     \> Use \textit{cmd} as the preprocessor, rather than the normal C
        preprocessor.\\

\cmdline{-N}
     \> Do not run the preprocessor.\\

\cmdline{-T}
     \> Use a temporary file, not a pipe, for preprocessor output.\\

\cmdline{-Wp}\textit{arg}[,\textit{arg}\dots]
     \> Send arguments to the preprocessor.\\

\cmdline{-Wb}\textit{arg}[,\textit{arg}\dots]
     \> Send arguments to the back-end.\\

\cmdline{-nf}
     \> Do not warn about unresolved forward declarations.\\

\cmdline{-k}
     \> Keep comments after declarations, to be used by some back-ends.\\

\cmdline{-K}
     \> Keep comments before declarations, to be used by some back-ends.\\

\cmdline{-C}\textit{dir}
     \> Change directory to \textit{dir} before writing output files.\\

\cmdline{-d}
     \> Dump the parsed IDL then exit, without running a back-end.\\

\cmdline{-p}\textit{dir}
     \> Use \textit{dir} as a path to find omniidl back-ends.\\

\cmdline{-V}
     \> Print version information then exit.\\

\cmdline{-u}
     \> Print usage information.\\

\cmdline{-v}
     \> Verbose: trace compilation stages.\\

\end{tabbing}

\noindent Most of these options are self explanatory, but some are not
so obvious.

\subsection{Preprocessor interactions}

IDL is processed by the C preprocessor before omniidl parses it.
omniidl always uses the GNU C preprocessor (which it builds with the
name omnicpp). The \cmdline{-D}, \cmdline{-U}, and \cmdline{-I}
options are just sent to the preprocessor. Note that the current
directory is not on the include search path by default---use
`\cmdline{-I.}' for that. The \cmdline{-Y} option can be used to
specify a different preprocessor to omnicpp. Beware that line
directives inserted by other preprocessors are likely to confuse
omniidl.

\subsubsection{Ancient history: Windows 9x}

The output from the C preprocessor is normally fed to the omniidl
parser through a pipe. On some Windows 98 machines (but not all!)  the
pipe does not work, and the preprocessor output is echoed to the
screen. When this happens, the omniidl parser sees an empty file, and
produces useless stub files with strange long names. To avoid the
problem, use the `\cmdline{-T}' option to create a temporary file
between the two stages.


\subsection{Forward-declared interfaces}

If you have an IDL file like:

\begin{idllisting}
interface I;
interface J {
  attribute I the_I;
};
\end{idllisting}

\noindent then omniidl will normally issue a warning:

{\small
\begin{verbatim}
  test.idl:1: Warning: Forward declared interface `I' was never
  fully defined
\end{verbatim}
}

\noindent It is illegal to declare such IDL in isolation, but it
\emph{is} valid to define interface \intf{I} in a separate file. If
you have a lot of IDL with this sort of construct, you will drown
under the warning messages. Use the \cmdline{-nf} option to suppress
them.


\subsection{Comments}

By default, omniidl discards comments in the input IDL. However, with
the \cmdline{-k} and \cmdline{-K} options, it preserves the comments
for use by the back-ends. The C++ back-end ignores this information,
but it is relatively easy to write new back-ends which \emph{do} make
use of comments.

The two different options relate to how comments are attached to
declarations within the IDL. Given IDL like:

\begin{idllisting}
interface I {
  void op1();
  // A comment
  void op2();
};
\end{idllisting}

\noindent the \cmdline{-k} flag will attach the comment to \op{op1};
the \cmdline{-K} flag will attach it to \op{op2}.



\section{C++ back-end options}
\label{sec:cxx_backend}

When you specify the C++ back-end (with \cmdline{-bcxx}), the
following \cmdline{-Wb} options are available. Note that the
\cmdline{-Wb} options must be specified \emph{after} the
\cmdline{-bcxx} option, so omniidl knows which back-end to give the
arguments to.

\begin{tabbing}
\cmdline{-Wbsplice-modules}~~ \= \kill
%HEVEA\\

\cmdline{-Wbh=}\textit{suffix}
     \> Use \textit{suffix} for generated header files. Default
        `\file{.hh}'.\\

\cmdline{-Wbs=}\textit{suffix}
     \> Use \textit{suffix} for generated stub files. Default
        `\file{SK.cc}.'\\

\cmdline{-Wbd=}\textit{suffix}
     \> Use \textit{suffix} for generated dynamic files. Default
        `\file{DynSK.cc}.'\\

\cmdline{-Wba}
     \> Generate stubs for TypeCode and Any.\\

\cmdline{-Wbtp}
     \> Generate `tie' implementation skeletons.\\

\cmdline{-Wbtf}
     \> Generate flattened `tie' implementation skeletons.\\

\cmdline{-Wbami}
     \> Generate AMI types and operations.\\

\cmdline{-Wbexample}
     \> Generate example implementation code.\\

\cmdline{-Wbinline}
     \> Output stubs for \code{\#include}d IDL files in line with the
        main file.\\

\cmdline{-Wbuse-quotes}
     \> Use quotes in `\code{\#include}' directives 
        (e.g.\ \code{"foo"} rather than \code{<foo>}.)\\

\cmdline{-Wbkeep-inc-path}
     \> Preserve IDL `\code{\#include}' paths in generated
       	`\code{\#include}' directives.\\

\cmdline{-Wbvirtual-objref}
     \> Use virtual functions for object reference operations.\\

\cmdline{-Wbimpl-mapping}
     \> Use the `implementation' mapping for object reference methods.\\

\cmdline{-Wbsplice-modules}
     \> Splice together multiply-opened modules into one.\\

\cmdline{-WbBOA}
     \> Generate BOA compatible skeletons.\\

\cmdline{-Wbold}
     \> Generate old CORBA 2.1 signatures for skeletons.\\

\cmdline{-Wbold-prefix}
     \> Map C++ reserved words with prefix `\code{\_}' rather than
        `\code{\_cxx\_}'.\\

\cmdline{-WbF}
     \> Generate code fragments (only for use during omniORB build).\\

\end{tabbing}


\subsection{Optional code generation options}

By default, omniidl generates the minimum code required to provide all
the IDL-defined types and interfaces, which is sufficient for the
majority of applications. Additional code can also be generated, for
various purposes:


\subsubsection{Any and TypeCode}

To generate TypeCodes and Any insertion operators, give the
\cmdline{-Wba} option. See chapter~\ref{chap:any} for details.

By default, omniidl separates the normal stub and skeleton file (the
\file{SK.cc} file) from these `dynamic' stubs (the \file{DynSK.cc}
file), so applications that do not need support for Any and TypeCode
for a particular IDL file do not waste space with unnecessary
definitions. It is possible to output both the normal stubs and the
dynamic stubs to a single file, by simply specifying the same
extension for both files. This command places both the normal stubs
and the dynamic stubs in \file{aSK.cc}:

\begin{quote}
\cmdline{omniidl -bcxx -Wba -Wbd=SK.cc a.idl}
\end{quote}


\subsubsection{Tie templates}

As described in section~\ref{sec:tie}, tie templates can be used to
provide servant implementations, instead of using inheritance from the
normal skeleton classes. To generate tie templates, give the
\cmdline{-Wbtp} option to omniidl.

When using a pre-namespace C++ compiler, IDL modules are mapped to C++
classes, which causes a problem with tie templates.  The C++ mapping
says that for the interface \intf{M::I}, the C++ tie template class
should be named \type{POA\_M::I\_tie}. However, since template classes
cannot be declared inside other classes, this naming scheme cannot be
used if \type{POA\_M} is a class.

The C++ mapping has an alternative option of `flattened' tie class
names, in which the template class is declared at global scope with
the name \type{POA\_M\_I\_tie}. i.e.\ all occurrences of `\type{::}'
are replaced by `\type{\_}'. Generate the flattened ties using the
\cmdline{-Wbtf} command line argument.


\subsubsection{Asynchronous Method Invocation}

Generate asynchronous invocation operations and the various types
required by AMI by specifying \cmdline{-Wbami}. See
chapter~\ref{chap:ami} for details.


\subsubsection{Example implementations}

If you use the \cmdline{-Wbexample} flag, omniidl will generate an
example implementation file as well as the stubs and skeletons. For
IDL file \file{foo.idl}, the example code is written to
\file{foo_i.cc}. The example file contains class and method
declarations for the operations of all interfaces in the IDL file,
along with a \op{main} function which creates an instance of each
object. You still have to fill in the operation implementations, of
course.


\subsection{Include file options}

IDL files regularly \code{\#include} other files. By default, if file
\file{a.idl} says \code{\#include <b/c.idl>} then the generated
header \file{a.hh} has an include of the form \code{\#include
  <c.idl>}, and \file{aSK.cc} and \file{aDynSK.cc} contain only code
corresponding to the declarations in \file{a.idl}.

If the \cmdline{-Wbinline} option is provided, all the
\code{\#include}d declarations are generated in \file{a.hh},
\file{aSK.cc} and \file{aDynSK.cc}, meaning the application code
should only use that single set of files.

If \cmdline{-Wbuse-quotes} is specified, then the directive in
\file{a.hh} uses quotes rather than angle brackets:
\code{\#include "c.idl"}.

Normally any path details contained in the IDL \code{\#include}
directive are removed, leaving just the base name. If
\cmdline{-Wbkeep-inc-path} is specified, the directive in
\file{a.hh} is \code{\#include <b/c.idl>}.



\subsection{Object reference operations}

Some of the C++ mapping's parameter passing rules are problematic in
terms of memory management. For example, if an IDL operation has a
parameter of type \type{inout string}, the standard mapping has a C++
parameter of type \type{char*\&}. If application code passes a
\type{String\_var} for the parameter, some C++ compilers choose the
wrong conversion operator and cause a violation of the memory
management rules\footnote{For this reason, the \type{\_var} types
  define an \op{inout} method that ensures use of the correct
  conversion and thus avoids this kind of trouble.}.

To avoid this, omniORB uses some helper classes as the parameter types
in object reference operations, meaning that the correct memory
management rules are always followed. Normally, that is invisible to
application code, but occasionally it becomes problematic. One example
is that if a \type{local interface} is derived from a normal
unconstrained interface, the C++ mapping of the local interface
derives from the object reference class, and so the base object
reference class must use the standard mapping rather than omniORB's
usual enhanced mapping. To choose the standard `implementation
mapping', give the \cmdline{-Wbimpl-mapping} option to omniidl.

Similarly, omniidl usually uses non-virtual methods in its object
reference classes, since there is no usual need to override them. The
local interface situation also requires method overrides, so omniidl
must be instructed to generate object references as virtual. Use
\cmdline{-Wbvirtual-objref} to achieve this.

More details about the local interface mapping can be found in
section~\ref{sec:LocalInterfaces}.


\subsection{Module splicing}

On ancient C++ compilers without namespace support, IDL modules map to
C++ classes, and so cannot be reopened. For some IDL, it is possible
to `splice' reopened modules on to the first occurrence of the module,
so all module definitions are in a single class. It is possible in
this sort of situation:

\begin{idllisting}
module M1 {
  interface I {};
};
module M2 {
  interface J {
    attribute M1::I ok;
  };
};
module M1 {
  interface K {
    attribute I still_ok;
  };
};
\end{idllisting}

\noindent but not if there are cross-module dependencies:

\begin{idllisting}
module M1 {
  interface I {};
};
module M2 {
  interface J {
    attribute M1::I ok;
  };
};
module M1 {
  interface K {
    attribute M2::J oh_dear;
  };
};
\end{idllisting}

\noindent In both of these cases, the \cmdline{-Wbsplice-modules}
option causes omniidl to put all of the definitions for module
\intf{M1} into a single C++ class. For the first case, this will work
fine. For the second case, class \type{M1::K} will contain a reference
to \type{M2::J}, which has not yet been defined; the C++ compiler will
complain.


\section{Examples}

Generate the C++ headers and stubs for a file \file{a.idl}:

\begin{quote}
\cmdline{omniidl -bcxx a.idl}
\end{quote}

\noindent Generate with Any support:

\begin{quote}
\cmdline{omniidl -bcxx -Wba a.idl}
\end{quote}

\noindent As above, but also generate Python stubs (assuming omniORBpy
is installed):

\begin{quote}
\cmdline{omniidl -bcxx -Wba -bpython a.idl}
\end{quote}

\noindent Just check the IDL files for validity, generating no output:

\begin{quote}
\cmdline{omniidl a.idl b.idl}
\end{quote}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Connection and Thread Management}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:connections}


This chapter describes how omniORB manages threads and network
connections.

\section{Background}

In CORBA, the ORB is the `middleware' that allows a client to invoke
an operation on an object without regard to its implementation or
location. In order to invoke an operation on an object, a client needs
to `bind' to the object by acquiring its object reference. Such a
reference may be obtained as the result of an operation on another
object (such as a naming service or factory object) or by conversion
from a stringified representation. If the object is in a different
address space, the binding process involves the ORB building a proxy
object in the client's address space. The ORB arranges for invocations
on the proxy object to be transparently mapped to equivalent
invocations on the implementation object.

For the sake of interoperability, CORBA mandates that all ORBs should
support IIOP as the means to communicate remote invocations over a
TCP/IP connection. IIOP is usually\footnote{GIOP 1.2 supports
`bidirectional GIOP', which permits the r\^oles to be reversed.}
asymmetric with respect to the roles of the parties at the two ends of
a connection. At one end is the client which can only initiate remote
invocations. At the other end is the server which can only receive
remote invocations.

Notice that in CORBA, as in most distributed systems, remote bindings
are established implicitly without application intervention. This
provides the illusion that all objects are local, a property known as
`location transparency'. CORBA does not specify when such bindings
should be established or how they should be multiplexed over the
underlying network connections. Instead, ORBs are free to implement
implicit binding by a variety of means.

The rest of this chapter describes how omniORB manages network
connections and the programming interface to fine tune the management
policy.


\section{The model}

omniORB is designed from the ground up to be fully multi-threaded. The
objective is to maximise the degree of concurrency and at the same
time eliminate any unnecessary thread overhead. Another objective is
to minimise the interference by the activities of other threads on the
progress of a remote invocation. In other words, thread `cross-talk'
should be minimised within the ORB. To achieve these objectives, the
degree of multiplexing at every level is kept to a minimum by default.

Minimising multiplexing works well when the system is relatively
lightly loaded. However, when the ORB is under heavy load, it can
sometimes be beneficial to conserve operating system resources such as
threads and network connections by multiplexing at the ORB
level. omniORB has various options that control its multiplexing
behaviour.


\section{Client side behaviour}

On the client side of a connection, the thread that invokes on a proxy
object drives the GIOP protocol directly and blocks on the connection
to receive the reply. The first time the client makes a call to a
particular address space, the ORB opens a suitable connection to the
remote address space (based on the client transport rule as described
in section~\ref{sec:clientRule}). After the reply has been received,
the ORB caches the open network connection, ready for use by another
call.

If two (or more) threads in a multi-threaded client attempt to contact
the same address space simultaneously, there are two different ways to
proceed. The default way is to open another network connection to the
server. This means that neither the client or server ORB has to
perform any multiplexing on the network connections---multiplexing is
performed by the operating system, which has to deal with multiplexing
anyway. The second possibility is for the client to multiplex the
concurrent requests on a single network connection. This conserves
operating system resources (network connections), but means that both
the client and server have to deal with multiplexing issues
themselves.

In the default one call per connection mode, there is a limit to the
number of concurrent connections that are opened, set with the
\code{maxGIOPConnection\dsc{}PerServer} parameter. To tell the ORB
that it may multiplex calls on a single connection, set the
\code{oneCallPerConnection} parameter to zero. If the
\code{oneCallPer\dsc{}Connection} parameter is set to the default
value of one, and there are more concurrent calls than specified by
\code{maxGIOPConnectionPerServer}, calls block waiting for connections
to become free.

Note that some server-side ORBs, including omniORB versions before
version 4.0, are unable to deal with concurrent calls multiplexed on a
single connection, so they serialise the calls. It is usually best to
keep to the default mode of opening multiple connections.


\subsection{Client side timeouts}
\label{sec:timeoutAPI}

omniORB can associate a timeout with a call, meaning that if the call
takes too long a \code{CORBA::TIMEOUT} exception\footnote{Or
  \code{CORBA::TRANSIENT} if the backwards-compatibility
  \code{throwTransientOnTimeout} parameter is set to \code{1}.} is
thrown. Timeouts can be set for the whole process, for a specific
thread, or for a specific object reference.

Timeouts are set using this API:

\begin{cxxlisting}
namespace omniORB {
  void setClientCallTimeout(CORBA::ULong millisecs);
  void setClientCallTimeout(CORBA::Object_ptr obj, CORBA::ULong millisecs);
  void setClientThreadCallTimeout(CORBA::ULong millisecs);
  void setClientConnectTimeout(CORBA::ULong millisecs);
};
\end{cxxlisting}

\op{setClientCallTimeout} sets either the global timeout or the
timeout for a specific object reference.
\op{setClientThreadCallTimeout} sets the timeout for the calling
thread. The calling thread must have an \code{omni\_thread} associated
with it. Setting any timeout value to zero disables it.

Accessing per-thread state is a relatively expensive operation, so per
thread timeouts are disabled by default. The
\code{supportPerThreadTimeOut} parameter must be set \code{true} to
enable them.

To choose the timeout value to use for a call, the ORB first looks to
see if there is a timeout for the object reference, then to the
calling thread, and finally to the global timeout.

When a client has no existing connection to communicate with a server,
it must open a new connection before performing the
call. \op{setClientConnect\dsc{}Timeout} sets an overriding timeout for
cases where a new connection must be established. The effect of the
connect timeout depends upon whether the connect timeout is greater
or less than the timeout that would otherwise be used.

\vspace{\baselineskip}\noindent
As an example, imagine that the usual call timeout is 10 seconds:

\subsubsection*{Connect timeout > usual timeout}

If the connect timeout is set to 20 seconds, then a call that
establishes a new connection will be permitted 20 seconds before it
times out. Subsequent calls using the same connection have the normal
10 second timeout. If establishing the connection takes 8 seconds,
then the call itself takes 5 seconds, the call succeeds despite having
taken 13 seconds in total, longer than the usual timeout.

This kind of configuration is good when connections are slow to be
established.

If an object reference has multiple possible endpoints available, and
connecting to the first endpoint times out, only that one endpoint
will have been tried before an exception is raised. However, once the
timeout has occurred, the object reference will switch to use the next
endpoint. If the application attempts to make another call, it will
use the next endpoint.


\subsubsection*{Connect timeout < usual timeout}

If the connect timeout is set to 2 seconds, the actual network-level
connect is only permitted to take 2 seconds. As long as the connection
is established in less than 2 seconds, the call can proceed. The 10
second call timeout still applies to the time taken for the whole call
(including the connection establishment). So, if establishing the
connection takes 1.5 seconds, and the call itself takes 9.5 seconds,
the call will time out because although it met the connection timeout,
it exceeded the 10 second total call timeout. On the other hand, if
establishing the connection takes 3 seconds, the call will fail after
only 2 seconds, since only 2 seconds are permitted for the connect.

If an object reference has multiple possible endpoints available, the
client will attempt to connect to them in turn, until one succeeds.
The connect timeout applies to each connection attempt. So with a
connect timeout of 2 seconds, the client will spend up to 2 seconds
attempting to connect to the first address and then, if that fails, up
to 2 seconds trying the second address, and so on. The 10 second
timeout still applies to the call as a whole, so if the total time
taken on timed-out connection attempts exceeds 10 seconds, the call
will time out.

This kind of configuration is useful where calls may take a long time
to complete (so call timeouts are long), but a fast indication of
connection failure is required.


\section{Server side behaviour}

The server side has two primary modes of operation: thread per
connection and thread pooling. It is able to dynamically transition
between the two modes, and it supports a hybrid scheme that behaves
mostly like thread pooling, but has the same fast turn-around for
sequences of calls as thread per connection.

\subsection{Thread per connection mode}

In thread per connection mode (the default, and the only option in
omniORB versions before 4.0), each connection has a single thread
dedicated to it. The thread blocks waiting for a request. When it
receives one, it unmarshals the arguments, makes the up-call to the
application code, marshals the reply, and goes back to watching the
connection. There is thus no thread switching along the call chain,
meaning the call is very efficient.

As explained above, a client can choose to multiplex multiple
concurrent calls on a single connection, so once the server has
received the request, and just before it makes the call into
application code, it marks the connection as `selectable', meaning
that another thread should watch it to see if any other requests
arrive. If they do, extra threads are dispatched to handle the
concurrent calls. GIOP 1.2 actually allows the argument data for
multiple calls to be interleaved on a connection, so the unmarshalling
code has to handle that too. As soon as any multiplexing occurs on the
connection, the aim of removing thread switching cannot be met, and
there is inevitable inefficiency due to thread switching.

The \code{maxServerThreadPerConnection} parameter can be set to limit
the number of threads that can be allocated to a single connection
containing concurrent calls. Setting the parameter to 1 mimics the
behaviour of omniORB versions before 4.0, that did not support
calls multiplexed on one connection.


\subsection{Thread pool mode}
\label{sec:watchConn}

In thread pool mode, selected by setting the
\code{threadPerConnectionPolicy} parameter to zero, a single thread
watches all incoming connections. When a call arrives on one of them,
a thread is chosen from a pool of threads, and set to work
unmarshalling the arguments and performing the up-call. There is
therefore at least one thread switch for each call.

The thread pool is not pre-initialised. Instead, threads are started
on demand, and idle threads are stopped after a period of inactivity.
The maximum number of threads that can be started in the pool is set
with the \code{maxServer\dsc{}ThreadPoolSize} parameter. The default
is 100.

A common pattern in CORBA applications is for a client to make several
calls to a single object in quick succession. To handle this situation
most efficiently, the default behaviour is to not return a thread to
the pool immediately after a call is finished. Instead, it is set to
watch the connection it has just served for a short while, mimicking
the behaviour in thread per connection mode. If a new call comes in
during the watching period, the call is dispatched without any thread
switching, just as in thread per connection mode. Of course, if the
server is supporting a very large number of connections (more than the
size of the thread pool), this policy can delay a call coming from
another connection. If the \code{threadPoolWatch\dsc{}Connection}
parameter is set to zero, connection watching is disabled and threads
return to the pool immediately after finishing a single request.

In the face of multiplexed calls on a single connection, multiple
threads from the pool can be dispatched for one connection, just as in
thread per connection mode. With \code{threadPoolWatchConnection} set
to the default value of 1, only the last thread servicing a connection
will watch it when it finishes a request. Setting the parameter to a
larger number allows the last \emph{n} connections to watch the
connection.


\subsection{Policy transition}

If the server is dealing with a relatively small number of
connections, it is most efficient to use thread per connection mode.
If the number of connections becomes too large, however, operating
system limits on the number of threads may cause a significant
slowdown, or even prevent the acceptance of new connections
altogether.

To give the most efficient response in all circumstances, omniORB
allows a server to start in thread per connection mode, and transition
to thread pooling if many connections arrive. This is controlled with
the \code{threadPerConnection\dsc{}UpperLimit} and
\code{threadPerConnectionLowerLimit} parameters. The upper limit must
always be larger than the lower limit. The upper limit chooses the
number of connections at which time the ORB transitions to thread pool
mode; the lower limit selects the point at which the transition back
to thread per connection is made.

For example, setting the upper limit to 50 and the lower limit to 30
would mean that the first 49 connections would receive dedicated
threads. The 50th to arrive would trigger thread pooling. All future
connections to arrive would make use of threads from the pool. Note
that the existing dedicated threads continue to service their
connections until the connections are closed. If the number of
connections falls below 30, thread per connection is reactivated and
new connections receive their own dedicated threads (up to the limit
of 50 again). Once again, existing connections in thread pool mode
stay in that mode until they are closed.


\section{Idle connection shutdown}
\label{sec:connShutdown}

It is wasteful to leave a connection open when it has been left unused
for a considerable time. Too many idle connections could block out new
connections when the system runs out of spare communication channels.
For example, most platforms have a limit on the number of file handles
a process can open. Many platforms have a very small default limit
like 64. The value can often be increased to a maximum of a thousand
or more by changing the `ulimit' in the shell.

Every so often, a thread scans all open connections to see which are
idle. The scanning period (in seconds) is set with the
\code{scanGranularity} parameter. The default is 5 seconds.

Outgoing connections (initiated by clients) and incoming connections
(initiated by servers) have separate idle timeouts.  The timeouts are
set with the \code{outConScan\dsc{}Period} and \code{inConScanPeriod}
parameters respectively. The values are in seconds, and must be a
multiple of the scan granularity.

Beware that setting \code{outConScanPeriod} or \code{inConScanPeriod}
to be equal to (or less than) \code{scanGranularity} means that
connections are considered candidates for closure immediately after
they are opened. That can mean that the connections are closed before
any calls have been sent through them. If oneway calls are used, such
connection closure can result in silent loss of calls.


\subsection{Interoperability Considerations}

The IIOP specification allows both the client and the server to
shutdown a connection unilaterally. When one end is about to shutdown
a connection, it should send a \code{CloseConnection} message to the
other end. It should also make sure that the message will reach the
other end before it proceeds to shutdown the connection.

The client should distinguish between an orderly and an abnormal
connection shutdown. When a client receives a \code{CloseConnection}
message before the connection is closed, the condition is an orderly
shutdown.  If the message is not received, the condition is an
abnormal shutdown.  In an abnormal shutdown, the ORB should raise a
\code{COMM\_FAILURE} exception whereas in an orderly shutdown, the ORB
should \emph{not} raise an exception and should try to re-establish a
new connection transparently.

omniORB implements these semantics completely. However, it is known
that some ORBs are not (yet) able to distinguish between an orderly
and an abnormal shutdown. Usually this is manifested as the client in
these ORBs seeing a \code{COMM\_FAILURE} occasionally when connected
to an omniORB server. The work-around is either to catch the exception
in the application code and retry, or to turn off the idle connection
shutdown inside the omniORB server.



\section{Transports and endpoints}
\label{sec:endpoints}

omniORB can support multiple network transports. All platforms
(usually) have a TCP transport available. Unix platforms support a
Unix domain socket transport. Platforms with the OpenSSL library
available can support an SSL transport.

Servers must be configured in two ways with regard to transports: the
transports and interfaces on which they listen, and the details that
are published in IORs for clients to see. Usually the published
details will be the same as the listening details, but there are times
when it is useful to publish different information.

Details are selected with the \code{endPoint} family of parameters.
The simplest is plain \code{endPoint}, which chooses a transport and
interface details, and publishes the information in IORs. Endpoint
parameters are in the form of URIs, with a scheme name of
`\code{giop:}', followed by the transport name. Different transports
have different parameters following the transport.

TCP endpoints have the format:

\begin{quote}
\code{giop:tcp:}\textit{<host>}\code{:}\textit{<port>}
\end{quote}

\noindent The host must be a valid host name or IP address for the
server machine.  It determines the network interface on which the
server listens. The port selects the TCP port to listen on, which must
be unoccupied.  Either the host or port, or both can be left empty. If
the host is empty, the ORB publishes the IP address of the first
non-loopback network interface it can find (or the loopback if that is
the only interface), but listens on \emph{all} network interfaces. If
the port is empty, the operating system chooses an \term{ephemeral}
port.

Multiple TCP endpoints can be selected, either to specify multiple
network interfaces on which to listen, or (less usefully) to select
multiple TCP ports on which to listen.

If no \code{endPoint} parameters are set, the ORB assumes a single
parameter of \code{giop:tcp::}, meaning IORs contain the address of
the first non-loopback network interface, the ORB listens on all
interfaces, and the OS chooses a port number.

SSL endpoints have the same format as TCP ones, except `\code{tcp}'
is replaced with `\code{ssl}'. Unix domain socket endpoints have the
format:

\begin{quote}
\code{giop:unix:}\textit{<filename>}
\end{quote}

\noindent where the filename is the name of the socket within the
filesystem. If the filename is left blank, the ORB chooses a name
based on the process id and a timestamp.

To listen on an endpoint without publishing it in IORs, specify it
with the \code{endPointNoPublish} configuration parameter. See below
for more details about endpoint publishing.


\subsection{Port ranges}

Sometimes it is useful to restrict a server to listen on one of a
range of ports, rather than pinning it to one particular port or
allowing the OS to choose an ephemeral port. omniORB 4.2 introduces
the ability to specify a range of ports using a hyphen. e.g.\ to
listen on a port between 5000 and 5010 inclusive:

\begin{quote}
\code{giop:tcp::5000-5010}
\end{quote}

omniORB randomly chooses a port in the range. If it finds that the
chosen port is already occupied, it keeps trying different ports until
it finds a free one. If all the ports in the range are occupied, it
throws \code{CORBA::INITIALIZE}.


\subsection{IPv6}

On platforms where it is available, omniORB supports IPv6. On most
Unix platforms, IPv6 sockets accept both IPv6 and IPv4 connections, so
omniORB's default \code{giop:tcp::} endpoint accepts both IPv4 and
IPv6 connections. On Windows versions before Windows Vista, each
socket type only accepts incoming connections of the same type, so an
IPv6 socket cannot be used with IPv4 clients. For this reason, the
default \code{giop:tcp::} endpoint only listens for IPv4 connections.
Since endpoints with a specific host name or address only listen on a
single network interface, they are inherently limited to just one
protocol family.

To explicitly ask for just IPv4 or just IPv6, an endpoint with the
wildcard address for the protocol family should be used. For IPv4, the
wildcard address is `\code{0.0.0.0}', and for IPv6 it is `\code{::}'.
So, to listen for IPv4 connections on all IPv4 network interfaces, use
an endpoint of:

\begin{quote}
\code{giop:tcp:0.0.0.0:}
\end{quote}

\noindent All IPv6 addresses contain colons, so the address portion in
URIs must be contained within \code{[]} characters. Therefore, to
listen just for IPv6 connections on all IPv6 interfaces, use the
somewhat cryptic:

\begin{quote}
\code{giop:tcp:[::]:}
\end{quote}

\noindent To listen for both IPv4 and IPv6 connections on Windows
versions prior to Vista, both endpoints must be explicitly provided.

\subsubsection{Link local addresses}

In IPv6, all network interfaces are assigned a \term{link local}
address, starting with the digits \code{fe80}. The link local address
is only valid on the same `link' as the interface, meaning directly
connected to the interface, or possibly on the same subnet, depending
on how the network is switched. To connect to a server's link local
address, a client has to know which of its network interfaces is on
the same link as the server. Since there is no way for omniORB to know
which local interface a remote link local address may be connected to,
and in extreme circumstances may even end up contacting the wrong
server if it picks the wrong interface, link local addresses are not
considered valid. Servers do not publish link local addresses in their
IORs.


\subsection{Endpoint publishing}

For clients to be able to connect to a server, the server publishes
endpoint information in its IORs (Interoperable Object References).
Normally, omniORB publishes the first available address for each of
the endpoints it is listening on.

The endpoint information to publish is determined by the
\code{endPointPublish} configuration parameter. It contains a
comma-separated list of publish rules. The rules are applied in turn
to each of the configured endpoints; if a rule matches an endpoint, it
causes one or more endpoints to be published.

The following core rules are supported:

\vspace{\baselineskip}

\begin{tabular}{p{.25\textwidth}p{.75\textwidth}}
\code{addr} &     the first natural address of the endpoint\\
\code{ipv4} &     the first IPv4 address of a TCP or SSL endpoint\\
\code{ipv6} &     the first IPv6 address of a TCP or SSL endpoint\\
\code{name} &     the first address that can be resolved to a name\\
\code{hostname} & the result of the gethostname() system call\\
\code{fqdn} &     the fully-qualified domain name\\
\end{tabular}

\vspace{\baselineskip}

\noindent
The core rules can be combined using the vertical bar operator to
try several rules in turn until one succeeds. e.g:

\vspace{\baselineskip}

\begin{tabular}{p{.25\textwidth}p{.65\textwidth}}
\code{name|ipv6|ipv4} & the name of the endpoint if it has one;
                 	failing that, its first IPv6 address;
                 	failing that, its first IPv4 address.
\end{tabular}

\vspace{\baselineskip}

\noindent
Multiple rules can be combined using the comma operator to
publish more than one endpoint. e.g.

\vspace{\baselineskip}

\begin{tabular}{p{.25\textwidth}p{.65\textwidth}}
\code{name,addr} & the name of the endpoint (if it has one),
                   followed by its first address.
\end{tabular}

\vspace{\baselineskip}

\noindent
For endpoints with multiple addresses (e.g. TCP endpoints on
multi-homed machines), the \code{all()} manipulator causes all
addresses to be published. e.g.:

\vspace{\baselineskip}

\begin{tabular}{p{.3\textwidth}p{.7\textwidth}}
\code{all(addr)} & all addresses are published\\
\code{all(name)} & all addresses that resolve to names are published\\
\code{all(name|addr)} & all addresses are published by name if they have
                        one, address otherwise.\\
\code{all(name,addr)} & all addresses are published by name (if they
                        have one), and by address.\\
\code{all(name), all(addr)} & first the names of all addresses are published,
                             followed by all the addresses.\\
\end{tabular}

\vspace{\baselineskip}

\noindent
A specific endpoint can be published by giving its endpoint URI,
even if the server is not listening on that endpoint. e.g.:

\vspace{\baselineskip}

\begin{tabular}{p{.25\textwidth}p{.65\textwidth}}
\code{giop:tcp:not.my.host:12345}\\
\code{giop:unix:/not/my/socket-file}\\
\end{tabular}

\vspace{\baselineskip}

\noindent
If the host or port number for a TCP or SSL URI are missed out,
they are filled in with the details from each listening TCP/SSL
endpoint. This can be used to publish a different name for a
TCP/SSL endpoint that is using an ephemeral port, for example.

omniORB 4.0 supported two options related to endpoint publishing that
are superseded by the \code{endPointPublish} parameter, and so are now
deprecated. Setting \code{endPointPublishAllIFs} to 1 is equivalent to
setting \code{endPointPublish} to `\code{all(addr)}'. The
\code{endPointNoListen} parameter is equivalent to adding endpoint
URIs to the \code{endPointPublish} parameter.



\section{Connection selection and acceptance}

In the face of IORs containing details about multiple different
endpoints, clients have to know how to choose the one to use to
connect a server. Similarly, servers may wish to restrict which
clients can connect to particular transports. This is achieved with
\term{transport rules}.


\subsection{Client transport rules}
\label{sec:clientRule}

The \code{clientTransportRule} parameter is used to filter and
prioritise the order in which transports specified in an IOR are
tried. Each rule has the form:

\begin{quote}
\textit{<address mask> [action]+}
\end{quote}

\noindent The address mask can be one of

\vspace{\baselineskip}

\begin{tabular}{llp{.5\textwidth}}
1. & \code{localhost} & The address of this machine\\

2. & \textit{w.x.y.z}\code{/}\textit{m1.m2.m3.m4} & An IPv4 address
     with bits selected by the mask, e.g.\
     \code{172.16.0.0/255.240.0.0}\\

3. & \textit{w.x.y.z}\code{/}\textit{prefixlen} & An IPv4 address with
     \textit{prefixlen} significant bits, e.g.\
     \code{172.16.2.0/24}\\

4. & \textit{a:b:c:d:e:f:g:h}\code{/}\textit{prefixlen} & An IPv6
     address with \textit{prefixlen} significant bits, e.g.\
     \code{3ffe:505:2:1::/64}\\

5. & \code{*} & Wildcard that matches any address\\
\end{tabular}

\vspace{\baselineskip}

\noindent The action is one or more of the following:

\vspace{\baselineskip}

\begin{tabular}{llp{.5\textwidth}}
1. & \code{none} & Do not use this address\\
2. & \code{tcp}  & Use a TCP transport\\
3. & \code{ssl}  & Use an SSL transport\\
4. & \code{unix} & Use a Unix socket transport\\
5. & \code{bidir}& Connections to this address can be used
                   bidirectionally (see section~\ref{sec:bidir})\\
\end{tabular}

\vspace{\baselineskip}

\noindent The transport-selecting actions form a prioritised list, so
an action of `\code{unix,ssl,\dsc{}tcp}' means to use a Unix transport if
there is one, failing that a SSL transport, failing \emph{that} a TCP
transport. In the absence of any explicit rules, the client uses the
implicit rule of `\code{* unix,ssl,tcp}'.

If more than one rule is specified, they are prioritised in the order
they are specified. For example, the configuration file might contain:

\begin{verbatim}
  clientTransportRule = 192.168.1.0/255.255.255.0  unix,tcp
  clientTransportRule = 172.16.0.0/255.240.0.0     unix,tcp
                      =       *                    none
\end{verbatim}

\noindent This would be useful if there is a fast network
(192.168.1.0) which should be used in preference to another network
(172.16.0.0), and connections to other networks are not permitted at
all.

In general, the result of filtering the endpoint specifications in an
IOR with the client transport rule will be a prioritised list of
transports and networks. (If the transport rules do not prioritise one
endpoint over another, the order the endpoints are listed in the IOR
is used.)  When trying to contact an object, the ORB tries its
possible endpoints in turn, until it finds one with which it can
contact the object. Only after it has unsuccessfully tried all
permissible endpoints will it raise a \code{TRANSIENT} exception to
indicate that the connect failed.



\subsection{Server transport rules}
\label{sec:serverRule}

Server transport rules have the same format as client transport
rules. Rather than being used to select which of a set of ways to
contact a machine, they are used to determine whether or not to accept
connections from particular clients. In this example, we only allow
connections from our intranet:

\begin{verbatim}
  serverTransportRule = localhost                  unix,tcp,ssl
                      = 172.16.0.0/255.240.0.0     tcp,ssl
                      = *                          none
\end{verbatim}

\noindent And in this one, we accept only SSL connections if the
client is not on the intranet:

\begin{verbatim}
  serverTransportRule = localhost                  unix,tcp,ssl
                      = 172.16.0.0/255.240.0.0     tcp,ssl
                      = *                          ssl,bidir
\end{verbatim}

\noindent In the absence of any explicit rules, the server uses the
implicit rule of `\code{* unix,\dsc{}ssl,tcp}', meaning any kind of
connection is accepted from any client.


\section{Bidirectional GIOP}
\label{sec:bidir}

omniORB supports bidirectional GIOP, which allows callbacks to be made
using a connection opened by the original client, rather than the
normal model where the server opens a new connection for the callback.
This is important for negotiating firewalls, since they tend not to
allow connections back on arbitrary ports.

There are several steps required for bidirectional GIOP to be enabled
for a callback. Both the client and server must be configured
correctly. On the client side, these conditions must be met:

\begin{itemize}

\item The \code{offerBiDirectionalGIOP} parameter must be set to \code{true}. 
\item The client transport rule for the target server must contain the
      \code{bidir} action.
\item The POA containing the callback object (or objects) must have
      been created with a \code{BidirectionalPolicy} value of
      \code{BOTH}.

\end{itemize}

\noindent On the server side, these conditions must be met:

\begin{itemize}

\item The \code{acceptBiDirectionalGIOP} parameter must be set to \code{true}. 
\item The server transport rule for the requesting client must contain
      the \code{bidir} action.
\item The POA hosting the object contacted by the client must have
      been created with a \code{BidirectionalPolicy} value of
      \code{BOTH}.

\end{itemize}


\section{TLS / SSL transport}

omniORB supports a TLS / SSL transport, using OpenSSL. It is only
built if OpenSSL is available. On platforms using Autoconf, it is
autodetected in many locations, or its location can be given with the
\code{-{}-with-openssl=} argument to \code{configure}. On other
platforms, the \code{OPEN\_SSL\_ROOT} make variable must be set in the
platform file.

To use the SSL transport, you must link your application with the
\file{omnisslTP} library, and correctly set up certificates. See the
\file{src/examples/ssl_echo} directory for an example. That directory
contains a \file{README} file with more details.

\subsection{Self-signed certificate authority}

By default, omniORB configures OpenSSL to require both clients and
servers to have certificates that are signed by a Certificate
Authority (CA). It is possible to use a public CA to obtain keys that
can be independently verified, but for many purposes, it is sufficient
to use a private CA to sign all the keys in use in an application. The
following is a brief description of how to become your own certificate
authority and issue and sign certificates, using the OpenSSL command
line tools.

Before starting, find the default \file{openssl.cnf} file that was
installed with OpenSSL, copy it to a suitable location, and edit it as
you feel appropriate. Now, build a certificate directory structure,
authority key and certificate:

\begin{verbatim}
  mkdir demoCA demoCA/private demoCA/newcerts

  openssl req -config openssl.cnf -x509 -newkey rsa:2048 \
     -keyout demoCA/private/cakey.pem -out demoCA/cacert.pem -days 3650

  echo 01 >demoCA/serial
  touch demoCA/index.txt
\end{verbatim}

\noindent Next, issue a key request and sign it:

\begin{verbatim}
  openssl req -config openssl.cnf -new -keyout server_key.pem \
     -out server_req.pem -days 3650

  openssl ca -config openssl.cnf -policy policy_anything \
     -out server_cert.pem -in server_req.pem 
\end{verbatim}

\noindent Amongst other things, you now have a server key file in
\file{server_key.pem} and a certificate in \file{server_cert.pem}. To
make a single file containing both the key and the certificate,
suitable for use in omniORB, concatenate the key and certificate files
together.  You can skip the human-readable(ish) text in the
certificate file before the \verb|-----BEGIN CERTIFICATE-----| marker.

If need be, create more certificates for servers and clients in the
same way.


\section{ZIOP}

omniORB has support for ZIOP, which compresses transmitted
messages. To use it, link with the \code{omniZIOP4} library.

On Unix platforms, ZIOP support is automatically enabled if the
configure script detects zlib. To enable it on Windows, set the
\code{EnableZIOP} make variable in the platform configuration file.

omniORB has an almost complete implementation of the ZIOP
specification, with the following extensions and differences:

\begin{enumerate}
\item To avoid a dependency on \code{CORBA::Any}, compression policies
  can be obtained with functions in the \code{omniZIOP} namespace,
  rather than with the standard \op{orb->create\_policy}. See
  \file{include/omniORB4/omniZIOP.h} for details. To use \code{Any}
  with the standard \op{orb->create\_policy}, link with the
  \code{omniZIOPDynamic4} library in addition to \code{omniZIOP4}.

\item Client-side policies are global, set with
  \op{omniZIOP::setGlobalPolicies}.
  \op{CORBA::Object::\_set\_policy\_overrides} is not supported.

\item POAs can be given ZIOP policies as shown in the
  \file{src/examples/ziop/ziop_impl.cc}, but they can also use the
  global policies set with \op{omniZIOP::\dsc{}setGlobalPolicies}.  This
  is useful to apply ZIOP policies to the RootPOA or omniINSPOA.
\end{enumerate}

\noindent In addition to the standard policies, whether or not to
enable ZIOP is determined by client and server transport rules. For a
client to use ZIOP, the matching client transport rule must include
`\code{ziop}'; similarly, for a server to use ZIOP, the matching
server transport rule must include `\code{ziop}'. e.g.\ to use the
examples:

\begin{verbatim}
  ziop_impl -ORBserverTransportRule "* unix,ssl,tcp,ziop"

  ziop_clt -ORBclientTransportRule "* unix,ssl,tcp,ziop" IOR:...
\end{verbatim}

\noindent This allows you to enable ZIOP for WAN links, but disable it
for LAN communication, for example.


\subsection{Forcing ZIOP Policies}

The fact that a server supports ZIOP is encoded in its IORs. This
means that if a client uses a \corbauri{corbaloc} URI to reference an
object, the object reference does not contain ZIOP details, and thus
the communication cannot use ZIOP. If a client is absolutely certain
that a server supports ZIOP, it can extend an object reference with
ZIOP details using \op{omniZIOP::setServerPolicies}. Using the new
object reference, the client will be able to make ZIOP calls.

\begin{cxxlisting}
namespace omniZIOP {
  CORBA::Object_ptr
  setServerPolicies(CORBA::Object_ptr obj, const CORBA::PolicyList& policies);
};
\end{cxxlisting}

Creating a ZIOP-enabling object reference in this way is dangerous!
If the server does not actually support ZIOP, it will receive
compressed messages that it cannot handle. A well-behaved server will
throw a \code{CORBA::MARSHAL} exception in response, or perhaps just
drop the invalid connection.



\section{Connection Management Extension}

The \code{omniConnectionMgmt} library provides an omniORB-specific
extension for application-level connection management. Its purpose is
to allow clients and servers to negotiate private GIOP connections,
and to control how the connections are used in multi-threaded
situations.

The \code{omniConnectionMgmt} library has two functions, defined in
\file{include/omniORB4/omniConnectionMgmt.h}:

\begin{cxxlisting}
namespace omniConnectionMgmt {

  void init();

  CORBA::Object_ptr
  makeRestrictedReference(CORBA::Object_ptr obj,
			  CORBA::ULong      connection_id,
			  CORBA::ULong      max_connections,
			  CORBA::ULong      max_threads,
			  CORBA::Boolean    data_batch,
			  CORBA::Boolean    permit_interleaved,
			  CORBA::Boolean    server_hold_open);
};
\end{cxxlisting}

\noindent The \op{init} function must be called before
\op{CORBA::ORB\_init} in every process that is to take part in the
connection management.

The \op{makeRestrictedReference} function is the single entry-point to
the connection management functionality. It builds an annotated object
reference that contains information for the connection management
system. It returns a new reference, leaving the original object
reference unchanged.

\subsection{Client-side parameters}

These parameters affect the client side of a connection:

\confoptnd{connection\_id}

This number identifies the private connection set. All object
references with the same \code{connection\_id} will share the same set
of GIOP connections. Object references with different connection ids
are guaranteed to use different connections from each other, and from
object references that have not been annotated with
\op{makeRestrictedReference}.

\confoptnd{max\_connections}

This parameter overrides the omniORB \code{maxGIOPConnectionPerServer}
configuration parameter for the given \code{connection\_id}. It
determines the maximum number of separate GIOP connections that will
be opened to the object's server to service concurrent calls. It is
common to set this value to 1, indicating that only one connection
will be used for the given \code{connection\_id}. Note that this
parameter can only be used to reduce the default
\code{maxGIOPConnectionPerServer} value, not increase it.

\confoptnd{data\_batch}

omniORB usually configures its TCP connections to disable Nagle's
algorithm, which batches small messages together into single IP
packages, since that is best for the usual CORBA usage pattern of
two-way requests. Setting this parameter to true overrides that, and
enables Nagle's algorithm on TCP connections or equivalent
functionality on other transports. This can increase throughput if a
client is sending a large number of small oneway calls.

\confoptnd{permit\_interleaved}

This parameter overrides the \code{oneCallPerConnection} configuration
parameter that determines whether multi-threaded clients can
interleave calls on a single connection, issuing a new request message
while a previous request is still waiting for a reply. If
\code{permit\_interleaved} is true, clients can interleave messages;
if it is false, they cannot.


\subsection{Server-side parameters}

These parameters affect the client side of a connection:

\confoptnd{max\_threads}

This parameter overrides the global
\code{maxServerThreadPerConnection} configuration parameter that
determines the maximum number of concurrent threads the server will
use to service requests coming from a connection. Note that this
parameter is only relevant if either the client permits interleaved
calls, or if oneway operations are used, since those are the only
circumstances under which the server can receive a new request on a
connection while already handling a request. As with the
\code{max\_connections} client-side parameter, this parameter can only
reduce the default number of threads, not increase it.

\confoptnd{server\_hold\_open}

Normally, both clients and servers can decide to close a GIOP
connection at any time. When using normal two-way calls, this is no
problem since if a server closes a connection, the client is
guaranteed to notice it when it waits for a reply, and can retry the
call if necessary. With oneway calls, however, if a server closes a
connection just as the client is sending a request, the client will
not know whether the oneway call was received or not, and the call
will potentially be lost. By setting the \code{server\_hold\_open}
parameter to true, the server will not close the connection, relying
on the client to do so. In that case, oneway calls will not be lost
unless there is a network problem that breaks the GIOP connection.


\subsection{Usage}

The omniConnectionMgmt extension is very easy to use---simply call the
\op{init} method in all processes involved, then restrict references
as required. The \op{makeRestrictedReference} function adds profile
information to the object reference's IOR, meaning that the parameters
become part of the object reference and are transmitted along with
it. In other words, a server can create a restricted reference and
send it to a client, and the client will automatically make use of the
restricted parameters when it invokes operations on the object
reference. Alternatively, a client can restrict a normal reference it
receives, in order to change its own behaviour.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Interoperable Naming Service}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:ins}

omniORB supports the Interoperable Naming Service (INS). The following
is a summary of its facilities.


\section{Object URIs}

As well as accepting IOR-format strings, \op{ORB::string\_to\_object}
also supports two Uniform Resource Identifier (URI)~\cite{rfc2396}
formats, which can be used to specify objects in a convenient
human-readable form. IOR-format strings are now also considered URIs.

\subsection{corbaloc}

\corbauri{corbaloc} URIs allow you to specify object references which
can be contacted by IIOP, or found through
\op{ORB::resolve\_initial\_references}. To specify an IIOP object
reference, you use a URI of the form:

\begin{quote}
\corbauri{corbaloc:iiop:}<\textit{host}>\corbauri{:}<\textit{port}>%
\corbauri{/}<\textit{object key}>
\end{quote}

\noindent for example:

\begin{quote}
\corbauri{corbaloc:iiop:myhost.example.com:1234/MyObjectKey}
\end{quote}

\noindent which specifies an object with key `MyObjectKey' within a
process running on myhost.example.com listening on port 1234. Object
keys containing non-ASCII characters can use the standard URI \%
escapes:

\begin{quote}
\corbauri{corbaloc:iiop:myhost.example.com:1234/My}%
\texttt{\%}%
\corbauri{efObjectKey}
\end{quote}

\noindent denotes an object key with the value 239 (hex ef) in the
third octet.

The protocol name `\corbauri{iiop}' can be abbreviated to the empty
string, so the original URI can be written:

\begin{quote}
\corbauri{corbaloc::myhost.example.com:1234/MyObjectKey}
\end{quote}

\noindent The IANA has assigned port number 2809\footnote{Not 2089 as
printed in \cite{inschapters}!} for use by \corbauri{corbaloc}, so if
the server is listening on that port, you can leave the port number
out.  The following two URIs refer to the same object:

\begin{quote}
\corbauri{corbaloc::myhost.example.com:2809/MyObjectKey}\\
\corbauri{corbaloc::myhost.example.com/MyObjectKey}
\end{quote}

\noindent You can specify an object which is available at more than
one location by separating the locations with commas:

\begin{quote}
\corbauri{corbaloc::myhost.example.com,:localhost:1234/MyObjectKey}
\end{quote}

\noindent Note that you must restate the protocol for each address,
hence the `\corbauri{:}' before `\corbauri{localhost}'. It could
equally have been written `\corbauri{iiop:localhost}'.

You can also specify an IIOP version number:

\begin{quote}
\corbauri{corbaloc::1.2@myhost.example.com/MyObjectKey}
\end{quote}

\noindent Specifying IIOP versions above 1.0 is slightly risky since
higher versions make use of various information stored in IORs that is
not present in a corbaloc URI. It is generally best to contact initial
corbaloc objects with IIOP 1.0, and rely on higher versions for all
other object references.



\subsection{Other transports}

The only transport specified in the CORBA standard is \corbauri{iiop},
but omniORB also supports the following extensions:

\begin{description}

\item[\corbauri{ssliop}]\mbox{}\\
Equivalent semantics to \corbauri{iiop}, but the server is contacted
using SSL / TLS. As with \corbauri{iiop}, the address details are of
the form \code{\textit{host}:\textit{port}}.

\item[\corbauri{omniunix}]\mbox{}\\
The omniORB Unix domain socket transport. The address details are of
the form \code{\textit{filename}}.

\end{description}



\subsection{Resolve initial references}

A \corbauri{corbaloc:} can also specify a call to
\op{resolve\_initial\_references}. This

\begin{cxxlisting}
orb->string_to_object("corbaloc:rir:/NameService");
\end{cxxlisting}

\noindent is identical in behaviour to

\begin{cxxlisting}
orb->resolve_initial_references("NameService");
\end{cxxlisting}






\subsection{corbaname}
\label{sec:corbaname}

\corbauri{corbaname} URIs cause \op{string\_to\_object} to look-up a
name in a CORBA Naming service. They are an extension of the
\corbauri{corbaloc} syntax:

\begin{quote}
\corbauri{corbaname:}%
<\textit{corbaloc location}>%
\corbauri{/}%
<\textit{object key}>%
\corbauri{#}%
<\textit{stringified name}>
\end{quote}

\noindent for example:

\begin{quote}
\corbauri{corbaname::myhost/NameService#project/example/echo.obj}\\
\corbauri{corbaname:rir:/NameService#project/example/echo.obj}
\end{quote}

\noindent The object found with the \corbauri{corbaloc}-style portion
must be of type \intf{CosNaming::\dsc{}NamingContext}, or something
derived from it. If the object key (or \corbauri{rir} name) is
`\corbauri{NameService}', it can be left out:

\begin{quote}
\corbauri{corbaname::myhost#project/example/echo.obj}\\
\corbauri{corbaname:rir:#project/example/echo.obj}
\end{quote}

\noindent The stringified name portion can also be left out, in which
case the URI denotes the \intf{CosNaming::NamingContext} which would
have been used for a look-up:

\begin{quote}
\corbauri{corbaname::myhost.example.com}\\
\corbauri{corbaname:rir:}
\end{quote}

\noindent The first of these examples is the easiest way of specifying
the location of a naming service.


\section{Configuring resolve\_initial\_references}
\label{sec:insargs}

The INS specifies two standard command line arguments which provide a
portable way of configuring \op{ORB::resolve\_initial\_references}:


\subsection{ORBInitRef}

\cmdline{-ORBInitRef} takes an argument of the form
<\textit{ObjectId}>\cmdline{=}<\textit{ObjectURI}>. So, for example,
with command line arguments of:

\begin{quote}
\cmdline{-ORBInitRef NameService=corbaname::myhost.example.com}
\end{quote}

\noindent \code{resolve\_initial\_references("NameService")} will
return a reference to the object with key `NameService' available on
myhost.example.com, port 2809. Since IOR-format strings are considered
URIs, you can also say things like:

\begin{quote}
\cmdline{-ORBInitRef NameService=IOR:00ff...}
\end{quote}


\subsection{ORBDefaultInitRef}

\cmdline{-ORBDefaultInitRef} provides a prefix string which is used to
resolve otherwise unknown names. When
\op{resolve\_initial\_references} is unable to resolve a name which
has been specifically configured (with \cmdline{-ORBInitRef}), it
constructs a string consisting of the default prefix, a `\corbauri{/}'
character, and the name requested.  The string is then fed to
\op{string\_to\_object}. So, for example, with a command line of:

\begin{quote}
\cmdline{-ORBDefaultInitRef corbaloc::myhost.example.com}
\end{quote}

\noindent a call to \code{resolve\_initial\_references("MyService")}
will return the object reference denoted by
`\corbauri{corbaloc::myhost.example.com/MyService}'.

Similarly, a \corbauri{corbaname} prefix can be used to cause
look-ups in the naming service. Note, however, that since a
`\corbauri{/}' character is always added to the prefix, it is
impossible to specify a look-up in the root context of the naming
service---you have to use a sub-context, like:

\begin{quote}
\cmdline{-ORBDefaultInitRef corbaname::myhost.example.com\#services}
\end{quote}



\section{omniNames}

\subsection{NamingContextExt}

omniNames supports the extended \intf{CosNaming::NamingContextExt}
interface:

\begin{idllisting}
module CosNaming {
  interface NamingContextExt : NamingContext {
    typedef string StringName;
    typedef string Address;
    typedef string URLString;

    StringName  to_string(in Name n)        raises(InvalidName);
    Name        to_name  (in StringName sn) raises(InvalidName);

    exception InvalidAddress {};

    URLString   to_url(in Address addr, in StringName sn)
      raises(InvalidAddress, InvalidName);

    Object      resolve_str(in StringName n)
      raises(NotFound, CannotProceed, InvalidName, AlreadyBound);
  };
};
\end{idllisting}

\op{to\_string} and \op{to\_name} convert from \type{CosNaming::Name}
sequences to flattened strings and vice-versa.  Note that calling
these operations involves remote calls to the naming service, so they
are not particularly efficient. You can use the omniORB specific local
\op{omniURI::nameToString} and \op{omniURI::\dsc{}stringToName}
functions instead.

A \type{CosNaming::Name} is stringified by separating name components
with `\texttt{/}' characters. The \code{kind} and \code{id} fields of
each component are separated by `\texttt{.}' characters. If the
\code{kind} field is empty, the representation has no trailing
`\texttt{.}'; if the \code{id} is empty, the representation starts
with a `\texttt{.}' character; if both \texttt{id} and \texttt{kind}
are empty, the representation is just a `\texttt{.}'. The backslash
`\texttt{\textbackslash}' is used to escape the meaning of
`\texttt{/}', `\texttt{.}' and `\texttt{\textbackslash}' itself.

\op{to\_url} takes a \corbauri{corbaloc} style address and key string
(but without the \corbauri{corbaloc:} part), and a stringified name,
and returns a \corbauri{corbaname} URI (incorrectly called a URL)
string, having properly escaped any invalid characters. The
specification does not make it clear whether or not the address string
should also be escaped by the operation; omniORB does not escape
it. For this reason, it is best to avoid calling \op{to\_url} if the
address part contains escapable characters.  To avoid remote calls,
omniORB provides the equivalent local function
\op{omniURI::\dsc{}addrAndNameToURI}.

\op{resolve\_str} is equivalent to calling \op{to\_name} followed by
the inherited \op{resolve} operation. There are no string-based
equivalents of the various bind operations.


\subsection{Use with corbaname}

To make it easy to use omniNames with \corbauri{corbaname} URIs, it
starts with the default port of 2809, and an object key of
`\texttt{NameService}' for the root naming context.


\section{omniMapper}
\hyphenation{omni-Mapper}

omniMapper is a simple daemon which listens on port 2809 (or any other
port), and redirects IIOP requests for configured object keys to
associated persistent object references. It can be used to make a
naming service (even an old non-INS aware version of omniNames or
other ORB's naming service) appear on port 2809 with the object key
`\texttt{NameService}'. The same goes for any other service you may
wish to specify, such as an interface repository. omniMapper is
started with a command line of:

\begin{quote}
\cmdline{omniMapper [-port }<\textit{port}>%
\cmdline{] [-config }<\textit{config file}>%
\cmdline{] [-v]}
\end{quote}

\noindent The \cmdline{-port} option allows you to choose a port other
than 2809 to listen on. The \cmdline{-config} option specifies a
location for the configuration file. The default name is
\file{/etc/omniMapper.cfg}, or \file{C:\omniMapper.cfg} on
Windows. omniMapper does not normally print anything; the \cmdline{-v}
option makes it verbose so it prints configuration information and a
record of the redirections it makes, to standard output.

The configuration file is very simple. Each line contains a string to
be used as an object key, some white space, and an IOR (or any valid
URI) that it will redirect that object key to. Comments should be
prefixed with a `\texttt{\#}' character. For example:

\begin{quote}
\begin{verbatim}
# Example omniMapper.cfg
NameService         IOR:000f...
InterfaceRepository IOR:0100...
\end{verbatim}
\end{quote}

omniMapper can either be run on a single machine, in much the same way
as omniNames, or it can be run on \emph{every} machine, with a common
configuration file. That way, each machine's omniORB configuration
file could contain the line:

\begin{quote}
\begin{verbatim}
ORBDefaultInitRef corbaloc::localhost
\end{verbatim}
\end{quote}



\section{Creating objects with simple object keys}

In normal use, omniORB creates object keys containing various
information including POA names and various non-ASCII characters.
Since object keys are supposed to be opaque, this is not usually a
problem. The INS breaks this opacity and requires servers to create
objects with human-friendly keys.

If you wish to make your objects available with human-friendly URIs,
there are two options. The first is to use omniMapper as described
above, in conjunction with a \code{PERSISTENT} POA. The second is to
create objects with the required keys yourself. You do this with a
special POA with the name `\texttt{omniINSPOA}', acquired from
\op{resolve\_initial\_references}. This POA has the \code{USER\_ID}
and \code{PERSISTENT} policies, and the special property that the
object keys it creates contain only the object ids given to the POA,
and no other data. It is a normal POA in all other respects, so you
can activate/deactivate it, create children, and so on, in the usual
way.

Children of the omniINSPOA do not inherit its special properties of
creating simple object keys. If the omniINSPOA's policies are not
suitable for your application, you cannot create a POA with different
policies (such as single threading, for example), and still generate
simple object keys. Instead, you can activate a servant in the
omniINSPOA that uses location forwarding to redirect requests to
objects in a different POA.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Code set conversion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:codesets}

omniORB supports full code set negotiation, used to select and
translate between different character code sets when transmitting
chars, strings, wchars and wstrings. The support is mostly transparent
to application code, but there are a number of options that can be
selected. This chapter covers the options, and also gives some
pointers about how to implement your own code sets, in case the ones
that come with omniORB are not sufficient.


\section{Native code sets}

For the ORB to know how to handle strings and wstrings given to it by
the application, it must know what code set they are represented
with, so it can properly translate them if need be. The defaults are
ISO 8859-1 (Latin 1) for char and string, and UTF-16 for wchar and
wstring. Different code sets can be chosen at initialisation time with
the \code{nativeCharCodeSet} and \code{nativeWCharCodeSet}
parameters. The supported code sets are printed out at initialisation
time if the ORB traceLevel is 15 or greater.

For most applications, the defaults are fine. Some applications may
need to set the native char code set to UTF-8, allowing the full
Unicode range to be supported in strings.

Note that the default for wchar is always UTF-16, even on Unix
platforms where wchar is a 32-bit type. Select the UCS-4 code set to
select characters outside the first plane without having to use UTF-16
surrogates\footnote{If you have no idea what this means, don't
worry---you're better off not knowing unless you \emph{really} have
to.}.


\section{Default code sets}

The way code set conversion is meant to work in CORBA communication is
that each client and server has a \term{native} code set that it uses
for character data in application code, and supports a number of
\term{transmission} code sets that is uses for communication. When a
client connects to a server, the client picks one of the server's
transmission code sets to use for the interaction. For that to work,
the client plainly has to know the server's supported transmission
code sets.

Code set information from servers is embedded in IORs. A client with
an IOR from a server should therefore know what transmission code sets
the server supports. This approach can fail for two reasons:

\begin{enumerate}
  \item A \corbauri{corbaloc} URI (see chapter~\ref{chap:ins}) does
    not contain any code set information.

  \item Some badly-behaved servers that do support code set conversion
    fail to put codeset information in their IORs.
\end{enumerate}

The CORBA standard says that if a server has not specified
transmission code set information, clients must assume that they only
support ISO-8859-1 for char and string, and do not support wchar and
wstring at all. The effect is that client code receives
\code{DATA\_CONVERSION} or \code{BAD\_PARAM} exceptions.

To avoid this issue, omniORB allows you to configure \term{default}
code sets that are used as a server's transmission code sets if they
are not otherwise known. Set \code{defaultCharCodeSet} for char and
string data, and \code{defaultWCharCodeSet} for wchar and wstring data.


\section{Code set library}

To save space in the main ORB core library, most of the code set
implementations are in a separate library named omniCodeSets4. To use
the extra code sets, you must link your application with that
library. On most platforms, if you are using dynamic linking,
specifying the omniCodeSets4 library in the link command is sufficient
to have it initialised, and for the code sets to be available. With
static linking, or platforms with less intelligent dynamic linkers,
you must force the linker to initialise the library. You do that by
including the \file{omniORB4/optionalFeatures.h} header. By default,
that header enables several optional features. Look at the file
contents to see how to turn off particular features.


\section{Implementing new code sets}

It is quite easy to implement new code sets, if you need support for
code sets (or marshalling formats) that do not come with the omniORB
distribution. There are extensive comments in the headers and ORB code
that explain how to implement a code set; this section just serves to
point you in the right direction.

The main definitions for the code set support are in
\file{include/omniORB4/codeSets.h}. That defines a set of base classes
use to implement code sets, plus some derived classes that use look-up
tables to convert simple 8-bit and 16-bit code sets to Unicode.

When sending or receiving string data, there are a total of four code
sets in action: a native char code set, a transmission char code set,
a native wchar code set, and a transmission wchar code set. The native
code sets are as described above; the transmission code sets are the
ones selected to communicate with a remote machine. They are
responsible for understanding the GIOP marshalling formats, as well as
the code sets themselves. Each of the four code sets has an object
associated with it which contains methods for converting data.

There are two ways in which a string/wstring can be transmitted or
received. If the transmission code set in action knows how to deal
directly with the native code set (the trivial case being that they
are the same code set, but more complex cases are possible too), the
transmission code set object can directly marshal or unmarshal the
data into or out of the application buffer. If the transmission code
set does not know how to handle the native code set, it converts the
string/wstring into UTF-16, and passes that to the native code set
object (or vice-versa). All code set implementations must therefore
know how to convert to and from UTF-16.

With this explanation, the classes in \file{codeSets.h} should be easy
to understand. The next place to look is in the various existing code
set implementations, which are files of the form \file{cs-*.cc} in the
\file{src/lib/omniORB/orbcore} and \file{src/lib/omniORB/codesets}.
Note how all the 8-bit code sets (the ISO 8859-* family) consist
entirely of data and no code, since they are driven by look-up tables.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Interceptors}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:interceptors}

omniORB supports interceptors that allow the application to insert
processing in various points along the call chain, and in various
other locations. It does not (yet) support the standard Portable
Interceptors API.

The interceptor interfaces are defined in a single header,
\file{include/omniORB4/omniInterceptors.h}. Each interception point
consists of a singleton object with \op{add} and \op{remove} methods,
and the definition of an `interceptor info' class. For example:

\begin{cxxlisting}
class omniInterceptors {
  ...
  class clientSendRequest_T {
  public:

    class info_T {
    public:
      GIOP_C&                 giop_c;
      IOP::ServiceContextList service_contexts;

      info_T(GIOP_C& c) : giop_c(c), service_contexts(5) {}

    private:
      info_T();
      info_T(const info_T&);
      info_T& operator=(const info_T&);
    };

    typedef CORBA::Boolean (*interceptFunc)(info_T& info);

    void add(interceptFunc);
    void remove(interceptFunc);
  };
  ...
};
\end{cxxlisting}

\noindent You can see that the interceptors themselves are functions
that take the \code{info\_T} object as their argument and return
boolean. Interceptors are called in the order they are registered;
normally, all interceptor functions return \code{true}, meaning that
processing should continue with subsequent interceptors. If an
interceptor returns \code{false}, later interceptors are not
called. You should only do that if you really know what you are doing.

Notice that the \code{info\_T} contains references to omniORB internal
data types. The definitions of these types can be found in other
header files within \file{include/omniORB4} and
\file{include/omniORB4/internal}.


\section{Interceptor registration}

All the interceptor singletons are registered within another singleton
object of class \code{omniInterceptors}. You retrieve a pointer to the
object with the \op{omniORB::\dsc{}getInterceptors} function, which
must be called after the ORB has been initialised with
\op{CORBA::ORB\_init}, but before the ORB is used. The code to
register an interceptor looks, for example, like:

\begin{cxxlisting}
omniInterceptors* interceptors = omniORB::getInterceptors();
interceptors->clientSendRequest.add(myInterceptorFunc);
\end{cxxlisting}


\section{Available interceptors}

The following interceptors are available:

\begin{description}

\item[encodeIOR]\mbox{}\\
%
Called when encoding an IOR to represent an object reference. This
interception point allows the application to insert extra profile
components into IORs. Note that you must understand and adhere to the
rules about data stored in IORs, otherwise the IORs created may be
invalid. omniORB itself uses this interceptor to insert various items,
so you can see an example of its use in the
\op{insertSupportedComponents} function defined in
\file{src/lib/omniORB/orbcore/ior.cc}.


\item[decodeIOR]\mbox{}\\
%
Called when decoding an IOR. The application can use this to get out
whatever information they put into IORs with encodeIOR. Again, see
\op{extract\dsc{}SupportedComponents} in
\file{src/lib/omniORB/orbcore/ior.cc} for an example.


\item[clientOpenConnection]\mbox{}\\
%
Called as a client opens a new connection to a server, after the
connection is opened but before it is used to send a request. The
interceptor function can set the \code{info\_T}'s \code{reject} member
to \code{true} to cause the client to immediately close the new
connection and throw CORBA::TRANSIENT to the calling code. In that
case, the interceptor function can also set the \code{why} member to
provide a message that is logged.


\item[clientSendRequest]\mbox{}\\
%
Called just before a request header is sent over the network. The
application can use it to insert service contexts in the header. See
the \op{setCodeSet\dsc{}ServiceContext} function in
\file{src/lib/omniORB/orbcore/cdrStream.cc} for an example of its use.


\item[clientReceiveReply]\mbox{}\\
%
Called as the client receives a reply, just after unmarshalling the
reply header. Called for normal replies and exceptions.


\item[serverAcceptConnection]\mbox{}\\
%
Called when a server accepts a new incoming connection, but before it
reads any data from it. The interceptor function can set the
\code{info\_T}'s \code{reject} member to \code{true} to cause the
server to immediately close the new connection. In that case, the
interceptor function can also set the \code{why} member to provide a
message that is logged.


\item[serverReceiveRequest]\mbox{}\\
%
Called when the server receives a request, just after unmarshalling
the request header. See the \op{getCodeSetServiceContext} function in
\file{src/lib/omniORB/orbcore/cdrStream.cc} for an example.


\item[serverSendReply]\mbox{}\\
%
Called just before the server marshals a reply header.


\item[serverSendException]\mbox{}\\
%
Called just before the server marshals an exception reply header.


\item[createRope]\mbox{}\\
%
Called when the ORB is about to create a `rope' that encapsulates a
bundle of connections (`strands') to a remote address space. It allows
application code to override omniORB's normal connection management.


\item[createIdentity]\mbox{}\\
%
Called when the ORB is about to create an `identity' object to
represent a CORBA object. It allows application code to provide its
own identity implementations. It is very unlikely that an application
will need to do this.


\item[createORBServer]\mbox{}\\
%
Used internally by the ORB to register different kinds of server. At
present, only a GIOP server is registered. It is very unlikely that
application code will need to do this.


\item[createThread]\mbox{}\\
%
Called whenever the ORB creates a thread. The \type{info\_T} class for
this interceptor is

\begin{cxxlisting}
    class info_T {
    public:
      virtual void run() = 0;
      virtual omni_thread* self() = 0;
    };
\end{cxxlisting}

\noindent
The interceptor is called in the context of the newly created thread.
The function \emph{must} call the \type{info\_T}'s \op{run} method, to
pass control to the thread body. \op{run} returns just before the
thread exits. This arrangement allows the interceptor to initialise
some per-thread state before the thread body runs, then release it
just before the thread exits.

The \type{info\_T}'s \op{self} method returns a pointer to the
\type{omni\_thread} object for the thread, equivalent to calling
\op{omni\_thread::self}.


\item[assignUpcallThread]\mbox{}\\
%
The ORB maintains a general thread pool, from which threads are drawn
for various purposes. One purpose is for performing upcalls to
application code, in response to incoming CORBA calls. The
\code{assignUpcallThread} interceptor is called when a thread is
assigned to perform upcalls. In the thread per connection model, the
thread stays assigned to performing upcalls for the entire lifetime of
the underlying network connection; in the thread pool model, threads
are assigned for upcalls on a per call basis, so this interceptor is
triggered for every incoming call\footnote{Except that with the
  \code{threadPoolWatchConnection} parameter set \code{true}, a thread
  can perform multiple upcalls even when thread pool mode is
  active.}. As with the \code{createThread} interceptor, the
interceptor function must call the \type{info\_T}'s \op{run} method to
pass control to the upcall.

When a thread finishes its assignment of processing upcalls, it
returns to the pool (even in thread per connection mode), so the same
thread can be reassigned to perform more upcalls, or reused for a
different purpose.


\item[assignAMIThread]\mbox{}\\
%
Asynchronous Method Invocation (AMI) uses threads to perform outgoing
calls. The \code{assignAMIThread} interceptor is called when a thread
is assigned to perform AMI calls. As with the other thread
interceptors, the interceptor function must call the \type{info\_T}'s
\op{run} method to pass control to the AMI call.

Unlike the other interceptors, the interceptor functions for
\code{createThread}, \code{assignUpcallThread} and
\code{assignAMIThread} have no return values. Interceptor chaining is
performed by calls through the \op{info\_T::run} method, rather than
by visiting interceptor functions in turn.

\end{description}


\section{Server-side call interceptor}

Calls can be intercepted on the server just before the upcall into
application code. This interceptor is registered with omniORB's
\type{callDescriptor} class, which is responsible for encapsulating
the state of a call. Unlike the transport-related
\code{serverReceiveRequest}, \code{serverSendReply} and
\code{serverSendException} interceptors, the \type{callDescriptor}
interceptor is invoked for \emph{all} calls, even ones from colocated
clients in the same address space.

The types used for the call interceptor are defined in
\file{include/omniORB4/callDescriptor.h}. The interceptor takes the
form of a bare function with two parameters. The first parameter is a
pointer to the \type{callDescriptor}; the second is a pointer to
\type{omniServant}, which is the base class of all servant
classes. The interceptor function must call the
\type{callDescriptor}'s \op{interceptedCall} method to pass on the
call.

This interception point allows access to various parts of omniORB's
call machinery. The \type{callDescriptor} includes access to the
operation name and, if cast to the concrete subclass defined by the
IDL compiler, the call arguments and return values too.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Type Any and TypeCode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:any}

The CORBA specification provides for a type that can hold the value of
any OMG IDL type. This type is known as type \type{Any}. The OMG also
specifies a pseudo-object, \type{TypeCode}, that can encode a
description of any type specifiable in OMG IDL.

In this chapter, an example demonstrating the use of type Any is
presented. The example code is in the \file{src/examples/anyExample}
directory in the omniORB distribution. The example is followed by
sections describing the behaviour of type Any and TypeCode in omniORB.
For further information on type Any, refer to the C++ Mapping
specification., and for more information on TypeCode, refer to the
Interface Repository chapter in the CORBA core section of the CORBA
specification.



\section{Example using type Any}

Before going through this example, you should make sure that you have
read and understood the examples in chapter~\ref{chap:basic}.

\subsection{Type Any in IDL}
Type Any allows one to delay the decision on the type used in an
operation until run-time. To use type any in IDL, use the keyword
\code{any}, as in the following example:

\begin{idllisting}
// IDL
interface anyExample {
  any testOp(in any mesg);
};
\end{idllisting}


\noindent The operation \op{testOp} in this example can now take any
value expressible in OMG IDL as an argument, and can also return any
type expressible in OMG IDL.

Type Any is mapped into C++ as the type \type{CORBA::Any}. When passed
as an argument or as a result of an operation, the following rules
apply:

\mbox{}

{\small
\begin{tabular}{llll}
{\bf In }                & {\bf InOut }       & {\bf Out }           & 
{\bf Return }                                                   \\ \hline
{\tt const CORBA::Any\& }& {\tt CORBA::Any\& }& {\tt CORBA::Any*\& } & 
{\tt CORBA::Any* }
\end{tabular}
}

\mbox{}

\noindent So, the above IDL would map to the following C++:

\begin{cxxlisting}
// C++

class anyExample_i : public virtual POA_anyExample {
public:
  anyExample_i() { }
  virtual ~anyExample_i() { }
  virtual CORBA::Any* testOp(const CORBA::Any& a);
};
\end{cxxlisting}


\subsection{Inserting and Extracting Basic Types from an Any}

The question now arises as to how values are inserted into and removed
from an Any. This is achieved using two overloaded operators:
\code{<{}<=} and \code{>{}>=}.

To insert a value into an Any, the \code{<{}<=} operator is used, as
in this example:

\begin{cxxlisting}
// C++
CORBA::Any an_any;
CORBA::Long l = 100;
an_any <<= l;
\end{cxxlisting}

\noindent Note that the overloaded \code{<{}<=} operator has a return
type of \type{void}.

To extract a value, the \code{>{}>=} operator is used, as in this
example (where the Any contains a long):

\begin{cxxlisting}
// C++
CORBA::Long l;
an_any >>= l;

cout << "This is a long: " << l << endl;
\end{cxxlisting}


The overloaded \code{>{}>=} operator returns a \type{CORBA::Boolean}.
If an attempt is made to extract a value from an Any when it contains
a different type of value (e.g.\ an attempt to extract a long from an
Any containing a double), the overloaded \code{>{}>=} operator will
return \code{false}; otherwise it will return \code{true}. Thus, a
common tactic to extract values from an Any is as follows:

\begin{cxxlisting}
// C++
CORBA::Long l;
CORBA::Double d;
const char* str;

if (an_any >>= l) {
  cout << "Long: " << l << endl;
}
else if (an_any >>= d) {
  cout << "Double: " << d << endl;
}
else if (an_any >>= str) {
  cout << "String: " << str << endl;
  // The storage of the extracted string is still owned by the any.
}
else {
  cout << "Unknown value." << endl;
}
\end{cxxlisting}


\subsection{Inserting and Extracting Constructed Types from an Any}

It is also possible to insert and extract constructed types and object
references from an Any. omniidl will generate insertion and extraction
operators for the constructed type. Note that it is necessary to
specify the \texttt{-Wba} command-line flag when running omniidl in
order to generate these operators. The following example illustrates
the use of constructed types with type Any:

\begin{idllisting}
// IDL
struct testStruct {
  long l;
  short s;
};

interface anyExample {
  any testOp(in any mesg);
};
\end{idllisting}

Upon compiling the above IDL with \texttt{omniidl -bcxx -Wba}, the
following overloaded operators are generated:

\begin{enumerate}
\item \verb|void operator<<=(CORBA::Any&, const testStruct&)|
\item \verb|void operator<<=(CORBA::Any&, testStruct*)|
\item \verb|CORBA::Boolean operator>>=(const CORBA::Any&,|\\
      \verb|const testStruct*&)|
\end{enumerate}

Operators of this form are generated for all constructed types, and
for interfaces.

The first operator, \emph{(1)}, copies the constructed type, and
inserts it into the Any. The second operator, \emph{(2)}, inserts the
constructed type into the Any, and then manages it. Note that if the
second operator is used, the Any consumes the constructed type, and
the caller should not use the pointer to access the data after
insertion. The following is an example of how to insert a value into
an Any using operator \emph{(1)}:

\begin{cxxlisting}
// C++
CORBA::Any an_any;

testStruct t;
t.l = 456;
t.s = 8;

an_any <<= t;
\end{cxxlisting}


The third operator, \emph{(3)}, is used to extract the constructed
type from the Any, and can be used as follows:

\begin{cxxlisting}
const testStruct* tp;

if (an_any >>= tp) {
    cout << "testStruct: l: " << tp->l << endl;
    cout << "            s: " << tp->s << endl;
}
else {
    cout << "Unknown value contained in Any." << endl;
}
\end{cxxlisting}

As with basic types, if an attempt is made to extract a type from an
Any that does not contain a value of that type, the extraction
operator returns \code{false}. If the Any does contain that type, the
extraction operator returns \code{true}. If the extraction is
successful, the caller's pointer will point to memory managed by the
Any. The caller must not delete or otherwise change this storage, and
should not use this storage after the contents of the Any are replaced
(either by insertion or assignment), or after the Any has been
destroyed. In particular, management of the pointer should not be
assigned to a \type{\_var} type.

If the extraction fails, the caller's pointer will be set to point to
null.

Note that there are special rules for inserting and extracting arrays
(using the \type{\_forany} types), and for inserting and extracting
bounded strings, booleans, chars, and octets. Please refer to the C++
Mapping specification for further information.



\section{Type Any in omniORB}
\label{anyOmniORB}

This section contains some notes on the use and behaviour of type Any
in omniORB.

\subsection{Generating Insertion and Extraction Operators.}
To generate type Any insertion and extraction operators for
constructed types and interfaces, the \texttt{-Wba} command line flag
should be specified when running omniidl.

\subsection{TypeCode comparison when extracting from an Any.}
When an attempt is made to extract a type from an Any, the TypeCode of
the type is checked for \emph{equivalence} with the TypeCode of the
type stored by the Any. The \op{equivalent} test in the TypeCode
interface is used for this purpose. For example:

\begin{idllisting}
// IDL 1
typedef double Double1;

struct Test1 {
  Double1 a;
};
\end{idllisting}

\begin{idllisting}
// IDL 2
typedef double Double2;

struct Test1 {
  Double2 a;
};
\end{idllisting}
    
If an attempt is made to extract the type \type{Test1} defined in IDL
1 from an Any containing the \type{Test1} defined in IDL 2, this will
succeed (and vice-versa), as the two types differ only by an alias.

\subsection{Top-level aliases.}
When a type is inserted into an Any, the Any stores both the value of
the type and the TypeCode for that type. However, in some cases, a
top-level alias can be lost due to the details of the C++ mapping. For
example, consider these IDL definitions:

\begin{idllisting}
// IDL 3
typedef sequence<double> seqDouble1;
typedef sequence<double> seqDouble2;
typedef seqDouble2       seqDouble3;
\end{idllisting}

omniidl generates distinct types for \type{seqDouble1} and
\type{seqDouble2}, and therefore each has its own set of C++ operators
for Any insertion and extraction. That means inserting a
\type{seqDouble1} into an Any sets the Any's TypeCode to include the
alias `seqDouble1', and inserting a \type{seqDouble2} sets the
TypeCode to the alias `seqDouble2'.

However, in the C++ mapping, \type{seqDouble3} is required to be just
a C++ typedef to \type{seqDouble2}, so the C++ compiler uses the Any
insertion operator for \type{seqDouble2}. Therefore, inserting a
\type{seqDouble3} sets the Any's TypeCode to the \type{seqDouble2}
alias. If this is not desirable, you can use the member function
`\code{void type(TypeCode\_ptr)}' of the Any interface to explicitly
set the TypeCode to the correct one.


\subsection{Removing aliases from TypeCodes.}
Some ORBs (such as old versions of Orbix) will not accept TypeCodes
containing \code{tk\_alias} TypeCodes. When using type Any while
interoperating with these ORBs, it is necessary to remove
\code{tk\_alias} TypeCodes from throughout the TypeCode representing a
constructed type.

To remove all \code{tk\_alias} TypeCodes from TypeCodes transmitted in
Anys, supply the \texttt{-ORBtcAliasExpand 1} command-line flag when
running an omniORB executable. There will be some (small) performance
penalty when transmitting Any values.

Note that the \code{\_tc\_} TypeCodes generated for all constructed
types will contain the complete TypeCode for the type (including any
\code{tk\_alias} TypeCodes), regardless of whether the
\texttt{-ORBtcAliasExpand} flag is set to 1 or not. It is only when
Anys are transmitted that the aliases are stripped.

\subsection{Recursive TypeCodes.}
omniORB supports recursive TypeCodes. This means that types such as
the following can be inserted or extracted from an Any:

\begin{idllisting}
// IDL 4
struct Test4 {
  sequence<Test4> a;
};
\end{idllisting}


\subsection{Threads and type Any.}
Inserting and extracting simultaneously from the same Any (in 2
threads) results in undefined behaviour.

In versions of omniORB before 4.0, extracting simultaneously from the
same Any (in 2 or more different threads) also led to undefined
behaviour. That is no longer the case---Any extraction is now thread
safe.


\section{TypeCode in omniORB}

This section contains some notes on the use and behaviour of TypeCode
in omniORB

\subsection{TypeCodes in IDL.}

When using TypeCodes in IDL, note that they are defined in the CORBA
scope.  Therefore, \type{CORBA::TypeCode} should be used. Example:

\begin{idllisting}
// IDL 5
struct Test5 {
  long length;
  CORBA::TypeCode desc;
};
\end{idllisting}

\subsection{orb.idl}

The CORBA specification says that IDL using \type{CORBA::TypeCode}
must include the file \file{orb.idl}. That is not required in omniORB,
but a suitable \file{orb.idl} is available.


\subsection{Generating TypeCodes for constructed types.}

To generate a TypeCode for constructed types, specify the
\texttt{-Wba} command-line flag when running omniidl. This will
generate a \code{\_tc\_} TypeCode describing the type, at the same
scope as the type. Example:

\begin{idllisting}
// IDL 6
struct Test6 {
  double a;
  sequence<long> b;
};
\end{idllisting}

A TypeCode, \code{\_tc\_Test6}, will be generated to describe the
struct \type{Test6}. The operations defined in the TypeCode interface
can be used to query the TypeCode about the type it represents.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter[Objects by value, etc.]
  {Objects by value, abstract interfaces and local interfaces}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:valuetype}

omniORB 4.1 supports objects by value, declared with the
\code{valuetype} keyword in IDL, and both abstract and local
interfaces. This chapter outlines some issues to do with using these
types in omniORB. You are assumed to have read the relevant parts of
the CORBA specification, specifically chapters 3, 4, 5 and 6 of the
CORBA 2.6 specification, and sections 1.17, 1.18 and 1.35 of the C++
mapping specification, version 1.1.


\section{Features}

omniORB supports the complete objects by value specification, with the
exception of custom valuetypes. All other valuetype features including
value boxes, value sharing semantics, abstract valuetypes, and
abstract interfaces are supported. Local interfaces are supported,
with a number of caveats outlined in
section~\ref{sec:LocalInterfaces}.


\section{Reference counting}

Values are reference counted. This means that, as long as your
application properly manages reference counts, values are usually
automatically deleted when they are no longer required. However, one
of the features of valuetypes is that they support the representation
of cyclic graph structures. In that kind of situation, the reference
counting garbage collection does not work, because references internal
to the graph prevent the reference counts ever becoming zero.

To avoid memory leaks, application code must explicitly break any
reference cycles in values it manipulates. This includes graphs of
values received as parameters and return values from CORBA operations.


\section{Value sharing and local calls}

When valuetypes are passed as parameters in CORBA calls (i.e.\ calls
on CORBA objects declared with \code{interface} in IDL), the structure
of related values is maintained. Consider, for example, the following
IDL definitions (which are from the example code in
\file{src/examples/valuetype/simple}:

\begin{idllisting}
module ValueTest {
  valuetype One {
    public string s;
    public long   l;
  };

  interface Test {
    One op1(in One a, in One b);
  };
};
\end{idllisting}

If the client to the \type{Test} object passes the same value in both
parameters, just one value is transmitted, and the object
implementation receives a copy of the single value, with references to
it in both parameters.

In the case that the object is remote from the client, there is
obviously a copying step involved. In the case that the object is in
the same address space as the client, the same copying semantics must
be maintained so that the object implementation can modify the values
it receives without the client seeing the modifications. To support
that, omniORB must copy the entire parameter list in one operation, in
case there is sharing between different parameters. Such copying is a
rather more time-consuming process than the parameter-by-parameter
copy that takes place in calls not involving valuetypes.

To avoid the overhead of copying parameters in this way, applications
can choose to relax the semantics of value copying in local calls, so
values are not copied at all, but are passed by reference. In that
case, the client to a call \emph{will} see any modifications to the
values it passes as parameters (and similarly, the object
implementation will see any changes the client makes to returned
values). To choose this option, set the \code{copyValuesInLocalCalls}
configuration parameter to zero.


\section{Value box factories}

With normal valuetypes, omniidl generates factory classes (with names
ending \code{\_init}) as required by the C++ mapping specification.
The application is responsible for registering the factories with the
ORB.

Unfortunately, the C++ mapping makes no mention of factories for value
boxes. In omniORB, factories for value boxes are automatically
registered with the ORB, and there are no application-visible factory
classes generated for them. Some other CORBA implementations generate
application visible factories, and the application \emph{does} have to
register the factories with the ORB.


\section{Standard value boxes}

The standard \type{CORBA::StringValue} and \type{CORBA::WStringValue}
value boxes are available to application code. To make the definitions
available in IDL, \#include the standard \file{orb.idl}.


\section{Covariant returns}

As required by the C++ mapping, on C++ compilers that support
covariant return types, omniidl generates code for the
\op{\_copy\_value} function that returns the most derived type of the
value. On older compilers, \op{\_copy\_value} returns
\type{CORBA::ValueBase}.

If you write code that calls \op{\_copy\_value}, and you need to
support older compilers, you should assign the result to a variable of
type \type{CORBA::ValueBase*} and downcast to the target type, rather
than using the covariant return.

If you are overriding \op{\_copy\_value}, you must correctly take
account of the \code{OMNI\_HAVE\_COVARIANT\_RETURNS} preprocessor
definition.



\section{Values inside Anys}

Valuetypes inserted into Anys cause a number of interesting issues.
Even when inside Anys, values are required to support complete sharing
semantics. Take this IDL for example:

\begin{idllisting}
module ValueTest {
  valuetype One {
    public string s;
    public long   l;
  };

  interface AnyTest {
    void op1(in One v, in Any a);
  };
};
\end{idllisting}

\noindent Now, suppose the client behaves as follows:

\begin{cxxlisting}
ValueTest::One* v = new One_impl("hello", 123);
CORBA::Any a;
a <<= v;
obj->op1(v, a);
\end{cxxlisting}

\noindent then on the server side:

\begin{cxxlisting}
void AnyTest_impl::op1(ValueTest::One* v, CORBA::Any& a)
{
  ValueTest::One* v2;
  a >>= v2;
  assert(v2 == v);
}
\end{cxxlisting}

\noindent
This is all very well in this kind of simple situation, but problems
can arise if truncatable valuetypes are used. Imagine this derived
value:

\begin{idllisting}
module ValueTest {
  valuetype Two : truncatable One {
    public double d;
  };
};
\end{idllisting}

\noindent
Now, suppose that the client shown above sends an instance of
valuetype \type{Two} in both parameters, and suppose that the server
has not seen the definition of valuetype \type{Two}. In this
situation, as the first parameter is unmarshalled, it will be
truncated to valuetype \type{One}, as required. Now, when the Any is
unmarshalled, it refers to the same value, which has been truncated.
So, even though the TypeCode in the Any indicates that the value has
type \type{Two}, the stored value actually has type \type{One}. If the
receiver of the Any tries to pass it on, transmission will fail
because the Any's value does not match its TypeCode.

In the opposite situation, where an Any parameter comes before a
valuetype parameter, a different problem occurs. In that case, as the
Any is unmarshalled, there is no type information available for
valuetype \type{Two}, so the value inside the Any has an internal
omniORB type used for unknown valuetypes. As the next parameter is
unmarshalled, omniORB sees that the shared value is unknown, and is
able to convert it to the target \type{One} valuetype with
truncation. In this case, the Any and the plain valuetype both have
the correct types and values, but the fact that both should have
referred to the same value has been lost.

Because of these issues, it is best to avoid defining interfaces that
mix valuetypes and Anys in a single operation, and certainly to avoid
trying to share plain values with values inside Anys.


\subsection{Values inside DynAnys}

The sharing semantics of valuetypes can also cause difficulties for
DynAny. The CORBA 2.6 specification does not mention how shared values
inside DynAnys should be handled; the CORBA 3.x specification slightly
clarifies the situation, but it is still unclear. To write portable
code it is best to avoid manipulating DynAnys containing values that
are shared.

In omniORB, when a value inside an Any is converted into a DynAny, the
value's state is copied into the DynAny, and manipulated there. When
converting back to an Any a new value is created. This means that any
other references to the original value (whether themselves inside Anys
of not) still relate to the original value, with unchanged state.
However, this copying only occurs when a DynValue is actually created,
so for example a structure with two value members referring to the
same value can manipulated inside a DynAny without breaking the
sharing, provided the value members are not accessed as DynAnys.
Extracting the value members as ValueBase will reveal the sharing, for
example.


\section{Local Interfaces}
\label{sec:LocalInterfaces}

Local interfaces are somewhat under-specified in the C++ mapping. This
section outlines the way local interfaces are supported in omniORB,
and details the limitations and issues.

\subsection{Simple local interfaces}

With simple IDL, there are no particular issues:

\begin{idllisting}
module Test {
  local interface Example {
    string hello(in string arg);
  };
};
\end{idllisting}

The IDL compiler generates an abstract base class
\type{Test::Example}. The application defines a class derived from it
that implements the abstract \op{hello} member function. Instances of
that class can then be used where the IDL specifies interface
\type{Example}.

Note that, by default, local interface implementations have no
reference counting behaviour. If the local object should be deleted
when the last reference is released, the application must implement
the \op{\_add\_ref} and \op{\_remove\_ref} virtual member functions
within the implementation class. Make sure that the implementations
are thread safe.


\subsection{Inheritance from unconstrained interfaces}

Local interfaces can inherit from unconstrained (i.e.\ non-local)
interfaces:

\begin{idllisting}
module Test {
  interface One {
    void problem(inout string arg);
  };
  local interface Two : One {
  };

  interface Receiver {
    void setOne(in One a);
  };
};
\end{idllisting}

IDL like this leads to two issues to do with omniORB's C++ mapping
implementation.

First, an instance of local interface \type{Two} should be suitable to
pass as the argument to the \op{setOne} method of a \type{Receiver}
object (as long as the object is in the same address space as the
caller). Therefore, the \type{Two} abstract base class has to inherit
from the internal class omniORB uses to map object references of type
\type{One}. For performance reasons, the class that implements
\type{One} object references normally has non-virtual member
functions. That means that the application-supplied \op{problem}
member function for the implementation of local interface \type{Two}
will not override the base class's version. To overcome this, the IDL
for the base unconstrained interface must be compiled with the
\cmdline{-Wbvirtual-objref} switch to omniidl. That makes the member
functions of the mapping of \type{One} into virtual functions, so they
can be overridden.

The second problem is that, in some cases, omniORB uses a different
mapping for object reference member functions than the mapping used in
servant classes. For example, in the \op{problem} operation, it uses
an internal type for the inout string argument that avoids memory
issues if the application uses a \type{String\_var} in the argument.
This means that the abstract member function declared in the
\type{Two} class (and implemented by the application) has a different
signature to the member function in the base class. The
application-supplied class will therefore not properly override the
base class method. In all likelihood, the C++ compiler will also
complain that the two member functions are ambiguous. The solution to
this problem is to use the implementation mapping in the base object
reference class, rather than the normal object reference mapping,
using the \cmdline{-Wbimpl-mapping} switch to omniidl. The consequence
of this is that some uses of \code{\_var} types for inout arguments
that are normally acceptable in omniORB can now lead to memory
management problems.

In summary, to use local interfaces derived from normal unconstrained
interfaces, you should compile all your IDL with the omniidl flags:

\begin{quote}
\cmdline{-Wbvirtual-objref -Wbimpl-mapping}
\end{quote}


\subsection{Valuetypes supporting local interfaces}

According to the IDL specification, it should be possible to declare a
valuetype that supports a local interface:

\begin{idllisting}
local interface I {
  void my_operation();
};
valuetype V supports I {
  public string s;
};
\end{idllisting}

omniidl accepts the IDL, but unfortunately the resulting C++ code does
not compile. The C++ mapping specification has a problem in that both
the \type{CORBA::\dsc{}LocalObject} and \type{CORBA::ValueBase}
classes have \op{\_add\_ref} and \op{\_remove\_\dsc{}ref} member
functions defined. The classes generated for the valuetype inherit
from both these base classes, and therefore have an ambiguity. Until
the C++ mapping resolves this conflict, valuetypes supporting local
interfaces cannot be used in omniORB.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Asynchronous Method Invocation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:ami}

omniORB 4.2 supports Asynchronous Method Invocation, AMI, as defined
in the CORBA Messaging specification. It supports both the polling and
callback models of asynchronous calls. Note that omniORB does not
support the other parts of the Messaging specification such as Quality
of Service, Routing and Persistent requests.

While omniORB mainly targets the 2.6 version of the CORBA
specification, the AMI support follows the CORBA Messaging
specification as described in the CORBA 3.1 specification, chapter
17~\cite{corba31-spec}. That version of the specification is largely
the same as the one in CORBA 2.6. The only significant difference is
that exception replies in the callback model use a simpler
interface-independent mapping.

\section{Implied IDL}

AMI works by defining some additional \term{implied IDL} for each
interface in the real IDL. The implied IDL contains type and
operation definitions that enable asynchronous calls.

As a guide to the implied IDL, there is a special \cmdline{ami}
back-end to omniidl that outputs the implied IDL for the given input
IDL. For example, given the Echo example IDL:

\begin{idllisting}
// echo.idl
interface Echo {
  string echoString(in string mesg);
};
\end{idllisting}

\noindent You can output the implied IDL using

\begin{quote}
\cmdline{omniidl -bami echo.idl}
\end{quote}

\noindent That outputs the following to standard out:

\begin{idllisting}
// ReplyHandler for interface Echo
interface AMI_EchoHandler : Messaging::ReplyHandler {
  void echoString(in string ami_return_val);
  void echoString_excep(in ::Messaging::ExceptionHolder excep_holder);
};

// Poller valuetype for interface Echo
abstract valuetype AMI_EchoPoller : Messaging::Poller {
  void echoString(in unsigned long ami_timeout, out string ami_return_val);
};

// AMI implied operations for interface Echo
interface Echo {
  void sendc_echoString(in ::AMI_EchoHandler ami_handler, in string mesg);
  ::AMI_EchoPoller sendp_echoString(in string mesg);
};
\end{idllisting}

\noindent Alternatively, you can use the \cmdline{-Wbdump} option to
output an interleaved version that shows the original IDL and the
implied IDL together.

Note that the implied IDL output is for information only. You should
not compile it, but rather instruct the omniidl C++ back-end to
generate the corresponding C++ definitions.


\section{Generating AMI stubs}

To generate stub code including AMI types and operations, give the
\cmdline{-Wbami} command line option to omniidl's \cmdline{cxx}
back-end:

\begin{quote}
\cmdline{omniidl -bcxx -Wbami echo.idl}
\end{quote}

\noindent That generates the normal C++ stubs and skeletons, plus all
the definitions in the implied IDL.


\section{AMI examples}

Example AMI clients for the \intf{Echo} server can be found in
\file{src/examples/ami}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Interface Type Checking}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{ch_intf}

This chapter describes the mechanism used by omniORB to ensure type
safety when object references are exchanged across the network. This
mechanism is handled completely within the ORB. There is no
programming interface visible at the application level. However, for
the sake of diagnosing the problem when there is a type violation, it
is useful to understand the underlying mechanism in order to interpret
the error conditions reported by the ORB.

\section{Introduction}

In GIOP/IIOP, an object reference is encoded as an Interoperable
Object Reference (IOR) when it is sent across a network connection.
The IOR contains a Repository ID (RepoId) and one or more
communication profiles. The communication profiles describe where and
how the object can be contacted. The RepoId is a string which uniquely
identifies the IDL interface of the object.

Unless the \code{ID} pragma is specified in the IDL, the ORB generates
the RepoId string in the so-called OMG IDL Format\footnote{For further
details of the repository ID formats, see section 10.6 in the CORBA
2.6 specification.}. For instance, the RepoId for the \intf{Echo}
interface used in the examples of chapter~\ref{chap:basic} is
\texttt{IDL:Echo:1.0}.

When interface inheritance is used in the IDL, the ORB always sends the
RepoId of the most derived interface. For example:

\begin{idllisting}
   // IDL
   interface A {
     ...
   };
   interface B : A {
     ...
   };
   interface C {
      void op(in A arg);
   };
\end{idllisting}

\begin{cxxlisting}
   // C++
   C_ptr server;
   B_ptr objB;
   A_ptr objA = objB;
   server->op(objA);  // Send B as A
\end{cxxlisting}

In the example, the operation \op{C::op} accepts an object reference
of type \type{A}. The real type of the reference passed to \op{C::op}
is \type{B}, which inherits from \type{A}. In this case, the RepoId of
\type{B}, and not that of \type{A}, is sent across the network.

The GIOP/IIOP specification allows an ORB to send a null string in the
RepoId field of an IOR. It is up to the receiving end to work out the
real type of the object. omniORB never sends out null strings as
RepoIds, but it may receive null RepoIds from other ORBs. In that
case, it will use the mechanism described below to ensure type safety.


\section{Interface Inheritance}

When the ORB receives an IOR of interface type B when it expects the
type to be A, it must find out if B inherits from A. When the ORB has
no local knowledge of the type B, it must work out the type of B
dynamically.

The CORBA specification defines an Interface Repository (IR) from
which IDL interfaces can be queried dynamically. In the above
situation, the ORB could contact the IR to find out the type of B.
However, this approach assumes that an IR is always available and
contains the up-to-date information of all the interfaces used in the
domain. This assumption may not be valid in many applications.

An alternative is to use the \op{\_is\_a} operation to work out the
actual type of an object. This approach is simpler and more robust
than the previous one because no 3rd party is involved, so this is
what omniORB does.

\begin{cxxlisting}
class Object{
    CORBA::Boolean _is_a(const char* type_id);
};
\end{cxxlisting}

The \op{\_is\_a} operation is part of the \intf{CORBA::Object}
interface and must be implemented by every object. The input argument
is a RepoId. The function returns \code{true} if the object is really
an instance of that type, including if that type is a base type of the
most derived type of that object.

In the situation above, the ORB would invoke the \op{\_is\_a}
operation on the object and ask if the object is of type A
\emph{before} it processes any application invocation on the object.

Notice that the \op{\_is\_a} call is \emph{not} performed when the IOR
is unmarshalled. It is performed just prior to the first application
invocation on the object. This leads to some interesting failure modes
if B reports that it is not an A. Consider the following example:

\begin{idllisting}
// IDL
interface A { ... };
interface B : A { ... };
interface D { ... };
interface C {
  A      op1();
  Object op2();
};
\end{idllisting}

\lstset{numbers=left,gobble=4}
\begin{cxxlisting}
 1  // C++
 2  C_ptr objC;
 3  A_ptr objA;
 4  CORBA::Object_ptr objR;
 5
 6  objA =  objC->op1();
 7  (void) objA->_non_existent();
 8
 9  objR =  objC->op2();
10  objA =  A::_narrow(objR);
\end{cxxlisting}
\lstset{numbers=none,gobble=0}

\noindent If the stubs of A,B,C,D are linked into the executable and:

\begin{description}
\item[Case 1] \op{C::op1} and \op{C::op2} return a B. Lines 6--10
complete successfully. The remote object is only contacted at line 7.

\item[Case 2] \op{C::op1} and \op{C::op2} return a D. This condition
only occurs if the runtime of the remote end is buggy. Even though the
IDL definitions show that D is not derived from A, omniORB gives it
the benefit of the doubt, in case it actually has a more derived
interface that is derived from both A and D. At line 7, the object is
contacted to ask if it is an A. The answer is no, so a
\code{CORBA::INV\_OBJREF} exception is raised. At line 10, the narrow
operation will fail, and objA will be set to nil.
\end{description}

\noindent If only the stubs of A are linked into the executable and:

\begin{description}
\item[Case 1] \op{C::op1} and \op{C::op2} return a B. Lines 6--10
complete successfully. When lines 7 and 10 are executed, the object is
contacted to ask if it is an A.

\item[Case 2] \op{C::op1} and \op{C::op2} return a D. This condition
only occurs if the runtime of the remote end is buggy. Line 6
completes and no exception is raised. At line 7, the object is
contacted to ask if it is an A. If the answer is no, a
\code{CORBA::INV\_OBJREF} exception is raised. At line 10, the narrow
operation will fail, and objA will be set to nil.
\end{description}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Packaging stubs into DLLs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:dlls}


omniORB's stubs can be packaged into shared libraries or DLLs. On Unix
platforms this is mostly painless, but on Windows things are slightly
more tricky.


\section{Dynamic loading and unloading}

As long as your platform supports running static initialisers and
destructors as libraries are loaded and unloaded, you can package
stubs into shared libraries / DLLs, and load them dynamically at
runtime.

There is one minor problem with this, which is that normally nil
object references are heap allocated, and only deallocated when the
ORB is destroyed. That means that if you unload a stub library from
which nil references have been obtained (just by creating an object
reference \_var for example), there is a risk of a segmentation fault
when the ORB is destroyed. To avoid that problem, define the
\code{OMNI\_UNLOADABLE\_STUBS} C pre-processor symbol while you are
compiling the stub files. Unfortunately, with that define set, there
is a risk that object reference \_vars at global scope will segfault
as they are unloaded. You must not create \_vars at global scope if
you are using \code{OMNI\_UNLOADABLE\_STUBS}.


\section{Windows DLLs}

On Unix platforms, the linker figures out how to link the symbols
exported by a library in to the running program. On Windows,
unfortunately, you have to tell the linker where symbols are coming
from. This causes all manner of difficulties.

\subsection{Exporting symbols}

To (statically) link with a DLL file in Windows, you link with a LIB
file which references the symbols exported from the DLL. To build the
LIB and DLL files, the correct symbols must be exported. One way to do
that is to decorate the source code with magic tags that tell the
compiler to export the symbols. The alternative is to provide a DEF
file that lists all the symbols to be exported. omniORB uses a DEF
file.

The question is, how do you create the DEF file?  The answer is to use
a Python script named \cmdline{makedeffile.py} that lives in the
\file{bin\scripts} directory in the omniORB distribution.
\cmdline{makedeffile.py} runs the dumpbin program that comes with
Visual C++, and processes its output to extract the necessary symbols.
Although it is designed for exporting the symbols from omniORB stub
files, it can actually be used for arbitrary C++ code. To use it to
create a DLL from a single source file, use the following steps:

\begin{enumerate}
\item Compile the source:

  \cmdline{cl -c -O2 -MD -GX -Fofoo.o -Tpfoo.cc}

\item Build a static library (It probably won't work on its own due to
      the -MD switch to cl, but we just need it to get the symbols
      out):

  \cmdline{lib -out:foo\_static.lib foo.o}

\item Use the script to build a .def file:

  \cmdline{makedeffile.py foo\_static.lib foo 1.0 foo.def}

\item Build the .dll and .lib with the def file.

  \cmdline{link -out:foo.dll -dll -def:foo.def -implib:foo.lib foo.o}
\end{enumerate}

Of course, you can link together many separate C++ files, rather than
just the one shown here.


\subsection{Importing constant symbols}

As if exporting the symbols from a DLL was not complicated enough, any
constant values exported by a DLL have to be explicitly
\emph{imported} into the code using them. omniORB's stub files declare
a number of such constants. This time, the constant declarations in
the generated header files are decorated in a way that tells the
compiler what to do. When the stub headers are \#included, the correct
pre-processor defines must be set. If things are not set correctly,
the code all links without problems, but then mysteriously blows up at
run time.

Depending on how complex your situation is, there are a range of
solutions. Starting with the simplest, here are some scenarios you may
find yourself in:

\begin{enumerate}

\item All stub code, and all code that uses it is wrapped up in a
      single DLL.

      Do nothing special.

\item All stub code is in a single DLL. Code using it is in another
      DLL, or not in a DLL at all.

      \code{\#define USE\_stub\_in\_nt\_dll} before \code{\#include} of
      the stub headers.

\item The stubs for each IDL file are in separate DLLs, one DLL per
      IDL file.

      In this case, if the IDL files \code{\#include} each other, then
      when the stub files are compiled, import declarations are needed
      so that references between the separate DLLs work. To do this,
      first compile the IDL files with the \cmdline{-Wbdll\_stubs}
      flag:

      \cmdline{omniidl -bcxx -Wbdll\_stubs example.idl}

      Then define the \code{INCLUDED\_stub\_in\_nt\_dll} pre-processor
      symbol when compiling the stub files. As above, define
      \code{USE\_stub\_in\_nt\_dll} when including the stub headers
      into application code.

\item Stubs and application code are packaged into multiple DLLs, but
      DLLs contain the stubs for more than one IDL file.

      This situation is handled by `annotating' the IDL files to
      indicate which DLLs they will be compiled into. The annotation
      takes the form of some \code{\#ifdefs} to be inserted in the
      stub headers. For example,

\begin{idllisting}
// one.idl

#pragma hh #ifndef COMPILING_FIRST_DLL
#pragma hh # ifndef USE_stub_in_nt_dll
#pragma hh #   define USE_stub_in_nt_dll
#pragma hh # endif
#pragma hh #endif

#include <two.idl>

module ModuleOne {
  ...
};


// two.idl

#pragma hh #ifndef COMPILING_SECOND_DLL
#pragma hh # ifndef USE_stub_in_nt_dll
#pragma hh #   define USE_stub_in_nt_dll
#pragma hh # endif
#pragma hh #endif

#include <three.idl>
...
\end{idllisting}

      Here, \file{one.idl} is packaged into \file{first.dll} and
      \file{two.idl} is in \file{second.dll}. When compiling
      \file{first.dll}, the \code{COMPILING\_FIRST\_DLL} define is
      set, meaning definitions from \file{one.idl} (and any other
      files in that DLL) are not imported. Any other module that
      includes the stub header for \file{one.idl} does not define
      \code{COMPILING\_FIRST\_DLL}, and thus imports the necessary
      symbols from the DLL.

      Rather than explicitly listing all the pre-processor code, it
      can be cleaner to use a C++ header file for each DLL. See the
      COS services IDL files in \file{idl/COS} for an example.

\end{enumerate}



\chapter{Resources}

There are a number of useful online resources related to omniORB:

\begin{itemize}

\item \url{https://www.omniorb.net/} is the main omniORB web
  site.

\item The omniORB mailing list is the first port of call for questions
  that are not answered in this document or in the FAQ. Subscription
  information and archives are at
  \url{https://www.omniorb.net/list.html}

\item Commercial support is available from
  \url{https://www.omniorb-support.com/}

\end{itemize}


\backmatter

\bibliography{omniORB}

\end{document}
